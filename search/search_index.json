{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CS2030S Programming Methodology II AY 2020/21 Semester 2 This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above. Other Critical Web Resources Piazza for Q&A and discussions LumiNUS for all other information (administration, logistic) and tools (surveys, grades). GitHub (under your own account) for accessing feedback of your labs.","title":"Home"},{"location":"index.html#cs2030s-programming-methodology-ii","text":"","title":"CS2030S Programming Methodology II"},{"location":"index.html#ay-202021-semester-2","text":"This website hosts the lecture notes, lecture slides, and other written guides about CS2030S. You can explore the links on the menu on the left, or search for keywords in the search bar above.","title":"AY 2020/21 Semester 2"},{"location":"index.html#other-critical-web-resources","text":"Piazza for Q&A and discussions LumiNUS for all other information (administration, logistic) and tools (surveys, grades). GitHub (under your own account) for accessing feedback of your labs.","title":"Other Critical Web Resources"},{"location":"00-overview.html","text":"Unit 0. Overview Learning Outcomes This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other. What is This Module About? CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming language constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented and functional paradigms as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules. The Choice of Java We decided to use one programming language throughout the module. This decision means that we need to pick a language which is strongly typed with static typing, and supports both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module. What This Module is not About This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, CS2030/S is not a module that focuses on computational efficiency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concerned with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency. Taming Complexity in Software Development An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who has gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software program rarely solves a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in your introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software evolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago. Strategies to Tame Complexity Good Software Development Practices If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices. Functions You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions are an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition. The Abstraction Principle The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as parameterized types or subtypes, and (ii) to sub-computation, abstracting them out as first-class functions. These concepts: generics, subtypes, first-class functions, underlies most of the content of CS2030/S. Erecting an Abstraction Barrier Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier, exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also variables and computations on these variables together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction . Code for Change The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritance and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way. Types Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that governs how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, parameterized types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define parameterized types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages. Eliminating Side Effects We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"0. Overview"},{"location":"00-overview.html#unit-0-overview","text":"","title":"Unit 0. Overview"},{"location":"00-overview.html#learning-outcomes","text":"This unit provides an overview of the aims of CS2030/S and how the key concepts covered in CS2030/S are related to each other.","title":"Learning Outcomes"},{"location":"00-overview.html#what-is-this-module-about","text":"CS2030/S is designed for students who have gone through a typical basic programming module module and have learned about problem solving with simple programming constructs such as loops, conditions, and functions. In a typical introductory programming module, such as CS1010 and its variants at NUS, students tend to write small programs (in the order of tens or hundreds of lines of code) to solve a programming homework problem, work alone on their code, and move on to solve the next problem once the homework is done. The first aim of CS2030/S is to change the students' mindset and to make them learn to write software that will continue to evolve as software requirements change, and to write software that will be read and modified by other programmers (including their future selves). The second aim of CS2030/S is to level-up the complexity of programs that the students write, from order of hundreds of lines to thousands of lines. CS2030/S bridges the students between writing toy programs to solve specific problem in CS1010 and writing larger real-world software in their later modules, such as CS2103 Software Engineering. A programming language is the medium in which programmers can express their intention and construct software, and thus is critical to supporting the aims above. With the appropriate features and tools, one can tame the complexity of software, make the code written friendlier to other programmers, and easier to evolve. The third aim of CS2030/S is thus to expand the students' mind on different ways one can construct software and the principles behind some of the programming language constructs. In particular, CS2030/S focuses on objects, types, and functions, as three key constructs towards building programmer-friendly software. It covers both object-oriented and functional paradigms as two different approaches to construct software, with a strong emphasis on type safety. The final aim of CS2030/S is to introduce students to programming language concepts, to bridge them from introductory programming to advanced modules such as programming language design and implementations. Part of CS2030/S introduces students to the design decisions behind some of the constraints and the workings behind the programming language compilation and execution, giving them a glimpse inside the programming system that so far has been mostly treated as a black box in introductory modules.","title":"What is This Module About?"},{"location":"00-overview.html#the-choice-of-java","text":"We decided to use one programming language throughout the module. This decision means that we need to pick a language which is strongly typed with static typing, and supports both object-oriented and functional programming. Considering multiple factors, we decided to choose Java for CS2030/S, for its popularity, syntax familiarity, and smoother transitions to later modules in the NUS computing curriculum. While Java is definitely not the most elegant programming language when expressing programs in functional style, we hope that students can still learn the principles of functional programming and apply it in other programming languages. This choice is a trade-off between having to switch to a different language in the middle of a module.","title":"The Choice of Java"},{"location":"00-overview.html#what-this-module-is-not-about","text":"This is not a module on Java programming. We will not comprehensively cover Java syntax and features, except those relevant to the concepts we teach. In fact, we will avoid and even ban students from using certain Java features (such as var ) for pedagogical purposes. This is not a module on software engineering either. Software engineering is a broad discipline on its own and deserves another module. Rather, this module is about the programming principles and constructs on top of which programmers can design better software. To motivate the importance of these principles and constructs and see how they can be used, we will inevitably cover some of the software engineering design principles, such as the Liskov's Substitution Principle (the L in SOLID), Tell-Don't-Ask, Composition over Inheritance, etc. But we will not comprehensively cover object-oriented design or software design in general (e.g., we will not cover S,O,I,D in SOLID). Finally, CS2030/S is not a module that focuses on computational efficiency. We have CS2040/S for that. In CS2030/S, although reducing computational cost still plays a role, this is not the only cost that matters. CS2030/S is also concerned with the human cost of debugging or maintaining software. In striving for simpler software that is easier to maintain and extend, we may have to sacrifice computational efficiency.","title":"What This Module is not About"},{"location":"00-overview.html#taming-complexity-in-software-development","text":"An underlying theme of CS2030/S is taming complexity in software development. There are objective metrics with which one can measure the complexity of software, but here, we will loosely define complexity as anything that increases the likelihood of bugs in a program. Let's start by considering a simplified view of what a software program is. One can view a software program as a collection of data variables and instructions on how to modify these variables. A program is generally written to meet a given requirement: given one or more input variables, the program should perform the computation to produce the output variables, in a way that meets the requirement. Often, the program stores information in the intermediate variables while performing the computation. As a student who has gone through an introductory programming module such as CS1010 and its variants, you should be familiar with the view above, and you should have some experience writing program to solve a given computational problem. The program you have written for these introductory modules are small \"toy\" programs mostly -- they consists of only a few hundreds of lines and tens of variables, at most. Software development in the real world, however, is far more complex than what you have experienced. A software program rarely solves a well-defined computational problem only. It often requires multiple components, such as user interface, data storage, and business rules, interacting with each other in an intricate manner to attain a set of functionalities. As the requirement of the software becomes more complex, the number of variables that needs to be kept track of increases; the logic of the computation the programmer needs to maintain the variables becomes more complicated. Further, it is often that the variables are inter-dependent of each other. For instance, updating a variable might require updating another; how a variable should be updated might depend on another variable. As the number of variables increases, so is the number of relationships between the variables that the programer has to keep track of. Failure to correctly maintain the variables and the relationship between them most likely will lead to bugs. Further, real world software rarely remains static. This property, is again different from what you have experienced in your introductory programming module, where once the instructors release a programming homework, they rarely go back and change the requirement. In the real world, software evolves over time -- new features are added, business rules changes, better algorithms are deployed. The code needs to be updated accordingly -- adding new variables and new computation; changing how variables are updated or are dependent on each other. Updating the code of an already-complex software program to keep up with the requirement, if not managed properly, can lead to bugs. Real world software is often the product of teamwork from multiple programmers, where the software development process is unlike what you have experienced in your introductory programming module, where you solve your homework individually. When multiple programmers work together, the interdependency between the states need to be communicated and handled properly and consistently across the programmers. One programmer's modification to the code should not introduce bugs into another programmer's code. Since software evolves over time, the notion of \"multiple programmers\" actually applies even to software developed by a single lone programmer across time. Changing one's code should not introduce new bugs to other parts of the code that is written some time ago.","title":"Taming Complexity in Software Development"},{"location":"00-overview.html#strategies-to-tame-complexity","text":"","title":"Strategies to Tame Complexity"},{"location":"00-overview.html#good-software-development-practices","text":"If you are taught properly in your introductory programming modules, you should already be familiar with some of the good programming practices that help to tame the complexity and reduce the chances of bugs. These practices include Comment your code: Commenting your code provides in situ communication between you and other programmers on the team, as well as between you and your future self, on the non-obvious purpose of the states and the relationships between the states. Such comments help to enhance the understanding of what the code is doing and to remind whoever is updating to code to modify appropriately when the requirement changes. Use a coding convention: Adhering to a coding convention helps improves code readability, reducing the cognitive barrier when one programmer reads another programmer's code and allowing the reader to understand the code more easily and thoroughly. CS2030/S will continue to enforce these good programming practices.","title":"Good Software Development Practices"},{"location":"00-overview.html#functions","text":"You should also be taught to always break you code down into functions, each one performs a simple, specific, task. The functions can then be composed to solve larger and more complex tasks. Functions are an important programming structure in taming code complexity, it allows programmers to (i) compartmentalize computation and its effects, reducing the amount of interactions to a few well defined ones (through arguments and return values); (ii) hide the implementation details so that they can be changed later without affecting other parts of the code; (iii) reuse computations and thus write code that is more succinct and easier to understand/change. In CS2030/S, you will not only continue to break your computation into functions, but we will kick it up several notches. A major part of CS2030/S is to introduce you to more programming paradigms and language tools that allow you to compartmentalize computations, hide details, and reduce repetition.","title":"Functions"},{"location":"00-overview.html#the-abstraction-principle","text":"The last point above about why it is important to code in small, reusable functions, follows what is called the Abstraction Principle 1 . The principle states that: \"Each significant piece of functionality in a program should be implemented in just one place in the source code. Where similar functions are carried out by distinct pieces of code, it is generally beneficial to combine them into one by abstracting out the varying parts.\" This principle is something that we will visit over and over again in CS2030/S, applying it to different varying parts of a program. In the case of functions, the \"varying parts\" are the values on which we wish to perform the computation on. We will also apply this principle to (i) types, abstracting them out as parameterized types or subtypes, and (ii) to sub-computation, abstracting them out as first-class functions. These concepts: generics, subtypes, first-class functions, underlies most of the content of CS2030/S.","title":"The Abstraction Principle"},{"location":"00-overview.html#erecting-an-abstraction-barrier","text":"Another important strategy for taming complexity is the abstraction barrier . Let's separate the role of a programmer into two, in the context of writing functions: the implementer , who implements the function, and a client , who calls the function. The implementer should compartmentalize the internal variables and the implementation of the function, hiding them behind the abstraction barrier, exposing the parameters and return values as the only communication gateways across the barrier. The abstraction barrier is something that we will refer to repeatedly in CS2030/S as well. We will see how we maintain this barrier not only in the context of functions, but also variables and computations on these variables together, by encapsulating them as objects , and hiding details from the client through access modifiers . These ideas form two of the core principles of object-oriented programming : encapsulation and abstraction .","title":"Erecting an Abstraction Barrier"},{"location":"00-overview.html#code-for-change","text":"The abstraction barrier, if erected and maintained properly, reduces code complexity. It, however, also reduces the flexibility as the software evolves. If the client wishes to modify the computation protected by the abstraction barrier, it will need the help of the implementer. In CS2030/S, we will see two ways we can modify the computation behind the abstraction barrier, without changing the code behind the barrier . First, we will introduce the concept of inheritance and polymorphism , the other two core principles of object-oriented programming. These object-oriented mechanisms allow programmers to easily extend or modify the behavior of existing code. Second, we will introduce closure , an abstraction to a computation and its environment, that we can pass into the functions behind the abstraction barrier to perform a computation. The second idea, if carried to the extreme in terms of flexibility, leads to the concept of monad in functional programming paradigm. A monad is a computational structure that allows objects to be composed and manipulated in a succinct and powerful way.","title":"Code for Change"},{"location":"00-overview.html#types","text":"Allowing a programmer to change the behavior of the existing code without changing the code could lead to more bugs, if not managed properly. To prevent this, both the programming language system, and the programmers, have to adhere to certain rules when extending or modifying the behavior of the existing code. Java and many other typed languages have type systems -- a set of rules that governs how variables, expressions, and functions interact with each other. You will learn about subtyping and the Liskov Substitution Principle, two notions that are important to constraining how inheritance and polymorphism should be used to avoid bugs. A type system is also an important tools to reduce the complexity of software development. By constraining the interactions among the variables, expressions, functions, it reduces the possible interdependence between these programming constructs. Furthermore, any attempt by programmers to break the constraint can be caught automatically. By utilizing the type system properly, we can detect potential bugs before it manifests itself. A reason CS2030/S chooses to use Java is due to its type system. CS2030/S will introduce the concept of types, subtypes, compile-time vs. run-time types, variants of types, parameterized types, and type inferences, in the context of Java. We will see how we can define our own types (using classes and interfaces ) and define relationships between them. We will see how we can define parameterized types and generic functions that takes in types as parameters. These concepts are applicable to many other programming languages.","title":"Types"},{"location":"00-overview.html#eliminating-side-effects","text":"We have discussed how functions can compartmentalize computations and isolate its complexity to within its body. For this approach to be effective, the function must not have any side effect -- such as updating a variable that is not within the function. Such functions, called pure functions , is one of the key principles of the functional programming paradigm, and is something that we will explore to kick off the section on functional paradigm in CS2030/S. A related idea in object-oriented programming we will cover in CS2030/S is immutability -- once we create an object, the object cannot be changed. In order to update an object, we need to create a new one. With immutability and pure functions, we can guarantee that the same function invoked on the same objects will always return the same value. This certainty can help in understanding and reasoning about the code behavior. This principle is formulated by Benjamin C. Pierce in his book \"Types and Programming Languages.\" \u21a9","title":"Eliminating Side Effects"},{"location":"01-compiler.html","text":"Unit 1: Program and Compiler After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time Software Program A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer. Compiled vs. Interpreted Programs The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first). Compiling and Running Java Programs Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 . Interpreting a Java program Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution. Compiler The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"1. Program and Compiler"},{"location":"01-compiler.html#unit-1-program-and-compiler","text":"After reading this unit, students should: recap some fundamental programming concepts, including the concept of a program, a programming language, a compiler, and an interpreter be aware of two modes of running a Java program (compiled vs. interpreted) be aware that compile-time errors are better than run-time errors, but the compiler cannot always detect errors during compile time","title":"Unit 1: Program and Compiler"},{"location":"01-compiler.html#software-program","text":"A software program is a collection of data variables and instructions on how to modify these variables. To dictate these instructions to the computer, programmers usually write down the instructions using a programming language, expressing their instructions in code that are made up of keywords, symbols, and names. A programming language is a formal language that helps programmers specify precisely what the instructions are at a higher level of abstraction (i.e., at a higher conceptual level) so that a programmer only needs to write a few lines of code to give complex instructions to the computer.","title":"Software Program"},{"location":"01-compiler.html#compiled-vs-interpreted-programs","text":"The processing unit of a computer can only accept and understand instructions written in machine code. A program, written in a higher-level programming language, therefore needs to be translated into machine code before execution. There are different approaches to how such translations can be done. The first approach uses a compiler -- a software tool that reads in the entire program written in a higher-level programming language and translates it into machine code. The machine code is then saved into an executable file, which can be executed later. clang , a C/C++ compiler, is an example. The second approach uses an interpreter -- software that reads in the program one statement at a time interprets what the statement means, and executes its directly. This is how Python and Javascript programs are executed. Modern programming systems for executing programs are, however, more sophisticated. V8, for instance, is an open-source engine that executes Javascript, and it contains both an interpreter that first interprets a Javascript into bytecode (an intermediate, low-level representation). A just-in-time compiler then reads in the bytecode and generates machine code dynamically at runtime with optimized performance. Java programs, on the other hand, can be executed in two ways. The Java program can first be compiled into bytecode. During execution, the bytecode is interpreted and compiled on-the-fly by the Java Virtual Machine (JVM) into machine code. The Java program can also be interpreted by the Java interpreter. Since CS2030/S uses Java, let's look at the two approaches in more detail (without worrying about how to write a single line of Java first).","title":"Compiled vs. Interpreted Programs"},{"location":"01-compiler.html#compiling-and-running-java-programs","text":"Suppose we have a Java program called Hello.java . To compile the program, we type 1 1 $ javac Hello.java into the command line. javac is the Java compiler. This step will either lead to the bytecode called Hello.class being created or spew out some errors. Assuming that there is no error, we can now run 1 $ java Hello to invoke the JVM java and execute the bytecode contains in Hello.class . Beginners tend to confuse between javac and java , and whether to add the extension .java or .class when compiling and executing a Java program. Do take note and refer back here if needed 2 .","title":"Compiling and Running Java Programs"},{"location":"01-compiler.html#interpreting-a-java-program","text":"Java (version 8 or later) comes with an interpreter called jshell that can read in Java statements, evaluate them, and print the results 3 . jshell is useful for learning and experimenting about Java. To run jshell in interactive mode, we type 1 $ jshell on the command line, which causes an interactive prompt to appear: 1 2 3 4 5 $ jshell | Welcome to JShell -- Version 11.0.2 | For an introduction type: /help intro jshell> We can now type in Java code on jshell> . Alternatively, we can also include all the Java statements that we want jshell to run in a file and pass it into jshell 1 $ jshell Hello.jsh While jshell is a convenient way to test things out and play with new Java concepts as we learn, do keep in mind that jshell combined both compilation and run-time into a single step. The error spewed out by jshell could be either compile-time error or run-time error, and this could be confusing to beginners who try to distinguish between the two phases of program execution.","title":"Interpreting a Java program"},{"location":"01-compiler.html#compiler","text":"The compiler does more than just translating source code into machine code or bytecode. The compiler also needs to parse the source code written and check if it follows the precise specification of the programming language (called grammar ) used, and produces a syntax error if the grammar is violated. It therefore can detect any syntax error before the program is run. It is much better for a programmer to detect any error in its code during compilation -- since this is the phase when the program is still being developed and under the control of the programmer. Runtime error, on the other hand, might occur when the customers are running the program, and so are much less desirable. As such, we try to detect errors as much as possible during compilation. The compiler is a powerful friend for any programmer if used properly. The power of the compiler, however, is limited. A compiler can only read and analyze the source code without actually running it. Without running the program, the compiler cannot always tell if a particular statement in the source code will ever be executed; it cannot always tell what values a variable will take. To deal with this, the compiler can either be conservative , and report an error as long as there is a possibility that a particular statement is incorrect; or, the compiler can be more permissive , reporting an error only if there is no possiblity that a particular statement is correct. If there is a possibility that a particular statement is correct, it does not throw an error, but rely on the programmer to do the right thing. We will further contrast these two behaviors later in this module. The $ represents the command prompt in a shell and you do not need to type this. \u21a9 To add to the confusion, Java 11 introduces a shortcut where we can run java Hello.java directly. This command causes Hello.java to be compiled and executed in a single step. We won't do this in CS2030/S (i) to avoid confusion and (ii) to show you the steps explicitly. \u21a9 Such a program is called REPL (Read-Evaluate-Print in a Loop) for short. \u21a9","title":"Compiler"},{"location":"02-type.html","text":"Unit 2: Variable and Type After this unit, students should be able to: appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed. Data Abstraction: Variable One of the important abstractions that are provided by a programming language is the variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location. Type As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 . Dynamic vs. Static Type Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early. Strong Typing vs. Weak Typing A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly typed language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string as an int? ok, as you wish! The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following compile-time error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense. Type Checking with A Compiler In addition to checking for syntax errors, the compiler can check for type compilability according to the compile-time type, to catch possible errors as early as possible. Such type checking is made possible with static typing. Consider the following Python program: 1 2 3 4 5 i = 0 while ( i < 10 ): # do something that takes time i = i + 1 print ( \"i is \" + i ) The type mismatch error on Line 5 is only caught when Line 5 is executed. Since the type of the variable i can change during run time, Python (and generally, dynamically typed languages) can not tell if Line 5 will lead to an error until it is evaluated at run-time. In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed. Primitive Types in Java We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000 ; int j = i ; i = i + 1 ; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j . Subtypes An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) . Subtyping Between Java Primitive Types Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion . Such conversion can happen during assignment or parameter passing. Additional Readings Java Tutorial: Primitive Data Types and other Language Basics","title":"2. Variable and Type"},{"location":"02-type.html#unit-2-variable-and-type","text":"After this unit, students should be able to: appreciate the concept of variables as an abstraction understand the concept of types and subtypes contrast between statically typed language vs. dynamically typed language contrast between strongly typed language vs. weakly typed language be familiar with Java variables and primitive types understand widening type conversion in the context of variable assignments and how subtyping dictates whether the type conversion is allowed.","title":"Unit 2: Variable and Type"},{"location":"02-type.html#data-abstraction-variable","text":"One of the important abstractions that are provided by a programming language is the variable . Data are stored in some location in computer memory. But we should not be referring to the memory location all the time. First, referring to something like 0xFA49130E is not user-friendly; Second, the location may change. A variable is an abstraction that allows us to give a user-friendly name to a piece of data in memory. We use the variable name whenever we want to access the value in that location, and pointer to the variable or reference to the variable whenever we want to refer to the address of the location.","title":"Data Abstraction: Variable"},{"location":"02-type.html#type","text":"As programs get more complex, the number of variables that the programmer needs to keep track of increases. These variables might be an abstraction over different types of data: some variables might refer to a number, some to a string, some to a list of numbers, etc. Not all operations are meaningful over all types of data. To help mitigate the complexity, we can assign a type to a variable. The type communicates to the readers what data type the variable is an abstraction over, and to the compiler/interpreter what operations are valid on this variable and how the operation behaves. In lower-level programming languages like C, the type also informs the compiler how the bit representing the variable should be interpreted. As an example of how types can affect how an operation behaves, let's consider Python. Suppose we have two variables x and y , storing the values 4 and 5 respectively and we run print x + y . If x and y are both strings, you would get 45 ; if x and y are integers, you would get 9 ; if 4 is an integer and 5 is a string, you would get an error. In the last instance above, you see that assigning a type to each variable helps to keep the program meaningful, as the operation + is not defined over an integer and a string in Python. Java and Javascript, however, would happily convert 4 into a string for you, and return 45 .","title":"Type"},{"location":"02-type.html#dynamic-vs-static-type","text":"Python and Javascript are examples of dynamically typed programming languages. The same variable can hold values of different types, and checking if the right type is used is done during the execution of the program. Note that, the type is associated with the values , and the type of the variable changes depending on the value it holds. For example, we can do the following: 1 2 i = 4 // i is an integer i = \"5\" // ok, i is now a string Java, on the other hand, is a statically typed language. We need to declare every variable we use in the program and specify its type. A variable can only hold values of the same type as the type of the variable, so we can't assign, for instance, a string to a variable of type int . Once a variable is assigned a type, its type cannot be changed. 1 2 3 int i ; // declare a variable i = 4 ; // ok i = \"5\" ; // error, cannot assign a string to an `int` The type that a variable is assigned with when we declare the variable is also known as the compile-time type . During the compilation, this is the only type that the compiler is aware of. The compiler will check if the compile-time type matches when it parses the variables, expressions, values, and function calls, and throw an error if there is a type mismatch. This type-checking step helps to catch errors in the code early.","title":"Dynamic vs. Static Type"},{"location":"02-type.html#strong-typing-vs-weak-typing","text":"A type system of a programming language is a set of rules that govern how the types can interact with each other. A programming language can be strongly typed or weakly typed. There are no formal definitions of \"strong\" vs. \"weak\" typing of a programming language, and there is a spectrum of \"strength\" between the typing discipline of a language. Generally, a strongly typed programming language enforces strict rules in its type system, to ensure type safety , i.e., to catch type errors during compile time rather than leaving it to runtime. On the other hand, a weakly typed (or loosely typed ) programming language is more permissive in terms of typing checking. C is an example of a static, weakly typed language. In C, the following is possible: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // you want to treat a string as an int? ok, as you wish! The last line forces the C compiler to treat the string (to be more precise, the address of the string) as an integer, through typecasting. In contrast, if we try the following in Java: 1 2 3 int i ; // declare a variable i = 4 ; // ok i = ( int ) \"5\" ; // error we will get the following compile-time error message: 1 | incompatible types: java.lang.String cannot be converted to int because the compiler enforces a stricter rule and allows typecasting only if it makes sense.","title":"Strong Typing vs. Weak Typing"},{"location":"02-type.html#type-checking-with-a-compiler","text":"In addition to checking for syntax errors, the compiler can check for type compilability according to the compile-time type, to catch possible errors as early as possible. Such type checking is made possible with static typing. Consider the following Python program: 1 2 3 4 5 i = 0 while ( i < 10 ): # do something that takes time i = i + 1 print ( \"i is \" + i ) The type mismatch error on Line 5 is only caught when Line 5 is executed. Since the type of the variable i can change during run time, Python (and generally, dynamically typed languages) can not tell if Line 5 will lead to an error until it is evaluated at run-time. In contrast, statically typed language like Java can detect type mismatch during compile time since the compile-time type of a variable is fixed.","title":"Type Checking with A Compiler"},{"location":"02-type.html#primitive-types-in-java","text":"We now switch our focus to Java, particularly to the types supported. There are two categories of types in Java, the primitive types and the reference types . We will first look at primitive types in this unit. Primitive types are types that holds numeric values (integers, floating-point numbers) as well as boolean values ( true and false ). For storing integral values, Java provides four types, byte , short , int , and long , for storing 8-bit, 16-bit, 32-bit, 64-bit signed integers respectively. The type char stores 16-bit unsigned integers representing UTF-16 Unicode characters. For storing floating-point values, Java provides two types, float and double , for 16-bit and 32-bit floating-point numbers. Unlike reference types, which we will see later, primitive type variables never share their value with each other, i.e., if we have: 1 2 3 int i = 1000 ; int j = i ; i = i + 1 ; i and j each store a copy of the value 1000 after Line 2. Changing i on Line 3 does not change the content of j .","title":"Primitive Types in Java"},{"location":"02-type.html#subtypes","text":"An important concept that we will visit repeatedly in CS2030/S is the concept of subtypes. Let \\(S\\) and \\(T\\) be two types. We say that \\(T\\) is a subtype of \\(S\\) if a piece of code written for variables of type \\(S\\) can also safely be used on variables of type \\(T\\) . We use the notation \\(T <: S\\) or \\(S :> T\\) to denote that \\(T\\) is subtype of \\(S\\) . The subtype relationship is transitive, i.e., if \\(S <: T\\) and \\(T <: U\\) , then \\(S <: U\\) . It is also reflexive, for any type \\(S\\) , \\(S <: S\\) . We also use the term supertype to denote the reversed relationship: if \\(T\\) is a subtype of \\(S\\) , then \\(S\\) is a supertype of \\(T\\) .","title":"Subtypes"},{"location":"02-type.html#subtyping-between-java-primitive-types","text":"Consider the range of values that the primitive types can take, Java defines the following subtyping relationship: byte <: short <: int <: long <: float <: double char <: int Valid subtype relationship is part of what the Java compiler checks for when it compiles. Consider the following example: 1 2 3 4 double d = 5.0 ; int i = 5 ; d = i ; i = d ; // error Line 4 above would lead to an error: 1 | incompatible types: possible lossy conversion from double to int but Line 3 is OK. This example shows how subtyping applies to type checking. Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . This step is called widening type conversion . Such conversion can happen during assignment or parameter passing.","title":"Subtyping Between Java Primitive Types"},{"location":"02-type.html#additional-readings","text":"Java Tutorial: Primitive Data Types and other Language Basics","title":"Additional Readings"},{"location":"03-function.html","text":"Unit 3: Functions After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function. Function as an Abstraction over Computation Another important abstraction provided by a programming language is the function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function does. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computations as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succinct, and therefore easier to read and understand. Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs. Abstraction Barrier We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different levels of abstraction as well. We will see how it is used for a higher-level of abstraction in the next unit.","title":"3. Functions"},{"location":"03-function.html#unit-3-functions","text":"After reading this unit, students should understand the importance of function as a programming constructor and how it helps to reduce complexity and mitigate bugs. be aware of two different roles a programmer can play: the implementer and the client understand the concept of abstraction barrier as a wall between the client and the implementer, including in the context of a function.","title":"Unit 3: Functions"},{"location":"03-function.html#function-as-an-abstraction-over-computation","text":"Another important abstraction provided by a programming language is the function (or procedure ). This abstraction allows programmers to group a set of instructions and give it a name. The named set of instructions may take one or more variables as input parameters, and return one or more values. Like all other abstractions, defining functions allow us to think at a higher conceptual level. By composing functions at increasingly higher level of abstractions, we can build programs with increasing level of complexity. Functions help us deal with complexity in a few ways: Functions allow programmers to compartmentalize computation and its effects. We can isolate the complexity to within its body: the intermediate variables exists only as local variables that has no effect outside of the function. A function only interacts with the rest of the code through its parameters and return value, and so, reduces the dependencies between variables to these well-defined interactions. Such compartmentalization reduces the complexity of code. Functions allow programmers to hide how a task is performed. The caller of the function only needs to worry about what the function does. By hiding the details of how , we gain two weapons against code complexity. First, we reduce the amount of information that we need to communicate among programmers. A fellow programmer only needs to read the documentation to understand what the parameters are for, what the return values are. There is no need for a fellow programmer to know about the intermediate variables or the internal computation used to implement the functions. Second, as the design and requirement evolve, the implementation of a function may change. But, as long as the parameters and the return value of a function remains the same, the caller of the function does not have to update the code accordingly. Reducing the need to change as the software evolves reduces the chances of introducing bugs accordingly. Functions allows us to reduce repetition in our code through code reuse . If we have the same computation that we need to perform repeatedly on different values , we can construct these computations as functions, replacing the values with parameters, and pass in the values as arguments to the function. This approach reduces the amount of boiler-plate code and has two major benefits in reducing code complexity and bugs. First, it makes the code more succinct, and therefore easier to read and understand. Second, it reduces the number of places in our code that we need to modify as the software evolves, and therefore, decreases the chance of introducing new bugs.","title":"Function as an Abstraction over Computation"},{"location":"03-function.html#abstraction-barrier","text":"We can imagine an abstraction barrier between the code that calls a function and the code that defines the function body. Above the barrier, the concern is about using the function to perform a task, while below the barrier, the concern is about how to perform the task. While many of you are used to writing a program solo, in practice, you rarely write a program with contributions from only a single person. The abstraction barrier separates the role of the programmer into two: (i) an implementer , who provides the implementation of the function, and (ii) a client , which uses the function to perform the task. Part of the aim in CS2030/S is to switch your mindset into thinking in terms of these two roles. The abstraction barrier thus enforces a separation of concerns between the two roles. The concept of abstraction barrier applies not only to a function, but it can be applied to different levels of abstraction as well. We will see how it is used for a higher-level of abstraction in the next unit.","title":"Abstraction Barrier"},{"location":"04-encapsulation.html","text":"Unit 4: Encapsulation After reading this unit, students should understand composite data type as a even-higher level abstraction over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types Abstraction: Composite Data Type Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things. In other words, the representation of the circle and the set of functions that operation on and manipulate circles, fall on the same side of the abstraction barrier. Abstraction: Class and Object (or, Encapsulation) We can further bundle the composite data type and its associated functions on the same side of the abstraction barrier together, into another abstraction called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; } } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle (); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c . r = 10 ; // set the radius to 10 c . getArea (); // return 314.1592653589793 Object-Oriented Programming A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods. Reference Types in Java We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle (); Circle c2 = c1 ; System . out . println ( c2 . r ); // print 0 c1 . r = 10.0 ; System . out . println ( c2 . r ); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well. Special Reference Value: null Any reference variable that is not initialized will have the special reference value null . A common error for beginners is to declare a reference variable and try to use it without instantiating an object: 1 2 Circle c1 ; c1 . r = 10.0 ; // error Line 2 would lead to a run-time error message 1 | Exception java.lang.NullPointerException Remember to always instantiate a reference variable before using it. Further Readings Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use PascalCase for class name and camelCase for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"4. Encapsulation"},{"location":"04-encapsulation.html#unit-4-encapsulation","text":"After reading this unit, students should understand composite data type as a even-higher level abstraction over variables understand encapsulation as an object-oriented (OO) principle understand the meaning of class, object, fields, methods, in the context of OO programming be able to define a class and instantiate one as an object in Java appreciate OO as a natural way to model the real world in programs understand reference types in Java and its difference from the primitive types","title":"Unit 4: Encapsulation"},{"location":"04-encapsulation.html#abstraction-composite-data-type","text":"Just like functions allow programmers to group instructions, give it a name, and refer to it later, a composite data type allows programmers to group primitive types together, give it a name (a new type), and refer to it later. This is another powerful abstraction in programming languages that help us to think at a higher conceptual level without worrying about the details. Commonly used examples are mathematical objects such as complex numbers, 2D data points, multi-dimensional vectors, circles, etc, or everyday objects such as a person, a product, etc. Defining composite data type allows programmers to abstract away (and be separated from the concern of) how a complex data type is represented. For instance, a circle on a 2D plane can be represented by the center ( x , y ) and its radius r , or it can be represented by the top left corner ( x , y ) and the width w of the bounding square. In C, we build a composite data type with struct . For example, 1 2 3 4 typedef struct { double x , y ; // (x,y) coordinate of the center. double r ; // radius } circle ; Once we have the struct defined, we are not completely shielded from its representation, until we write a set of functions that operates on the circle composite type. For instance, 1 2 3 double circle_area ( circle c ) { ... }; bool circle_contains_point ( circle c , double x , double y ) { ... }; : Implementing these functions requires knowledge of how a circle is represented. Once the set of functions that operates on and manipulates circles is available, we can use the circle type without worrying about the internal representation. If we decide to change the representation of a circle, then only the set of functions that operates on a circle type need to be changed, but not the code that uses circles to do other things. In other words, the representation of the circle and the set of functions that operation on and manipulate circles, fall on the same side of the abstraction barrier.","title":"Abstraction: Composite Data Type"},{"location":"04-encapsulation.html#abstraction-class-and-object-or-encapsulation","text":"We can further bundle the composite data type and its associated functions on the same side of the abstraction barrier together, into another abstraction called a class . A class is a data type with a group of functions associated with it. We call the functions as methods and the data in the class as fields (or members , or states , or attributes 1 ). A well-designed class maintains the abstraction barrier, properly wraps the barrier around the internal representation and implementation, and exposes just the right method interface for others to use. The concept of keeping all the data and functions operating on the data related to a composite data type together within an abstraction barrier is called encapsulation . Let's see how we can encapsulate the fields and methods associated together, using Circle as an example, in Java. 1 2 3 4 5 6 7 8 9 10 // Circle v0.1 class Circle { double x ; double y ; double r ; double getArea () { return 3.141592653589793 * r * r ; } } The code above defines a new class using the keyword class , give it a name Circle 2 , followed by a block listing the member variables (with types) and the function definitions. Just like we can create variables of a given type, we can create objects of a given class. Objects are instances of a class, each allowing the same methods to be called, and each containing the same set of variables of the same types, but (possibly) storing different values. In Java, the keyword new creates an object of a given class. For instance, to create a Circle object, we can use 1 Circle c = new Circle (); To access the fields and the methods, we use the . notation. For example, object.field or object.method(..) . For instance, 1 2 c . r = 10 ; // set the radius to 10 c . getArea (); // return 314.1592653589793","title":"Abstraction: Class and Object (or, Encapsulation)"},{"location":"04-encapsulation.html#object-oriented-programming","text":"A program written in an object-oriented language such as Java consists of classes, with one main class as the entry point. One can view a running object-oriented (or OO) program as something that instantiates objects of different classes and orchestrates their interactions with each other by calling each others' methods. One could argue that an object-oriented way of writing programs is much more natural, as it mirrors our world more closely. If we look around us, we see objects all around us, and each object has certain properties, exhibits certain behavior, and they allow certain actions. We interact with the objects through their interfaces, and we rarely need to know the internals of the objects we used every day (unless we try to repair them) 3 . To model a problem in an object-oriented manner, we typically model the nouns as classes and objects, the properties or relationships among the classes as fields, and the verbs or actions of the corresponding objects as methods.","title":"Object-Oriented Programming"},{"location":"04-encapsulation.html#reference-types-in-java","text":"We mentioned in Unit 2 that there are two kinds of types in Java. You have been introduced to the primitive types. Everything else in Java is a reference type. The Circle class is an example of a reference type. Unlike primitive variables, which never share the value, a reference variable stores only the reference to the value, and therefore two reference variables can share the same value. For instance, 1 2 3 4 5 Circle c1 = new Circle (); Circle c2 = c1 ; System . out . println ( c2 . r ); // print 0 c1 . r = 10.0 ; System . out . println ( c2 . r ); // print 10.0 The behavior above is due to the variables c1 and c2 referencing to the same Circle object in the memory. Therefore, changing the field r of c1 causes the field r of c2 to change as well.","title":"Reference Types in Java"},{"location":"04-encapsulation.html#special-reference-value-null","text":"Any reference variable that is not initialized will have the special reference value null . A common error for beginners is to declare a reference variable and try to use it without instantiating an object: 1 2 Circle c1 ; c1 . r = 10.0 ; // error Line 2 would lead to a run-time error message 1 | Exception java.lang.NullPointerException Remember to always instantiate a reference variable before using it.","title":"Special Reference Value: null"},{"location":"04-encapsulation.html#further-readings","text":"Oracle's Java Tutorial on Classes and Objects Computer scientists just could not decide what to call this :( \u21a9 As a convention, we use PascalCase for class name and camelCase for variable and method names in Java. \u21a9 This is a standard analogy in an OOP textbook. In practice, however, we often have to write programs that include abstract concepts with no tangible real-world analogy as classes. \u21a9","title":"Further Readings"},{"location":"05-infohiding.html","text":"Unit 5: Information Hiding After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java Breaking the Abstraction Barrier In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation of the Circle , to say, store the diameter, instead. This small implementation change would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug. Data Hiding Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amounts to using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; } } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later. Constructors With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle ( 0.0 , 0.5 , 10.0 ); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor . The this Keyword The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"5. Information Hiding"},{"location":"05-infohiding.html#unit-5-information-hiding","text":"After taking this unit, students should: understand the drawback of breaking the abstraction barrier understand the concept of information hiding to enforce the abstraction barrier understand how Java uses access modifiers to enforce information hiding understand what is a constructor and how to write one in Java","title":"Unit 5: Information Hiding"},{"location":"05-infohiding.html#breaking-the-abstraction-barrier","text":"In the ideal case, the code above the abstraction barrier would just call the provided interface to use the composite data type. There, however, may be cases where a programmer may intentionally or accidentally break the abstraction barrier. Consider the case of Circle above, where we modify the radius r directly with c.r = 10 . In doing so, we, as the client to Circle , make an explicit assumption of how Circle implements a circle. The implementation details have been leaked outside the abstraction barrier. Now, if the implementer wishes to change the representation of the Circle , to say, store the diameter, instead. This small implementation change would invalidate the code that the client has written! The client will have to carefully change all the code that makes the assumption, and modify accordingly, increasing the chances of introducing a bug.","title":"Breaking the Abstraction Barrier"},{"location":"05-infohiding.html#data-hiding","text":"Many OO languages allow programmers to explicitly specify if a field or a method can be accessed from outside the abstraction barrier. Java, for instance, supports private and public access modifiers. A field or a method that is declared as private cannot be accessed from outside the class, and can only be accessed within the class. On the other hand, as you can guess, a public field or method can be accessed, modified, or invoked from outside the class. Such a mechanism to protect the abstraction barrier from being broken is called data hiding or information hiding . This protection is enforced by the compiler at compile time. In our original Circle class (v0.1) in Unit 4 , we did not specify any access modifier -- this amounts to using the default modifier, the meaning of which is not our concern right now 1 For a start, we will explicitly indicate private or public for all our methods and fields. 1 2 3 4 5 6 7 8 9 10 // Circle v0.2 class Circle { private double x ; private double y ; private double r ; public double getArea () { return 3.141592653589793 * r * r ; } } Now the fields x , y , and r are hidden behind the abstraction barrier of the class Circle . Note that these fields are not accessible and modifiable outside of the class Circle , but they can be accessed and modified within Circle (inside the abstraction barrier), such as in the methods getArea . Breaking Python's Abstraction Barrier Python tries to prevent accidental access to internal representation by having a convention of prefixing the internal variables with _ (one underscore) or __ (two underscores). This method, however, does not prevent a lazy programmer from directly accessing the variables and possibly planting a bug/error that will surface later.","title":"Data Hiding"},{"location":"05-infohiding.html#constructors","text":"With data hiding, we completely isolate the internal representation of a class using an abstraction barrier. But, with no way for the client of the class to modify the fields directly, how can the client initialize the fields in a class? To get around this, it is common for a class to provide methods to initialize these internal fields. A method that initializes an object is called a constructor . A constructor method is a special method within the class. It cannot be called directly but is invoked automatically when an object is instantiated. In Java, a constructor method has the same name as the class and has no return type . A constructor can take in arguments just like other functions. Let's add a constructor to our Circle class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } } Now, to create a Circle object, we need to pass in three arguments: 1 Circle c = new Circle ( 0.0 , 0.5 , 10.0 ); Constructor in Python and JavaScript In Python, the constructor is the __init__ method. In JavaScript, the constructor is simply called constructor .","title":"Constructors"},{"location":"05-infohiding.html#the-this-keyword","text":"The code above also introduces the this keyword. this is a reference variable that refers back to self, and is used to distinguish between two variables of the same name. In the example above, this.x = x means we want to set the field x of this object to the parameter x passed into the constructor. Now that you have been introduced to this , we have also updated the method body of getArea and replaced r with this.r . Although there is nothing syntactically incorrect about using r , sticking to the idiom of referring to members through the this reference makes the code easier to understand to readers. We are making it explicit that we are referring to a field in the class, rather than a local variable or a parameter. The other access modifier is protected . Again, we do not want to worry about this modifier for now. \u21a9","title":"The this Keyword"},{"location":"06-tell-dont-ask.html","text":"Unit 6: Tell, Don't Ask After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\" Accessors and Mutators Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } } The \"Tell Don't Ask\" Principle The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to check if a given point (x,y) calls within the circle, one approach would be: 1 2 3 4 double cX = c . getX (); double cY = c . getY (); double r = c . getR (); boolean isInCircle = (( x - cX ) * ( x - cX ) + ( y - cY ) * ( y - cY )) <= r * r ; where c is a Circle object. A better approach would be to add a new boolean method in the Circle class, and call it instead: 1 boolean isInCircle = c . contains ( x , y ); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to change the representation of the circle and remove the direct accessors to the fields, then only the implementer needs to change the implementation of contains . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer. Further Reading Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"6. Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#unit-6-tell-dont-ask","text":"After taking this unit, students should: understand what accessor and mutator are used for, and why not to use them understand the principle of \"Tell, Don't Ask\"","title":"Unit 6: Tell, Don't Ask"},{"location":"06-tell-dont-ask.html#accessors-and-mutators","text":"Similar to providing constructors, a class should also provide methods to retrieve or modify the properties of the object. These methods are called the accessor (or getter ) or mutator (or setter ). The use of accessor and mutator methods is a bit controversial. Suppose that we provide an accessor method and a mutator method for every private field, then we are exposing the internal representation, therefore breaking the encapsulation. For instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Circle v0.4 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getX () { return this . x ; } public void setX ( double x ) { this . x = x ; } public double getY () { return this . y ; } public void setY ( double y ) { this . y = y ; } public double getR () { return this . r ; } public void setR ( double r ) { this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } }","title":"Accessors and Mutators"},{"location":"06-tell-dont-ask.html#the-tell-dont-ask-principle","text":"The mutators and accessors above are pretty pointless. If we need to know the internal and do something with it, then we are breaking the abstraction barrier. The right approach is to implement a method within the class that does whatever we want the class to do. For instance, suppose that we want to check if a given point (x,y) calls within the circle, one approach would be: 1 2 3 4 double cX = c . getX (); double cY = c . getY (); double r = c . getR (); boolean isInCircle = (( x - cX ) * ( x - cX ) + ( y - cY ) * ( y - cY )) <= r * r ; where c is a Circle object. A better approach would be to add a new boolean method in the Circle class, and call it instead: 1 boolean isInCircle = c . contains ( x , y ); The better approach involves writing a few more lines of code to implement the method, but it keeps the encapsulation intact. If one fine day, the implementer of Circle decided to change the representation of the circle and remove the direct accessors to the fields, then only the implementer needs to change the implementation of contains . The client does not have to change anything. The principle around which we can think about this is the \"Tell, Don't Ask\" principle. The client should tell a Circle object what to do (compute the circumference), instead of asking \"what is your radius?\" to get the value of a field then perform the computation on the object's behalf. While there are situations where we can't avoid using accessor or modifier in a class, for beginner OO programmers like yourself, it is better to not define classes with any accessor and modifier to the private fields, and forces yourselves to think in the OO way -- to tell an object what task to perform as a client, and then implement this task within the class as a method as the implementer.","title":"The \"Tell Don't Ask\" Principle"},{"location":"06-tell-dont-ask.html#further-reading","text":"Tell Don't Ask by Martin Fowler Why getters and setters are evil , by Allen Holub, JavaWorld Getters and setters are evil. Period , by Yegor Bygayenko.","title":"Further Reading"},{"location":"07-static-field.html","text":"Unit 7: Class Fields After this unit, students should: understand the difference between instance fields and class fields understand the meaning of keywords final and static in the context of a field be able to define and use a class field be able to use import to access classes from the Java standard libraries Class Fields Let's revisit the following implementation of Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } } In the code above, we use the constant \\(\\pi\\) but hardcoded it as 3.141592653589793. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other can feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example is the method sqrt() that computes the square root of a given number. sqrt is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a java.lang.Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change and public to indicate that the field is accessible from outside the class. In short, the combination of public static final modifiers is used for constant values in Java. 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these static fields that are associated with a class as class fields , and fields that are associated with an object as instance fields . Note that, a static class field needs not be final and it needs not be public . Class fields are useful for storing pre-computed values or configuration parameters associated with a class rather than individual objects. Accessing Class Fields A class field behaves just like a global variable and can be accessed in the code, anywhere the class can be accessed. Since a class field is associated with a class rather than an object, we access it through its class name . To use the static class field PI , for instance, we have to say java.lang.Math.PI . 1 2 3 public double getArea () { return java . lang . Math . PI * this . r * this . r ; } A more common way, however, is to use import statements at the top of the program. If we have this line: 1 import java.lang.Math ; Then, we can save some typing and write: 1 2 3 public double getArea () { return Math . PI * this . r * this . r ; } Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields. Example: The Circle class Now, let revise our Circle class to improve the code and make it a little more complete. We now add in comments for each method and variable as well, as we always should. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (x, y) with given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point (x, y) is within the circle. */ public boolean contains ( double x , double y ) { return false ; // TODO: Left as an exercise } } The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9","title":"7. Class Fields"},{"location":"07-static-field.html#unit-7-class-fields","text":"After this unit, students should: understand the difference between instance fields and class fields understand the meaning of keywords final and static in the context of a field be able to define and use a class field be able to use import to access classes from the Java standard libraries","title":"Unit 7: Class Fields"},{"location":"07-static-field.html#class-fields","text":"Let's revisit the following implementation of Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Circle v0.3 class Circle { private double x ; private double y ; private double r ; public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } public double getArea () { return 3.141592653589793 * this . r * this . r ; } } In the code above, we use the constant \\(\\pi\\) but hardcoded it as 3.141592653589793. Hardcoding such a magic number is a no-no in terms of coding style. This constant can appear in more than one places. If we hardcode such a number and want to change its precision later, we would need to trace down and change every occurrence. Every time we need to use \\(\\pi\\) , we have to remember or look up what is the precision that we use. Not only does this practice introduce more work, it is also likely to introduce bugs. In C, we define \\(\\pi\\) as a macro constant M_PI . But how should we do this in Java? This is where the ideal that a program consists of only objects with internal states that communicate with each other can feel a bit constraining. The constant \\(\\pi\\) is universal, and does not really belong to any object (the value of \\(\\pi\\) is the same for every circle!). Another example is the method sqrt() that computes the square root of a given number. sqrt is a general function that is not associated with any object as well. A solution to this is to associate these global values and functions with a class instead of with an object . For instance. Java predefines a java.lang.Math class 1 that is populated with constants PI and E (for Euler's number \\(e\\) ), along with a long list of mathematical functions. To associate a method or a field with a class in Java, we declare them with the static keyword. We can additionally add a keyword final to indicate that the value of the field will not change and public to indicate that the field is accessible from outside the class. In short, the combination of public static final modifiers is used for constant values in Java. 1 2 3 4 5 6 class Math { : public static final double PI = 3.141592653589793 ; : : } We call these static fields that are associated with a class as class fields , and fields that are associated with an object as instance fields . Note that, a static class field needs not be final and it needs not be public . Class fields are useful for storing pre-computed values or configuration parameters associated with a class rather than individual objects.","title":"Class Fields"},{"location":"07-static-field.html#accessing-class-fields","text":"A class field behaves just like a global variable and can be accessed in the code, anywhere the class can be accessed. Since a class field is associated with a class rather than an object, we access it through its class name . To use the static class field PI , for instance, we have to say java.lang.Math.PI . 1 2 3 public double getArea () { return java . lang . Math . PI * this . r * this . r ; } A more common way, however, is to use import statements at the top of the program. If we have this line: 1 import java.lang.Math ; Then, we can save some typing and write: 1 2 3 public double getArea () { return Math . PI * this . r * this . r ; } Class Fields and Methods in Python Note that, in Python, any variable declared within a class block is a class field: 1 2 3 class Circle : x = 0 y = 0 In the above example, x and y are class fields, not instance fields.","title":"Accessing Class Fields"},{"location":"07-static-field.html#example-the-circle-class","text":"Now, let revise our Circle class to improve the code and make it a little more complete. We now add in comments for each method and variable as well, as we always should. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius /** * Create a circle centered on (x, y) with given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point (x, y) is within the circle. */ public boolean contains ( double x , double y ) { return false ; // TODO: Left as an exercise } } The class Math is provided by the package java.lang in Java. A package is simply a set of related classes (and interfaces, but I have not told you what is an interface yet). To use this class, we need to add the line import java.lang.Math at the beginning of our program. \u21a9","title":"Example: The Circle class"},{"location":"08-static-method.html","text":"Unit 8: Class Methods After this unit, students should: understand the differences between instance methods and class methods be able to define and use a class method know that the main method is the entry point to a Java program the modifies and parameters required for a main method Let's suppose that, in our program, we wish to assign a unique integer identifier to every Circle object ever created. We can do this with the additions below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius private final int id ; // identifier private static int lastId = 0 ; // the id of the latest circle instance /** * Create a circle centered on (x, y) with a given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; this . id = Circle . lastId ; Circle . lastId += 1 ; } /** * Return how many circles have ever existed. */ public static int getNumOfCircles () { return Circle . lastId ; } } On Line 5, we added a new instance field id to store the identifier of the circle. Note that, since the identifier of a circle should not change once it is created, we use the keyword final here. On Line 6, we added a new class field lastId to remember that the lastId of the latest circle instance. This field is maintained as part of the class Circle and is initialized to 0. On Line 15 and 16, as part of the constructor, we initialize id to lastId and increment lastId . We explicitly access lastId through Circle to make it clear that lastId is a class field. Note that all of the above are done privately beneath the abstraction barrier. Since lastId is incremented by one every time a circle is created, we can also interpret lastId as the number of circles created so far. On Line 22-24, we added a method getNumOfCircles to return its value. The interesting thing here is that we declare getNumOfCircles with a static keyword. Similar to a static field, a static method is associated with a class, not to an instance of the class. Such method is called a class method . A class method is always invoked without being attached to an instance, and so it cannot access its instance fields or call other of its instance methods. The reference this has no meaning within a class method. Furthermore, just like a class field, a class method should be accessed through the class. For example, Circle . getNumOfCircles () . Other examples of class methods include the methods provided in java.lang.Math : sqrt , min , etc. These methods can be invoked through the Math class: e.g., Math.sqrt(x) . The main method The most common class method you will use is probably the main method. Every Java program has a class method called main , which serves as the entry point to the program. To run a Java program, we need to tell the JVM the class whose main method should be invoked first. In the example that we have seen, 1 java Hello will invoke the main method defined within the class Hello to kick start the execution of the program. The main method must be defined in the following way: 1 2 public final static void main ( String [] args ) { } You have learned what public and static means. The return type void indicates that main must not return a value. We have discussed what final means on a field, but are not ready to explain what final means on a method yet. The main method takes in an array ( [] ) of strings as parameters. These are the command-line arguments that we can pass in when invoking java . String (or java.lang.String ) is another class provided by the Java library that encapsulates a sequence of characters.","title":"8. Class Methods"},{"location":"08-static-method.html#unit-8-class-methods","text":"After this unit, students should: understand the differences between instance methods and class methods be able to define and use a class method know that the main method is the entry point to a Java program the modifies and parameters required for a main method Let's suppose that, in our program, we wish to assign a unique integer identifier to every Circle object ever created. We can do this with the additions below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Circle { private double x ; // x-coordinate of the center private double y ; // y-coordinate of the center private double r ; // the length of the radius private final int id ; // identifier private static int lastId = 0 ; // the id of the latest circle instance /** * Create a circle centered on (x, y) with a given radius */ public Circle ( double x , double y , double r ) { this . x = x ; this . y = y ; this . r = r ; this . id = Circle . lastId ; Circle . lastId += 1 ; } /** * Return how many circles have ever existed. */ public static int getNumOfCircles () { return Circle . lastId ; } } On Line 5, we added a new instance field id to store the identifier of the circle. Note that, since the identifier of a circle should not change once it is created, we use the keyword final here. On Line 6, we added a new class field lastId to remember that the lastId of the latest circle instance. This field is maintained as part of the class Circle and is initialized to 0. On Line 15 and 16, as part of the constructor, we initialize id to lastId and increment lastId . We explicitly access lastId through Circle to make it clear that lastId is a class field. Note that all of the above are done privately beneath the abstraction barrier. Since lastId is incremented by one every time a circle is created, we can also interpret lastId as the number of circles created so far. On Line 22-24, we added a method getNumOfCircles to return its value. The interesting thing here is that we declare getNumOfCircles with a static keyword. Similar to a static field, a static method is associated with a class, not to an instance of the class. Such method is called a class method . A class method is always invoked without being attached to an instance, and so it cannot access its instance fields or call other of its instance methods. The reference this has no meaning within a class method. Furthermore, just like a class field, a class method should be accessed through the class. For example, Circle . getNumOfCircles () . Other examples of class methods include the methods provided in java.lang.Math : sqrt , min , etc. These methods can be invoked through the Math class: e.g., Math.sqrt(x) .","title":"Unit 8: Class Methods"},{"location":"08-static-method.html#the-main-method","text":"The most common class method you will use is probably the main method. Every Java program has a class method called main , which serves as the entry point to the program. To run a Java program, we need to tell the JVM the class whose main method should be invoked first. In the example that we have seen, 1 java Hello will invoke the main method defined within the class Hello to kick start the execution of the program. The main method must be defined in the following way: 1 2 public final static void main ( String [] args ) { } You have learned what public and static means. The return type void indicates that main must not return a value. We have discussed what final means on a field, but are not ready to explain what final means on a method yet. The main method takes in an array ( [] ) of strings as parameters. These are the command-line arguments that we can pass in when invoking java . String (or java.lang.String ) is another class provided by the Java library that encapsulates a sequence of characters.","title":"The main method"},{"location":"09-composition.html","text":"Unit 9: Composition After learning this unit, students should understand: how to compose a new class from existing classes using composition how composition models the HAS-A relationship how sharing reference values in composed objects could lead to surprising results Adding more Abstractions Our previous implementation of Circle stores the center using its Cartesian coordinate \\((x,y)\\) . We have a method contains that takes in the Cartesian coordinate of a point. As such, our implementation of Circle assumes that a 2D point is best represented using its Cartesian coordinate. Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details. In this example, what happens if the application finds that it is more convenient to use polar coordinates to represent a 2D point? We will have to change the code of the constructor to Circle and the method contains . If our code contains other shapes or other methods in Circle that similarly assume a point is represented with its Cartesian coordinate, we will have to change them as well. It is easy for bugs to creep in. For instance, we might pass in the polar coordinate \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\) . We can apply the principle of abstraction and encapsulation here, and create a new class Point . The details of which are omitted and left as an exercise. With the Point class, our Circle class looks like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // version 0.5 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { // TODO: Left as an exercise return false ; } } This example also illustrates the concept of composition . Our class Circle has been upgraded from being a bundle of primitive types and its methods, to a bundle that includes a reference type Point as well. In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes. We have mentioned that classes model real-world entities in OOP. The composition models that HAS-A relationship between two entities. For instance, a circle has a point as the center. Example: Cylinder Now let's build up another layer of abstraction and construct a 3D object -- a cylinder. A cylinder has a circle as its base and has a height value. Using composition, we can construct a Cylinder class: 1 2 3 4 5 6 7 8 9 10 class Cylinder { private Circle base ; private double height ; public Cylinder ( Circle base , double height ) { this . base = base ; this . height = height ; } : } Sharing References (aka Aliasing) Recall that unlike primitive types, reference types may share the same reference values. This is called aliasing . Let's look at the subtleties of how this could affect our code and catch us by surprise. Consider the following, where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we want to allow a Circle to move its center. For the sake of this example, let's allow mutators on the class Point . Suppose we want to move c1 and only c1 to be centered at (1,1). 1 p . moveTo ( 1 , 1 ); You will find that by moving p , we are actually moving the center of both c1 and c2 ! This result is due to both circles c1 and c2 sharing the same point. When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center. This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this module, but let's first consider the following \"fix\" (that is still not ideal). Let's suppose that instead of moving p , we add a moveTo method to the Circle instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle { private Point c ; // the center private double r ; // the length of the radius : /** * move the center of this circle to the given point */ void moveTo ( Point c ) { this . c = c ; } : } Now, to move c1 , 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( new Point ( 1 , 1 )); You will find that c1 will now have a new center, but c2 's center remains at (0,0). Why doesn't this solve our problem then? Recall that we can further composed circles into other objects. Let's say that we have two cylinders: 1 2 Cylinder cylinder1 = new Cylinder(c1, 1); Cylinder cylinder2 = new Cylinder(c1, 1); that share the same base, then the same problem repeats itself! One solution is to avoid sharing references as much as possible. For instance, 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); p1 . moveTo ( 1 , 1 ); Without sharing references, moving p1 only affects c1 , so we are safe. The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized. This is an example of the trade offs we mentioned in the introduction to this module : we are sacrificing the computational cost to save programmers from potential suffering! Another approach to address this issue is immutability . We will cover this later in the module.","title":"9. Composition"},{"location":"09-composition.html#unit-9-composition","text":"After learning this unit, students should understand: how to compose a new class from existing classes using composition how composition models the HAS-A relationship how sharing reference values in composed objects could lead to surprising results","title":"Unit 9: Composition"},{"location":"09-composition.html#adding-more-abstractions","text":"Our previous implementation of Circle stores the center using its Cartesian coordinate \\((x,y)\\) . We have a method contains that takes in the Cartesian coordinate of a point. As such, our implementation of Circle assumes that a 2D point is best represented using its Cartesian coordinate. Recall that we wish to hide the implementation details as much as possible, protecting them with an abstraction barrier, so that the client does not have to bother about the details and it is easy for the implementer to change the details. In this example, what happens if the application finds that it is more convenient to use polar coordinates to represent a 2D point? We will have to change the code of the constructor to Circle and the method contains . If our code contains other shapes or other methods in Circle that similarly assume a point is represented with its Cartesian coordinate, we will have to change them as well. It is easy for bugs to creep in. For instance, we might pass in the polar coordinate \\((r, \\theta)\\) to a method, but the method treats the two parameters as the Cartesian \\((x,y)\\) . We can apply the principle of abstraction and encapsulation here, and create a new class Point . The details of which are omitted and left as an exercise. With the Point class, our Circle class looks like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // version 0.5 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { // TODO: Left as an exercise return false ; } } This example also illustrates the concept of composition . Our class Circle has been upgraded from being a bundle of primitive types and its methods, to a bundle that includes a reference type Point as well. In OOP, composition is a basic technique to build up layers of abstractions and construct sophisticated classes. We have mentioned that classes model real-world entities in OOP. The composition models that HAS-A relationship between two entities. For instance, a circle has a point as the center.","title":"Adding more Abstractions"},{"location":"09-composition.html#example-cylinder","text":"Now let's build up another layer of abstraction and construct a 3D object -- a cylinder. A cylinder has a circle as its base and has a height value. Using composition, we can construct a Cylinder class: 1 2 3 4 5 6 7 8 9 10 class Cylinder { private Circle base ; private double height ; public Cylinder ( Circle base , double height ) { this . base = base ; this . height = height ; } : }","title":"Example: Cylinder"},{"location":"09-composition.html#sharing-references-aka-aliasing","text":"Recall that unlike primitive types, reference types may share the same reference values. This is called aliasing . Let's look at the subtleties of how this could affect our code and catch us by surprise. Consider the following, where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we want to allow a Circle to move its center. For the sake of this example, let's allow mutators on the class Point . Suppose we want to move c1 and only c1 to be centered at (1,1). 1 p . moveTo ( 1 , 1 ); You will find that by moving p , we are actually moving the center of both c1 and c2 ! This result is due to both circles c1 and c2 sharing the same point. When we pass the center into the constructor, we are passing the reference instead of passing a cloned copy of the center. This is a common source of bugs and we will see how we can reduce the possibilities of such bugs later in this module, but let's first consider the following \"fix\" (that is still not ideal). Let's suppose that instead of moving p , we add a moveTo method to the Circle instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 class Circle { private Point c ; // the center private double r ; // the length of the radius : /** * move the center of this circle to the given point */ void moveTo ( Point c ) { this . c = c ; } : } Now, to move c1 , 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( new Point ( 1 , 1 )); You will find that c1 will now have a new center, but c2 's center remains at (0,0). Why doesn't this solve our problem then? Recall that we can further composed circles into other objects. Let's say that we have two cylinders: 1 2 Cylinder cylinder1 = new Cylinder(c1, 1); Cylinder cylinder2 = new Cylinder(c1, 1); that share the same base, then the same problem repeats itself! One solution is to avoid sharing references as much as possible. For instance, 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); p1 . moveTo ( 1 , 1 ); Without sharing references, moving p1 only affects c1 , so we are safe. The drawback of not sharing objects with the same content is that we will have a proliferation of objects and the computational resource usage is not optimized. This is an example of the trade offs we mentioned in the introduction to this module : we are sacrificing the computational cost to save programmers from potential suffering! Another approach to address this issue is immutability . We will cover this later in the module.","title":"Sharing References (aka Aliasing)"},{"location":"10-inheritance.html","text":"Unit 10: Inheritance After taking this unit, students should: understand inheritance as a mechanism to extend existing code understand how inheritance models the IS-A relationship know how to use the extends keyword for inheritance understand inheritance as a subtype be able to determine the run-time type and compile-time type of a variable Extension with Composition We have seen how composition allows us to compose a new, more complex, class, out of existing classes, without breaking the abstraction barrier of existing classes. Sometimes, however, composition is not the right approach. Let's consider the following example. Let's suppose that we, as a client, want to add color as a property to our Circle . Without penetrating the abstraction barrier of Circle , we can do the following: 1 2 3 4 5 6 7 8 9 10 // version 0.1 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } } where Color is another abstraction representing the color of shapes. What should we do if we want to calculate the area of our colored circle? Suppose we already have a ColoredCircle instance called coloredCircle . We could make circle public and call coloredCircle . circle . getArea () , or we could add an accessor and call coloredCircle . getCircle (). getArea () . Both of these are not ideal, since it breaks the abstraction barrier and reveals that the ColoredCircle class stores a circle (the latter being slightly better than the first). A better alternative is to let ColoredCircle provide its own getArea() method, and forward its call to Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.2 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } public double getArea () { return circle . getArea (); } } Then, the client to ColoredCircle can just call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally. The drawback of this approach is that we might end up with many such boilerplate forwarding methods. Extension with Inheritance Recall the concept of subtyping. We say that \\(S <: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\) . Now, think about ColoredCircle and Circle . If someone has written a piece of code that operates on Circle objects. Do we expect the same code to work on ColoredCircle ? In this example, yes! A ColoredCircle object should behave just like a circle -- we can calculate its area, circumference, check if two circles intersect, check if a point falls within the circle, etc. The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field. So, ColoredCircle is a subtype of Circle . We now show you how we can introduce this subtype relationship in Java, using the extends keyword. We can reimplement our ColoredCircle class this way: 1 2 3 4 5 6 7 8 9 // version 0.3 (using inheritance) class ColoredCircle extends Circle { private Color color ; public ColoredCircle ( Point center , double radius , Color color ) { super ( center , radius ); // call the parent's constructor this . color = color ; } } We just created a new type ColoredCircle as a class that extends from Circle . We call Circle the parent class or superclass of ColoredCircle ; and ColoredCircle a subclass of Circle . We also say that ColoredCircle inherits from Circle , since all the public fields of Circle (center and radius) and public methods (like getArea() ) are now accessible to ColoredCircle . Just like a parent-child relationship in real-life, however, anything private to the parent remains inaccessible to the child. This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation -- technically a child ColoredCircle object has a center and a radius, but it has no access to it! Line 6 of the code above introduces another keyword in Java: super . Here, we use super to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited). The concept we have shown you is called inheritance and is one of the four pillars of OOP. We can think of inheritance as a model for the \" is a \" relationship between two entities. With inheritance, we can call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally and without forwarding methods. When NOT to Use Inheritance Inheritance tends to get overused. In practice, we seldom use inheritance . Let's look at some examples of how not to use inheritance, and why. You may come across examples online or in books that look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point { private double x ; private double y ; : } class Circle extends Point { private double radius ; : } class Cylinder extends Circle { private double height ; : } The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition. Circle implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); Cylinder would have the fields corresponding to a circle, which is its base and height. In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class. When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: 1 2 3 4 5 void foo ( Circle c , Point p ) { if ( c . contains ( p )) { // do something } } Since Cylinder is a subtype of Point according to the implementation above, the code above should still work also if we replace Point with a Cylinder (according to the semantic of subtyping). But it gets weird -- what is the meaning of a Circle (in 2D) containing a Cylinder (in 3D)? We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of foo expects. The message here is this: Use composition to model a has-a relationship; inheritance for a is-a relationship . Make sure inheritance preserves the meaning of subtyping . Run-Time Type Recall that Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . Since ColoredCircle <: Circle , the following is not allowed in Java: 1 ColoredCircle c = new Circle(p, 0); // error but this is OK: 1 Circle c = new ColoredCircle(p, 0, blue); // OK where p is a Point object and blue is a Color object. Also, recall that Circle is called the compile-time type of c . Here, we see that c is now referencing an object of subtype ColoredCircle . Since this assignment happens during run-time, we say that the run-time type of c is ColoredCircle . The distinction between these two types will be important later.","title":"10. Inheritance"},{"location":"10-inheritance.html#unit-10-inheritance","text":"After taking this unit, students should: understand inheritance as a mechanism to extend existing code understand how inheritance models the IS-A relationship know how to use the extends keyword for inheritance understand inheritance as a subtype be able to determine the run-time type and compile-time type of a variable","title":"Unit 10: Inheritance"},{"location":"10-inheritance.html#extension-with-composition","text":"We have seen how composition allows us to compose a new, more complex, class, out of existing classes, without breaking the abstraction barrier of existing classes. Sometimes, however, composition is not the right approach. Let's consider the following example. Let's suppose that we, as a client, want to add color as a property to our Circle . Without penetrating the abstraction barrier of Circle , we can do the following: 1 2 3 4 5 6 7 8 9 10 // version 0.1 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } } where Color is another abstraction representing the color of shapes. What should we do if we want to calculate the area of our colored circle? Suppose we already have a ColoredCircle instance called coloredCircle . We could make circle public and call coloredCircle . circle . getArea () , or we could add an accessor and call coloredCircle . getCircle (). getArea () . Both of these are not ideal, since it breaks the abstraction barrier and reveals that the ColoredCircle class stores a circle (the latter being slightly better than the first). A better alternative is to let ColoredCircle provide its own getArea() method, and forward its call to Circle . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.2 (using composition) class ColoredCircle { private Circle circle ; private Color color ; public ColoredCircle ( Circle circle , Color color ) { this . circle = circle ; this . color = color ; } public double getArea () { return circle . getArea (); } } Then, the client to ColoredCircle can just call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally. The drawback of this approach is that we might end up with many such boilerplate forwarding methods.","title":"Extension with Composition"},{"location":"10-inheritance.html#extension-with-inheritance","text":"Recall the concept of subtyping. We say that \\(S <: T\\) if any piece of code written for type \\(T\\) also works for type \\(S\\) . Now, think about ColoredCircle and Circle . If someone has written a piece of code that operates on Circle objects. Do we expect the same code to work on ColoredCircle ? In this example, yes! A ColoredCircle object should behave just like a circle -- we can calculate its area, circumference, check if two circles intersect, check if a point falls within the circle, etc. The only difference, or more precisely, extension, is that it has a color, and perhaps has some methods related to this additional field. So, ColoredCircle is a subtype of Circle . We now show you how we can introduce this subtype relationship in Java, using the extends keyword. We can reimplement our ColoredCircle class this way: 1 2 3 4 5 6 7 8 9 // version 0.3 (using inheritance) class ColoredCircle extends Circle { private Color color ; public ColoredCircle ( Point center , double radius , Color color ) { super ( center , radius ); // call the parent's constructor this . color = color ; } } We just created a new type ColoredCircle as a class that extends from Circle . We call Circle the parent class or superclass of ColoredCircle ; and ColoredCircle a subclass of Circle . We also say that ColoredCircle inherits from Circle , since all the public fields of Circle (center and radius) and public methods (like getArea() ) are now accessible to ColoredCircle . Just like a parent-child relationship in real-life, however, anything private to the parent remains inaccessible to the child. This privacy veil maintains the abstraction barrier of the parent from the child, and creates a bit of a tricky situation -- technically a child ColoredCircle object has a center and a radius, but it has no access to it! Line 6 of the code above introduces another keyword in Java: super . Here, we use super to call the constructor of the superclass, to initialize its center and radius (since the child has no direct access to these fields that it inherited). The concept we have shown you is called inheritance and is one of the four pillars of OOP. We can think of inheritance as a model for the \" is a \" relationship between two entities. With inheritance, we can call coloredCircle . getArea () without knowing or needing to know how a colored circle is represented internally and without forwarding methods.","title":"Extension with Inheritance"},{"location":"10-inheritance.html#when-not-to-use-inheritance","text":"Inheritance tends to get overused. In practice, we seldom use inheritance . Let's look at some examples of how not to use inheritance, and why. You may come across examples online or in books that look like the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Point { private double x ; private double y ; : } class Circle extends Point { private double radius ; : } class Cylinder extends Circle { private double height ; : } The difference between these implementations and the one you have seen in Unit 9 is that it uses inheritance rather than composition. Circle implemented like the above would have the center coordinate inherited from the parent (so it has three fields, x, y, and radius); Cylinder would have the fields corresponding to a circle, which is its base and height. In terms of modeling the properties of circle and cylinder, we have all the right properties in the right class. When we start to consider methods encapsulated with each object, things start to break down. Consider a piece of code written as follows: 1 2 3 4 5 void foo ( Circle c , Point p ) { if ( c . contains ( p )) { // do something } } Since Cylinder is a subtype of Point according to the implementation above, the code above should still work also if we replace Point with a Cylinder (according to the semantic of subtyping). But it gets weird -- what is the meaning of a Circle (in 2D) containing a Cylinder (in 3D)? We could come up with a convoluted meaning that explains this, but it is likely not what the original implementer of foo expects. The message here is this: Use composition to model a has-a relationship; inheritance for a is-a relationship . Make sure inheritance preserves the meaning of subtyping .","title":"When NOT to Use Inheritance"},{"location":"10-inheritance.html#run-time-type","text":"Recall that Java allows a variable of type \\(T\\) to hold a value from a variable of type \\(S\\) only if \\(S <: T\\) . Since ColoredCircle <: Circle , the following is not allowed in Java: 1 ColoredCircle c = new Circle(p, 0); // error but this is OK: 1 Circle c = new ColoredCircle(p, 0, blue); // OK where p is a Point object and blue is a Color object. Also, recall that Circle is called the compile-time type of c . Here, we see that c is now referencing an object of subtype ColoredCircle . Since this assignment happens during run-time, we say that the run-time type of c is ColoredCircle . The distinction between these two types will be important later.","title":"Run-Time Type"},{"location":"11-overriding.html","text":"Unit 11: Overriding After reading this unit, students should be aware that every class inherits from Object be familiar with the equals and toString methods understand what constitutes a method signature understand method overriding appreciate the power of method overriding understand what Java annotations are for, and know when to use @Override be exposed to the String class and its associated methods, especially the + operator Object and String In Java, every class that does not extend another class inherits from the class Object implicitly. Object is, therefore, the \"ancestor\" of all classes in Java and is at the root of the class hierarchy. The Object class does not encapsulate anything in particular. It is a very general class that provides useful methods common to all objects. The two useful ones that we are going to spend time with are: equals(Object obj) , which checks if two objects are equal to each other, and toString() , which returns a string representation of the object as a String object. The toString Method The toString method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a String object during string concatenation using the operator + . We showed you that in Python, 4 + \"Hello\" would result in a type mismatch error. In Java, however, 4 + \"Hello\" will result in the string \"4Hello\" . In this example, the primitive value 4 is converted to a string before concatenation. A more interesting scenario is what happens if we try to concatenate, say, a Circle object with a string. Let's say we have: 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c ; You will see that s now contains the string \"Circle c is Circle@1ce92674 \" (the seemingly gibberish text after @` is the reference to the object and so your result will be different). What happened here is that the + operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its toString() method automatically for us. This is equivalent to 1 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c . toString (); Recall that in our Circle class (up to version 0.5) we do not have any toString method. The toString method that we invoked here is the toString method inherited from its parent Object . jshell and toString Recall that jshell is a REPL tool. After evaluating an expression, jshell prints the resulting value out. If the resulting value is a reference type, jshell will invoke toString to convert the reference type to a string first, before printing the string. Customizing toString for Circle The Object::toString method (that is our notation for the method toString from the class Object ) is not very user friendly. Ideally, when we print a Circle object, say, for debugging, we want to see its center and its radius. To do so, we can define our own toString method in Circle . Let's upgrade our Circle class to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // version 0.6 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } } The body of the method toString simply constructs a string representation for this circle object and returns it. With this toString implemented, the output will look something like this: 1 Circle c is { center: (0.0, 0.0), radius: 4.0 } Note that when the center this.c is converted to a string, the toString method of Point is invoked. We leave the implementation of Point::toString as an exercise. Method Overriding What we just did is called method overriding in OOP. Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well. Let's define the method signature of a method as the method name and the number, type, and order of its parameters, and the method descriptor as the method signature plus the return type. When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class 2 . In the example above, Circle::toString has overridden Object::toString . The @Override Annotation Line 37 in the example above contains the symbol @Override . This symbol is an example of annotation in Java. An annotation is not part of the program and does not affect the bytecode generated. Instead, it is a hint to the compiler. Remember that the compiler is our friend who will do its best to help detect errors early, during compilation. We must do our part to help the compiler help us. Here, @Override is a hint to the compiler that the following method, toString , is intended to override the method in the parent class. In case, there is a typo and overriding is not possible, the compiler will let us know. It is therefore recommended and expected that all overriding methods in your code are annotated with @Override . Using super To Access Overridden Methods After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the super keyword. For instance, the following Circle::toString calls Object::toString to prefix the string representation of the circle with Circle@1ce92674 . 1 2 3 4 @Override public String toString () { return super . toString () + \" { center: \" + this . c + \", radius: \" + this . r + \" }\" ; } Calling toString explicitly is not wrong, but we usually omit the call to keep the code readable and succinct. \u21a9 It is possible to override a method in some cases when the return type is different. We will discuss this during recitations. \u21a9","title":"11. Overriding"},{"location":"11-overriding.html#unit-11-overriding","text":"After reading this unit, students should be aware that every class inherits from Object be familiar with the equals and toString methods understand what constitutes a method signature understand method overriding appreciate the power of method overriding understand what Java annotations are for, and know when to use @Override be exposed to the String class and its associated methods, especially the + operator","title":"Unit 11: Overriding"},{"location":"11-overriding.html#object-and-string","text":"In Java, every class that does not extend another class inherits from the class Object implicitly. Object is, therefore, the \"ancestor\" of all classes in Java and is at the root of the class hierarchy. The Object class does not encapsulate anything in particular. It is a very general class that provides useful methods common to all objects. The two useful ones that we are going to spend time with are: equals(Object obj) , which checks if two objects are equal to each other, and toString() , which returns a string representation of the object as a String object.","title":"Object and String"},{"location":"11-overriding.html#the-tostring-method","text":"The toString method is very special, as this is invoked implicitly by Java, by default, to convert a reference object to a String object during string concatenation using the operator + . We showed you that in Python, 4 + \"Hello\" would result in a type mismatch error. In Java, however, 4 + \"Hello\" will result in the string \"4Hello\" . In this example, the primitive value 4 is converted to a string before concatenation. A more interesting scenario is what happens if we try to concatenate, say, a Circle object with a string. Let's say we have: 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c ; You will see that s now contains the string \"Circle c is Circle@1ce92674 \" (the seemingly gibberish text after @` is the reference to the object and so your result will be different). What happened here is that the + operator sees that one of the operands is a string but the other is not, so it converts the one that is not a string to a string by calling its toString() method automatically for us. This is equivalent to 1 1 2 Circle c = new Circle ( new Point ( 0 , 0 ), 4.0 ); String s = \"Circle c is \" + c . toString (); Recall that in our Circle class (up to version 0.5) we do not have any toString method. The toString method that we invoked here is the toString method inherited from its parent Object . jshell and toString Recall that jshell is a REPL tool. After evaluating an expression, jshell prints the resulting value out. If the resulting value is a reference type, jshell will invoke toString to convert the reference type to a string first, before printing the string.","title":"The toString Method"},{"location":"11-overriding.html#customizing-tostring-for-circle","text":"The Object::toString method (that is our notation for the method toString from the class Object ) is not very user friendly. Ideally, when we print a Circle object, say, for debugging, we want to see its center and its radius. To do so, we can define our own toString method in Circle . Let's upgrade our Circle class to do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // version 0.6 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } } The body of the method toString simply constructs a string representation for this circle object and returns it. With this toString implemented, the output will look something like this: 1 Circle c is { center: (0.0, 0.0), radius: 4.0 } Note that when the center this.c is converted to a string, the toString method of Point is invoked. We leave the implementation of Point::toString as an exercise.","title":"Customizing toString for Circle"},{"location":"11-overriding.html#method-overriding","text":"What we just did is called method overriding in OOP. Inheritance is not only good for extending the behavior of an existing class but through method overriding, we can alter the behavior of an existing class as well. Let's define the method signature of a method as the method name and the number, type, and order of its parameters, and the method descriptor as the method signature plus the return type. When a subclass defines an instance method with the same method descriptor as an instance method in the parent class, we say that the instance method in the subclass overrides the instance method in the parent class 2 . In the example above, Circle::toString has overridden Object::toString .","title":"Method Overriding"},{"location":"11-overriding.html#the-override-annotation","text":"Line 37 in the example above contains the symbol @Override . This symbol is an example of annotation in Java. An annotation is not part of the program and does not affect the bytecode generated. Instead, it is a hint to the compiler. Remember that the compiler is our friend who will do its best to help detect errors early, during compilation. We must do our part to help the compiler help us. Here, @Override is a hint to the compiler that the following method, toString , is intended to override the method in the parent class. In case, there is a typo and overriding is not possible, the compiler will let us know. It is therefore recommended and expected that all overriding methods in your code are annotated with @Override . Using super To Access Overridden Methods After a subclass overrides a method in the superclass, the methods that have been overridden can still be called, with the super keyword. For instance, the following Circle::toString calls Object::toString to prefix the string representation of the circle with Circle@1ce92674 . 1 2 3 4 @Override public String toString () { return super . toString () + \" { center: \" + this . c + \", radius: \" + this . r + \" }\" ; } Calling toString explicitly is not wrong, but we usually omit the call to keep the code readable and succinct. \u21a9 It is possible to override a method in some cases when the return type is different. We will discuss this during recitations. \u21a9","title":"The @Override Annotation"},{"location":"12-polymorphism.html","text":"Unit 12: Polymorphism After reading this unit, students should understand dynamic binding and polymorphism be aware of the equals method and the need to override it to customize the equality test understand when narrowing type conversion and type casting are allowed Taking on Many Forms Method overriding enables polymorphism , the fourth and the last pillar of OOP, and arguably the most powerful one. It allows us to change how existing code behaves, without changing a single line of the existing code (or even having access to the code). Consider the function say below: 1 2 3 void say ( Object obj ) { System . out . println ( \"Hi, I am \" + obj . toString ()); } Note that this method receives an Object instance. Since both Point <: Object and Circle <: Object , we can do the following: 1 2 3 4 Point p = new Point(0, 0); say(p); Circle c = new Circle(p, 4); say(c); When executed, say will first print Hi, I am (0.0, 0.0) , followed by Hi, I am { center: (0.0, 0.0), radius: 4.0 } . We are invoking the overriding Point::toString in the first call, and Circle::toString in the second call . The same method invocation obj.toString() causes two different methods to be called in two separate invocations! In biology, polymorphism means that an organism can have many different forms. Here, the variable obj can have many forms as well. Which method is invoked is decided during run-time , depending on the run-time type of the obj . This is called dynamic binding or late binding or dynamic dispatch . Before we get into this in more detail, let consider overriding Object::equals . The equals method Object::equals compares if two object references refer to the same object. Suppose we have: 1 2 3 Circle c0 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c1 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c2 = c1 ; c2.equals(c1) returns true , but c0.equals(c1) returns false . Even though c0 and c1 are semantically the same, they refer to the two different objects. To compare if two circles are semantically the same, we need to override this method 1 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.7 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } return false ; } } This is more complicated than toString . There are a few new concepts involved here: equals takes in a parameter of compile-time type Object . It only makes sense if we compare (during run-time) a circle with another circle. So, we first check if the run-time type of obj is a subtype of Circle . This is done using the instanceof operator. The operator returns true if obj has a run-time type that is a subtype of Circle . To compare this circle with the given circle, we have to access the center c and radius r . But if we access obj.c or obj.r , the compiler will complain. As far as the compiler is concerned, obj has the compile-time type Object , and there is no such fields c and r in the class Object ! This is why, after assuring that the run-time type of obj is a subtype of Circle , we assign obj to another variable circle that has the compile-time type Circle . We finally check if the two centers are equal (again, Point::equals is left as an exercise) and the two radii are equal 2 . The statement that assigns obj to circle involves type casting . We mentioned before that Java is strongly typed and so it is very strict about type conversion. Here, Java allows type casting from type \\(T\\) to \\(S\\) if \\(S <: T\\) . This is called narrowing type conversion . Unlike widening type conversion, which is always allowed and always correct, a narrowing type conversion requires explicit typecasting and validation during run-time. If we do not ensure that obj has the correct run-time type, casting can lead to a run-time error (which if you recall , is bad). All these complications would go away, however, if we define Circle::equals to take in a Circle as a parameter, like this: 1 2 3 4 5 6 7 8 9 10 class Circle { : /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals(Circle circle) { return (circle.c.equals(this.c) && circle.r == this.r); } } This version of equals however, does not override Object::equals . Since we hinted to the compiler that we meant this to be an overriding method, using @Override , the compiler will give us an error. This is not treated as method overriding, since the signature for Circle::equals is different from Object::equals . Why then is overriding important? Why not just leave out the line @Override and live with the non-overriding, one-line, equals method above? The Power of Polymorphism Let's consider the following example. Suppose we have a general contains method that takes in an array of objects. The array can store any type of objects: Circle , Square , Rectangle , Point , String , etc. The method contains also takes in a target obj to search for, and returns true if there is an object in array that equals to obj . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } With overriding and polymorphism, the magic happens in Line 4 -- depending on the run-time type of curr , the corresponding, customized version of equals is called to compare against obj . However, if Circle::equals takes in a Circle as the parameter, the call to equals inside the method contains would not invoke Circle::equals . It would invoke Object::equals instead due to the matching method signature, and we can't search for Circle based on semantic equality. To have a generic contains method without polymorphism and overriding, we will have to do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.2 (without polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( obj instanceof Circle ) { if ( curr . equals (( Circle ) obj )) { return true ; } } else if ( obj instanceof Square ) { if ( curr . equals (( Square ) obj )) { return true ; } } else if ( obj instanceof Point ) { if ( curr . equals (( Point ) obj )) { return true ; } } : } return false ; } which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the if-else statement! As this example has shown, polymorphism allows us to write succinct code that is future proof . By dynamically deciding which method implementation to execute during run-time, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile! If we override equals() , we should generally override hashCode() as well, but let's leave that for another lesson on another day. \u21a9 The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough. We are sloppy here to keep the already complicated code a bit simpler. You shouldn't do this in your code. \u21a9","title":"12. Polymorphism"},{"location":"12-polymorphism.html#unit-12-polymorphism","text":"After reading this unit, students should understand dynamic binding and polymorphism be aware of the equals method and the need to override it to customize the equality test understand when narrowing type conversion and type casting are allowed","title":"Unit 12: Polymorphism"},{"location":"12-polymorphism.html#taking-on-many-forms","text":"Method overriding enables polymorphism , the fourth and the last pillar of OOP, and arguably the most powerful one. It allows us to change how existing code behaves, without changing a single line of the existing code (or even having access to the code). Consider the function say below: 1 2 3 void say ( Object obj ) { System . out . println ( \"Hi, I am \" + obj . toString ()); } Note that this method receives an Object instance. Since both Point <: Object and Circle <: Object , we can do the following: 1 2 3 4 Point p = new Point(0, 0); say(p); Circle c = new Circle(p, 4); say(c); When executed, say will first print Hi, I am (0.0, 0.0) , followed by Hi, I am { center: (0.0, 0.0), radius: 4.0 } . We are invoking the overriding Point::toString in the first call, and Circle::toString in the second call . The same method invocation obj.toString() causes two different methods to be called in two separate invocations! In biology, polymorphism means that an organism can have many different forms. Here, the variable obj can have many forms as well. Which method is invoked is decided during run-time , depending on the run-time type of the obj . This is called dynamic binding or late binding or dynamic dispatch . Before we get into this in more detail, let consider overriding Object::equals .","title":"Taking on Many Forms"},{"location":"12-polymorphism.html#the-equals-method","text":"Object::equals compares if two object references refer to the same object. Suppose we have: 1 2 3 Circle c0 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c1 = new Circle ( new Point ( 0 , 0 ), 10 ); Circle c2 = c1 ; c2.equals(c1) returns true , but c0.equals(c1) returns false . Even though c0 and c1 are semantically the same, they refer to the two different objects. To compare if two circles are semantically the same, we need to override this method 1 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.7 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { return false ; // TODO: Left as an exercise } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } return false ; } } This is more complicated than toString . There are a few new concepts involved here: equals takes in a parameter of compile-time type Object . It only makes sense if we compare (during run-time) a circle with another circle. So, we first check if the run-time type of obj is a subtype of Circle . This is done using the instanceof operator. The operator returns true if obj has a run-time type that is a subtype of Circle . To compare this circle with the given circle, we have to access the center c and radius r . But if we access obj.c or obj.r , the compiler will complain. As far as the compiler is concerned, obj has the compile-time type Object , and there is no such fields c and r in the class Object ! This is why, after assuring that the run-time type of obj is a subtype of Circle , we assign obj to another variable circle that has the compile-time type Circle . We finally check if the two centers are equal (again, Point::equals is left as an exercise) and the two radii are equal 2 . The statement that assigns obj to circle involves type casting . We mentioned before that Java is strongly typed and so it is very strict about type conversion. Here, Java allows type casting from type \\(T\\) to \\(S\\) if \\(S <: T\\) . This is called narrowing type conversion . Unlike widening type conversion, which is always allowed and always correct, a narrowing type conversion requires explicit typecasting and validation during run-time. If we do not ensure that obj has the correct run-time type, casting can lead to a run-time error (which if you recall , is bad). All these complications would go away, however, if we define Circle::equals to take in a Circle as a parameter, like this: 1 2 3 4 5 6 7 8 9 10 class Circle { : /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals(Circle circle) { return (circle.c.equals(this.c) && circle.r == this.r); } } This version of equals however, does not override Object::equals . Since we hinted to the compiler that we meant this to be an overriding method, using @Override , the compiler will give us an error. This is not treated as method overriding, since the signature for Circle::equals is different from Object::equals . Why then is overriding important? Why not just leave out the line @Override and live with the non-overriding, one-line, equals method above?","title":"The equals method"},{"location":"12-polymorphism.html#the-power-of-polymorphism","text":"Let's consider the following example. Suppose we have a general contains method that takes in an array of objects. The array can store any type of objects: Circle , Square , Rectangle , Point , String , etc. The method contains also takes in a target obj to search for, and returns true if there is an object in array that equals to obj . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } With overriding and polymorphism, the magic happens in Line 4 -- depending on the run-time type of curr , the corresponding, customized version of equals is called to compare against obj . However, if Circle::equals takes in a Circle as the parameter, the call to equals inside the method contains would not invoke Circle::equals . It would invoke Object::equals instead due to the matching method signature, and we can't search for Circle based on semantic equality. To have a generic contains method without polymorphism and overriding, we will have to do something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.2 (without polymorphism) boolean contains ( Object array [] , Object obj ) { for ( Object curr : array ) { if ( obj instanceof Circle ) { if ( curr . equals (( Circle ) obj )) { return true ; } } else if ( obj instanceof Square ) { if ( curr . equals (( Square ) obj )) { return true ; } } else if ( obj instanceof Point ) { if ( curr . equals (( Point ) obj )) { return true ; } } : } return false ; } which is not scalable since every time we add a new class, we have to come back to this method and add a new branch to the if-else statement! As this example has shown, polymorphism allows us to write succinct code that is future proof . By dynamically deciding which method implementation to execute during run-time, the implementer can write short yet very general code that works for existing classes as well as new classes that might be added in the future by the client, without even the need to re-compile! If we override equals() , we should generally override hashCode() as well, but let's leave that for another lesson on another day. \u21a9 The right way to compare two floating-point numbers is to take their absolute difference and check if the difference is small enough. We are sloppy here to keep the already complicated code a bit simpler. You shouldn't do this in your code. \u21a9","title":"The Power of Polymorphism"},{"location":"13-lsp.html","text":"Unit 13: Liskov Substitution Principle After this unit, the student should: understand the type of bugs that reckless developers can introduce when using inheritance and polymorphism understand the Liskov Substitution Principle and thus be aware that not all IS-A relationships should be modeled with inheritance know how to explicitly disallow inheritance when writing a class or disallow overriding with the final keyword The Responsibility When Using Inheritance As you have seen in Unit 12 , polymorphism is a powerful tool that allows a client to change the behavior of existing code written by the implementer, behind the abstraction barrier. As Ben Parker (aka Uncle Ben) said, \"With great power, comes great responsibility.\" The client must use overriding and inheritance carefully. Since they can affect how existing code behaves, they can easily break existing code and introduce bugs. Since the client may not have access to the existing code behind the abstraction barrier, it is often tricky to trace and debug. Furthermore, the implementer would not appreciate it if their code was working perfectly until one day, someone overriding a method causes their code to fail, even without the implementer changing anything in their code. Ensuring this responsibility cannot be done by the compiler, unfortunately. It thus becomes a developer's responsibility to ensure that any inheritance with method overriding does not introduce bugs to existing code. This brings us to the Liskov Substitution Principle (LSP), which says: \"Let \\(\\phi(x)\\) be a property provable about objects \\(x\\) of type \\(T\\) . Then \\(\\phi(y)\\) should be true for objects \\(y\\) of type \\(S\\) where \\(S <: T\\) .\" This is consistent with the definition of subtyping, \\(S <: T\\) , but spelled out more formally. Let's consider the following example method, Module::marksToGrade , which takes in the marks of a student and returns the grade 'A', 'B', 'C', or 'F' as a char . How Module::marksToGrade is implemented is not important. Let's look at how it is used. 1 2 3 4 5 6 7 8 9 10 11 12 void displayGrade ( Module m , double marks ) { char grade = m . marksToGrade ( marks ); if ( grade == 'A' )) { System . out . println ( \"well done\" ); else if ( grade == 'B' ) { System . out . println ( \"good\" ); else if ( grade == 'C' ) { System . out . println ( \"ok\" ); } else { System . out . println ( \"retake again\" ); } } Now, suppose that one day, someone comes along and create a new class CSCUModule that inherits from Module , and overrides marksToGrade s that it now returns only 'S' and 'U'. Since CSCUModule is a subclass of Module , we can pass an instance to displayGrade : 1 displayGrade(new CSCUModule(\"GEQ1000\", 100)); and suddenly displayGrade is displaying retake again even if the student is scoring 100 marks. We are violating the LSP here. The object m has the following property: m.marksToGrade always returns something from the set { 'A' , 'B' , 'C' , 'F' }, that the method displayGrade depends on explicitly. The subclass CSCUModule violated that and makes m.marksToGrade returns 'S' or 'U' , sabotaging displayGrade and causing it to fail. LSP cannot be enforced by the compiler 1 . The properties of an object have to be managed and agreed upon among programmers. A common way is to document these properties as part of the code documentation. Preventing Inheritance and Method Overriding Sometimes, it is useful for a developer to explicitly prevent a class to be inherited. Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs. Both the two java classes you have seen, java.lang.Math and java.lang.String , cannot be inherited from. In Java, we use the keyword final when declaring a class to tell Java that we ban this class from being inherited. 1 2 3 final class Circle { : } Alternatively, we can allow inheritance but still prevent a specific method from being overridden, by declaring a method as final . Usually, we do this on methods that are critical for the correctness of the class. For instance, 1 2 3 4 5 6 class Circle { : final public boolean contains ( Point p ) { : } } We can use assert to check some of the properties though. \u21a9","title":"13. Liskov Substitution Principle"},{"location":"13-lsp.html#unit-13-liskov-substitution-principle","text":"After this unit, the student should: understand the type of bugs that reckless developers can introduce when using inheritance and polymorphism understand the Liskov Substitution Principle and thus be aware that not all IS-A relationships should be modeled with inheritance know how to explicitly disallow inheritance when writing a class or disallow overriding with the final keyword","title":"Unit 13: Liskov Substitution Principle"},{"location":"13-lsp.html#the-responsibility-when-using-inheritance","text":"As you have seen in Unit 12 , polymorphism is a powerful tool that allows a client to change the behavior of existing code written by the implementer, behind the abstraction barrier. As Ben Parker (aka Uncle Ben) said, \"With great power, comes great responsibility.\" The client must use overriding and inheritance carefully. Since they can affect how existing code behaves, they can easily break existing code and introduce bugs. Since the client may not have access to the existing code behind the abstraction barrier, it is often tricky to trace and debug. Furthermore, the implementer would not appreciate it if their code was working perfectly until one day, someone overriding a method causes their code to fail, even without the implementer changing anything in their code. Ensuring this responsibility cannot be done by the compiler, unfortunately. It thus becomes a developer's responsibility to ensure that any inheritance with method overriding does not introduce bugs to existing code. This brings us to the Liskov Substitution Principle (LSP), which says: \"Let \\(\\phi(x)\\) be a property provable about objects \\(x\\) of type \\(T\\) . Then \\(\\phi(y)\\) should be true for objects \\(y\\) of type \\(S\\) where \\(S <: T\\) .\" This is consistent with the definition of subtyping, \\(S <: T\\) , but spelled out more formally. Let's consider the following example method, Module::marksToGrade , which takes in the marks of a student and returns the grade 'A', 'B', 'C', or 'F' as a char . How Module::marksToGrade is implemented is not important. Let's look at how it is used. 1 2 3 4 5 6 7 8 9 10 11 12 void displayGrade ( Module m , double marks ) { char grade = m . marksToGrade ( marks ); if ( grade == 'A' )) { System . out . println ( \"well done\" ); else if ( grade == 'B' ) { System . out . println ( \"good\" ); else if ( grade == 'C' ) { System . out . println ( \"ok\" ); } else { System . out . println ( \"retake again\" ); } } Now, suppose that one day, someone comes along and create a new class CSCUModule that inherits from Module , and overrides marksToGrade s that it now returns only 'S' and 'U'. Since CSCUModule is a subclass of Module , we can pass an instance to displayGrade : 1 displayGrade(new CSCUModule(\"GEQ1000\", 100)); and suddenly displayGrade is displaying retake again even if the student is scoring 100 marks. We are violating the LSP here. The object m has the following property: m.marksToGrade always returns something from the set { 'A' , 'B' , 'C' , 'F' }, that the method displayGrade depends on explicitly. The subclass CSCUModule violated that and makes m.marksToGrade returns 'S' or 'U' , sabotaging displayGrade and causing it to fail. LSP cannot be enforced by the compiler 1 . The properties of an object have to be managed and agreed upon among programmers. A common way is to document these properties as part of the code documentation.","title":"The Responsibility When Using Inheritance"},{"location":"13-lsp.html#preventing-inheritance-and-method-overriding","text":"Sometimes, it is useful for a developer to explicitly prevent a class to be inherited. Not allowing inheritance would make it much easier to argue for the correctness of programs, something that is important when it comes to writing secure programs. Both the two java classes you have seen, java.lang.Math and java.lang.String , cannot be inherited from. In Java, we use the keyword final when declaring a class to tell Java that we ban this class from being inherited. 1 2 3 final class Circle { : } Alternatively, we can allow inheritance but still prevent a specific method from being overridden, by declaring a method as final . Usually, we do this on methods that are critical for the correctness of the class. For instance, 1 2 3 4 5 6 class Circle { : final public boolean contains ( Point p ) { : } } We can use assert to check some of the properties though. \u21a9","title":"Preventing Inheritance and Method Overriding"},{"location":"14-abstract.html","text":"Unit 14: Abstract Class After this lecture, students should: be familiar with the concept of an abstract class know the use of the Java keyword abstract and the constraints that come with it understand the usefulness of defining and using an abstract class understand what makes a class concrete High-Level Abstraction Recall that the concept of abstraction involves hiding away unnecessary complexity and details so that programmers do not have to bogged down with the nitty-gritty. When we code, we should, as much as possible, try to work with the higher-level abstraction, rather than the detailed version. Following this principle would allow us to write code that is general and extensible, by taking full advantage of inheritance and polymorphism. Take the following example which you have seen, 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } The function above is very general. We do not assume and do not need to know, about the details of the items being stored or search. All we required is that the equals method compared if two objects are equal. In contrast, someone whose mind focuses on finding a circle, might write something like this: 1 2 3 4 5 6 7 8 9 // version 0.3 (for Circle) boolean contains ( Circle [] array , Circle circle ) { for ( Circle curr : array ) { if ( curr . equals ( circle )) { return true ; } } return false ; } which serves the purpose, but is not general enough. The only method used is equals , which Circle inherits/overrides from Object so that using Circle for this function is too constraining. We can reuse this for any other subclasses of Circle, but not other classes. Abstracting Circles Now, let's consider the following function, which finds the largest area among the circles in a given array: 1 2 3 4 5 6 7 8 9 10 11 // version 0.1 double findLargest ( Circle [] array ) { double maxArea = 0 ; for ( Circle curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } findLargest suffers from the same specificity as the version 0.3 of contains . It only works for Circle and its subclasses only. Can we make this more general? We cannot replace Circle with Object , 1 2 3 4 5 6 7 8 9 10 11 // version 0.2 double findLargest ( Object [] array ) { double maxArea = 0 ; for ( Object curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } since getArea is not defined for a generic object (e.g., what does getArea of a string mean?). To allow us to apply findLargest to a more generic object, we have to create a new type -- something more specific than Object that supports getArea() , yet more general than Circle . Shape Let's create a new class called Shape , and redefine our Circle class as a subclass of Shape . We can now create other shapes, Square , Rectangle , Triangle , etc, and define the getArea method for each of them. With the new Shape class, we can rewrite findLargest as: 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( Shape [] array ) { double maxArea = 0 ; for ( Shape curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxShape ; } which now not only works for an array of Square , Rectangle , Circle , etc but also an array containing multiple shapes! Let's actually write out our new Shape class: 1 2 3 4 5 class Shape { public double getArea () { // ? } } and rewrite our Circle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.8 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle extends Shape { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ @Override public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { // TODO: Left as an exercise return false ; } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } } } Notably, since our Shape is a highly abstract entity, it does not have any fields. One question that arises is, how are we going to write Shape::getArea() ? We cannot compute the area of a shape unless we know what sort of shape it is. One solution is make Shape::getArea() returns 0. 1 2 3 4 5 class Shape { public double getArea () { return 0 ; } } This is not ideal. It is easy for someone to inherit from Shape , but forget to override getArea() . If this happens, then the subclass will have an area of 0. Bugs ensue. As we usually do in CS2030S, we want to exploit programming language constructs and the compiler to check and catch such errors for us. Abstract Methods and Classes This brings us to the concept of abstract classes . An abstract class in Java is a class that has been made into something so general that it cannot and should not be instantiated. Usually, this means that one or more of its instance methods cannot be implemented without further details. The Shape class above makes a good abstract class since we do not have enough details to implement Shape::getArea . To declare an abstract class in Java, we add the abstract keyword to the class declaration. To make a method abstract, we add the keyword abstract when we declare the method. An abstract method cannot be implemented and therefore should not have any method body. This is how we implement Shape as an abstract class. 1 2 3 abstract class Shape { abstract public double getArea (); } An abstract class cannot be instantiated. Any attempt to do so, such as: 1 Shape s = new Shape(); would result in an error. Note that our simple example of Shape only encapsulates one abstract method. An abstract class can contain multiple fields and multiple methods. Not all the methods have to be abstract. As long as one of them is abstract, the class becomes abstract. To illustrate this, consider 1 2 3 4 5 6 7 8 9 abstract class Shape { private int numOfAxesOfSymmetry ; public boolean isSymmetric () { return numOfAxesOfSymmetry > 0 ; } abstract public double getArea (); } Shape::isSymmetric is a concrete method but the class is still abstract since Shape::getArea() is abstract. Concrete Classes We call a class that is not abstract as a concrete class . A concrete class cannot have any abstract method. Thus, any subclass of Shape must override getArea() to supply its own implementation.","title":"14. Abstract Class"},{"location":"14-abstract.html#unit-14-abstract-class","text":"After this lecture, students should: be familiar with the concept of an abstract class know the use of the Java keyword abstract and the constraints that come with it understand the usefulness of defining and using an abstract class understand what makes a class concrete","title":"Unit 14: Abstract Class"},{"location":"14-abstract.html#high-level-abstraction","text":"Recall that the concept of abstraction involves hiding away unnecessary complexity and details so that programmers do not have to bogged down with the nitty-gritty. When we code, we should, as much as possible, try to work with the higher-level abstraction, rather than the detailed version. Following this principle would allow us to write code that is general and extensible, by taking full advantage of inheritance and polymorphism. Take the following example which you have seen, 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } The function above is very general. We do not assume and do not need to know, about the details of the items being stored or search. All we required is that the equals method compared if two objects are equal. In contrast, someone whose mind focuses on finding a circle, might write something like this: 1 2 3 4 5 6 7 8 9 // version 0.3 (for Circle) boolean contains ( Circle [] array , Circle circle ) { for ( Circle curr : array ) { if ( curr . equals ( circle )) { return true ; } } return false ; } which serves the purpose, but is not general enough. The only method used is equals , which Circle inherits/overrides from Object so that using Circle for this function is too constraining. We can reuse this for any other subclasses of Circle, but not other classes.","title":"High-Level Abstraction"},{"location":"14-abstract.html#abstracting-circles","text":"Now, let's consider the following function, which finds the largest area among the circles in a given array: 1 2 3 4 5 6 7 8 9 10 11 // version 0.1 double findLargest ( Circle [] array ) { double maxArea = 0 ; for ( Circle curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } findLargest suffers from the same specificity as the version 0.3 of contains . It only works for Circle and its subclasses only. Can we make this more general? We cannot replace Circle with Object , 1 2 3 4 5 6 7 8 9 10 11 // version 0.2 double findLargest ( Object [] array ) { double maxArea = 0 ; for ( Object curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } since getArea is not defined for a generic object (e.g., what does getArea of a string mean?). To allow us to apply findLargest to a more generic object, we have to create a new type -- something more specific than Object that supports getArea() , yet more general than Circle .","title":"Abstracting Circles"},{"location":"14-abstract.html#shape","text":"Let's create a new class called Shape , and redefine our Circle class as a subclass of Shape . We can now create other shapes, Square , Rectangle , Triangle , etc, and define the getArea method for each of them. With the new Shape class, we can rewrite findLargest as: 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( Shape [] array ) { double maxArea = 0 ; for ( Shape curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxShape ; } which now not only works for an array of Square , Rectangle , Circle , etc but also an array containing multiple shapes! Let's actually write out our new Shape class: 1 2 3 4 5 class Shape { public double getArea () { // ? } } and rewrite our Circle : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // version 0.8 import java.lang.Math ; /** * A Circle object encapsulates a circle on a 2D plane. */ class Circle extends Shape { private Point c ; // the center private double r ; // the length of the radius /** * Create a circle centered on Point c with given radius r */ public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } /** * Return the area of the circle. */ @Override public double getArea () { return Math . PI * this . r * this . r ; } /** * Return true if the given point p is within the circle. */ public boolean contains ( Point p ) { // TODO: Left as an exercise return false ; } /** * Return the string representation of this circle. */ @Override public String toString () { return \"{ center: \" + this . c + \", radius: \" + this . r + \" }\" ; } /** * Return true the object is the same circle (i.e., same center, same radius). */ @Override public boolean equals ( Object obj ) { if ( obj instanceof Circle ) { Circle circle = ( Circle ) obj ; return ( circle . c . equals ( this . c ) && circle . r == this . r ); } } } Notably, since our Shape is a highly abstract entity, it does not have any fields. One question that arises is, how are we going to write Shape::getArea() ? We cannot compute the area of a shape unless we know what sort of shape it is. One solution is make Shape::getArea() returns 0. 1 2 3 4 5 class Shape { public double getArea () { return 0 ; } } This is not ideal. It is easy for someone to inherit from Shape , but forget to override getArea() . If this happens, then the subclass will have an area of 0. Bugs ensue. As we usually do in CS2030S, we want to exploit programming language constructs and the compiler to check and catch such errors for us.","title":"Shape"},{"location":"14-abstract.html#abstract-methods-and-classes","text":"This brings us to the concept of abstract classes . An abstract class in Java is a class that has been made into something so general that it cannot and should not be instantiated. Usually, this means that one or more of its instance methods cannot be implemented without further details. The Shape class above makes a good abstract class since we do not have enough details to implement Shape::getArea . To declare an abstract class in Java, we add the abstract keyword to the class declaration. To make a method abstract, we add the keyword abstract when we declare the method. An abstract method cannot be implemented and therefore should not have any method body. This is how we implement Shape as an abstract class. 1 2 3 abstract class Shape { abstract public double getArea (); } An abstract class cannot be instantiated. Any attempt to do so, such as: 1 Shape s = new Shape(); would result in an error. Note that our simple example of Shape only encapsulates one abstract method. An abstract class can contain multiple fields and multiple methods. Not all the methods have to be abstract. As long as one of them is abstract, the class becomes abstract. To illustrate this, consider 1 2 3 4 5 6 7 8 9 abstract class Shape { private int numOfAxesOfSymmetry ; public boolean isSymmetric () { return numOfAxesOfSymmetry > 0 ; } abstract public double getArea (); } Shape::isSymmetric is a concrete method but the class is still abstract since Shape::getArea() is abstract.","title":"Abstract Methods and Classes"},{"location":"14-abstract.html#concrete-classes","text":"We call a class that is not abstract as a concrete class . A concrete class cannot have any abstract method. Thus, any subclass of Shape must override getArea() to supply its own implementation.","title":"Concrete Classes"},{"location":"15-interface.html","text":"Unit 15: Interface After taking this unit, students should: understand interface as a type for modeling \"can do\" behavior understand the subtype-supertype relationship between a class and its interfaces Modeling Behavior We have seen how we can write our program using superclasses (including abstract ones) to make our code more general and flexible. In this unit, we will kick this up one more notch and try to write something even more general, through another abstraction. Let's reexamine this method again: 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( Shape [] array ) { double maxArea = 0 ; for ( Shape curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } Note that all that is required for this method to work, is that the type of objects in array supports a getArea method. While Shape that we defined in the previous unit meets this requirement, it does not have to be. We could pass in an array of countries or an array of HDB flats. It is unnatural to model a Country or a Flat as a subclass of Shape (recall inheritance models the IS-A relationship). To resolve this, we will look at an abstraction that models what can an entity do, possibly across different class hierarchies. Interface The abstraction to do this is called an interface . An interface is also a type and is declared with the keyword interface . Since an interface models what an entity can do, the name usually ends with the -able suffix 1 . Suppose we want to create a type that supports the getArea() method, be it a shape, a geographical region, or a real estate property. Let's call it GetAreable : 1 2 3 interface GetAreable { public abstract double getArea (); } All methods declared in an interface are public abstract by default. We could also just write: 1 2 3 interface GetAreable { double getArea (); } Now, for every class that we wish to be able to call getArea() on, we tell Java that the class implements that particular interface. For instance, 1 2 3 4 5 6 7 abstract class Shape implements GetAreable { private int numOfAxesOfSymmetry ; public boolean isSymmetric () { return numOfAxesOfSymmetry > 0 ; } } The Shape class will now have a public abstract double getArea() thanks to it implementing the GetAreable interface. We can have a concrete class implementing an interface too. 1 2 3 4 5 6 7 8 9 10 11 12 class Flat extends RealEstate implements GetAreable { private int numOfRooms ; private String block ; private String street ; private int floor ; private int unit ; @Override public double getArea () { : } } For a class to implement an interface and be concrete, it has to override all abstract methods from the interface and provide an implementation to each, just like the example above. Otherwise, the class becomes abstract. With the GetAreable interface, we can now make our function findLargest even more general. 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( GetAreable [] array ) { double maxArea = 0 ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } Note: A class can only extend from one superclass, but it can implement multiple interfaces. An interface can extend from one or more other interfaces, but an interface cannot extend from another class. Interface as Supertype If a class \\(C\\) implements an interface \\(I\\) , \\(C <: I\\) . This definition implies that a type can have multiple supertypes. In the example above, Flat <: GetAreable and Flat <: RealEstate . Impure Interfaces As we mentioned at the beginning of this module, it is common for software requirements, and their design, to continuously evolve. But once we define an interface, it is difficult to change. Suppose that, after we define that GetAreable interface, other developers in the team starts to write classes that implement this interface. One fine day, we realize that we need to add more methods into the getAreable . Perhaps we need methods getSqFt() and getMeter2() in the interface. But, one cannot simply change the interface and add these abstract methods now. The other developers will have to change their classes to add the implementation of two methods, or else their code would not compile! This is what happened to the Java language when they transitted from version 7 to version 8. The language needed to add a bunch of useful methods to standard interfaces provided by the Java library, but doing so would break existing code in the 1990s that rely on these interfaces. The solution that Java came up with is the allow an interface to provide a default implementation of methods that all implementation subclasses will inherit (unless they override). A method with default implementation is tagged with the default keyword. This leads to a less elegant situation where an interface has some abstract methods and some non-abstract default methods. In CS2030S, we refer to this as impure interfaces and it is a pain to explain since it breaks our clean distinction between a class and an interface. We prefer not to talk about it -- but it is there in Java 8 and up. Although in recent Java releases, this is less common. \u21a9","title":"15. Interface"},{"location":"15-interface.html#unit-15-interface","text":"After taking this unit, students should: understand interface as a type for modeling \"can do\" behavior understand the subtype-supertype relationship between a class and its interfaces","title":"Unit 15: Interface"},{"location":"15-interface.html#modeling-behavior","text":"We have seen how we can write our program using superclasses (including abstract ones) to make our code more general and flexible. In this unit, we will kick this up one more notch and try to write something even more general, through another abstraction. Let's reexamine this method again: 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( Shape [] array ) { double maxArea = 0 ; for ( Shape curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } Note that all that is required for this method to work, is that the type of objects in array supports a getArea method. While Shape that we defined in the previous unit meets this requirement, it does not have to be. We could pass in an array of countries or an array of HDB flats. It is unnatural to model a Country or a Flat as a subclass of Shape (recall inheritance models the IS-A relationship). To resolve this, we will look at an abstraction that models what can an entity do, possibly across different class hierarchies.","title":"Modeling Behavior"},{"location":"15-interface.html#interface","text":"The abstraction to do this is called an interface . An interface is also a type and is declared with the keyword interface . Since an interface models what an entity can do, the name usually ends with the -able suffix 1 . Suppose we want to create a type that supports the getArea() method, be it a shape, a geographical region, or a real estate property. Let's call it GetAreable : 1 2 3 interface GetAreable { public abstract double getArea (); } All methods declared in an interface are public abstract by default. We could also just write: 1 2 3 interface GetAreable { double getArea (); } Now, for every class that we wish to be able to call getArea() on, we tell Java that the class implements that particular interface. For instance, 1 2 3 4 5 6 7 abstract class Shape implements GetAreable { private int numOfAxesOfSymmetry ; public boolean isSymmetric () { return numOfAxesOfSymmetry > 0 ; } } The Shape class will now have a public abstract double getArea() thanks to it implementing the GetAreable interface. We can have a concrete class implementing an interface too. 1 2 3 4 5 6 7 8 9 10 11 12 class Flat extends RealEstate implements GetAreable { private int numOfRooms ; private String block ; private String street ; private int floor ; private int unit ; @Override public double getArea () { : } } For a class to implement an interface and be concrete, it has to override all abstract methods from the interface and provide an implementation to each, just like the example above. Otherwise, the class becomes abstract. With the GetAreable interface, we can now make our function findLargest even more general. 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( GetAreable [] array ) { double maxArea = 0 ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } Note: A class can only extend from one superclass, but it can implement multiple interfaces. An interface can extend from one or more other interfaces, but an interface cannot extend from another class.","title":"Interface"},{"location":"15-interface.html#interface-as-supertype","text":"If a class \\(C\\) implements an interface \\(I\\) , \\(C <: I\\) . This definition implies that a type can have multiple supertypes. In the example above, Flat <: GetAreable and Flat <: RealEstate .","title":"Interface as Supertype"},{"location":"15-interface.html#impure-interfaces","text":"As we mentioned at the beginning of this module, it is common for software requirements, and their design, to continuously evolve. But once we define an interface, it is difficult to change. Suppose that, after we define that GetAreable interface, other developers in the team starts to write classes that implement this interface. One fine day, we realize that we need to add more methods into the getAreable . Perhaps we need methods getSqFt() and getMeter2() in the interface. But, one cannot simply change the interface and add these abstract methods now. The other developers will have to change their classes to add the implementation of two methods, or else their code would not compile! This is what happened to the Java language when they transitted from version 7 to version 8. The language needed to add a bunch of useful methods to standard interfaces provided by the Java library, but doing so would break existing code in the 1990s that rely on these interfaces. The solution that Java came up with is the allow an interface to provide a default implementation of methods that all implementation subclasses will inherit (unless they override). A method with default implementation is tagged with the default keyword. This leads to a less elegant situation where an interface has some abstract methods and some non-abstract default methods. In CS2030S, we refer to this as impure interfaces and it is a pain to explain since it breaks our clean distinction between a class and an interface. We prefer not to talk about it -- but it is there in Java 8 and up. Although in recent Java releases, this is less common. \u21a9","title":"Impure Interfaces"},{"location":"16-wrapper.html","text":"Unit 16: Wrapper Class After this unit, students should: be aware that Java provides wrapper classes around the primitive types be aware that Java will transparently and automatically box and unbox between primitive types and their corresponding wrapper classes Writing General Code for Primitive Types We have seen the following general code that takes in an array of Object objects, and searches if another object obj is in the given array . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } Through polymorphism and overriding of the equals method, we can make sure that it is general enough to work on any reference type. But what about primitive types? Do we need to write a separate function for each primitive type, like this? 1 2 3 4 5 6 7 8 9 // version 0.4 (for int, a primitive type) boolean contains ( int [] array , int obj ) { for ( int curr : array ) { if ( curr == obj ) { return true ; } } return false ; } Making Primitive Types Less Primitive Java provides wrapper classes for each of its primitive types. A wrapper class is a class that encapsulates a type , rather than fields and methods. The wrapper class for int is called Integer , for double is called Double , etc. A wrapper class can be used just like every other class in Java and behave just like every other class in Java. In particular, they are reference types and their instances can be created with new ; instances are stored on the heap, etc. For instance, 1 2 Integer i = new Integer(4); int j = i.intValue(); The code snippet above shows how we can convert a primitive int value to a wrapper instance i of type Integer , and how the intValue method can retrieve the int value from an Integer instance. With the wrapper type, we can reuse our contains method that takes in an Object array as a parameter to operate on an array of integers -- we just need to pass our integers into the method in an Integer array instead of an int array. All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed. Auto-boxing and Unboxing As conversion back-and-fro between a primitive type and its wrapper class is pretty common, Java provides a feature called auto-boxing/unboxing to perform type conversion between primitive type and its wrapper class. For instance, 1 2 Integer i = 4; int j = i; The first statement is an example of auto-boxing, where the primitive value int of 4 is converted into an instance of Integer . The second statement converts an instance of Integer back to int (without affecting its value of 4). Performance Since the wrapper classes allow us to write flexible programs, why not use them all the time and forget about primitive types? The answer: performance. Because using an object comes with the cost of allocating memory for the object and collecting garbage afterward, it is less efficient than primitive types. Consider the following two programs: 1 2 3 4 5 Double sum ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { sum += i ; } vs. 1 2 3 4 5 double sum ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { sum += i ; } The second one can be about 2 times faster. All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed. Thus, every time the sum in the first example above is updated, a new Double object gets created. Due to autoboxing and unboxing, the cost of creating objects becomes hidden and is often forgotten. The Java API in fact, provides multiple versions of the same method, one for all the reference types using Object , and one for each of the primitive types. This decision leads to multiple versions of the same code, but with the benefits of better performance. See the Arrays class for instance.","title":"16. Wrapper Class"},{"location":"16-wrapper.html#unit-16-wrapper-class","text":"After this unit, students should: be aware that Java provides wrapper classes around the primitive types be aware that Java will transparently and automatically box and unbox between primitive types and their corresponding wrapper classes","title":"Unit 16: Wrapper Class"},{"location":"16-wrapper.html#writing-general-code-for-primitive-types","text":"We have seen the following general code that takes in an array of Object objects, and searches if another object obj is in the given array . 1 2 3 4 5 6 7 8 9 // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } Through polymorphism and overriding of the equals method, we can make sure that it is general enough to work on any reference type. But what about primitive types? Do we need to write a separate function for each primitive type, like this? 1 2 3 4 5 6 7 8 9 // version 0.4 (for int, a primitive type) boolean contains ( int [] array , int obj ) { for ( int curr : array ) { if ( curr == obj ) { return true ; } } return false ; }","title":"Writing General Code for Primitive Types"},{"location":"16-wrapper.html#making-primitive-types-less-primitive","text":"Java provides wrapper classes for each of its primitive types. A wrapper class is a class that encapsulates a type , rather than fields and methods. The wrapper class for int is called Integer , for double is called Double , etc. A wrapper class can be used just like every other class in Java and behave just like every other class in Java. In particular, they are reference types and their instances can be created with new ; instances are stored on the heap, etc. For instance, 1 2 Integer i = new Integer(4); int j = i.intValue(); The code snippet above shows how we can convert a primitive int value to a wrapper instance i of type Integer , and how the intValue method can retrieve the int value from an Integer instance. With the wrapper type, we can reuse our contains method that takes in an Object array as a parameter to operate on an array of integers -- we just need to pass our integers into the method in an Integer array instead of an int array. All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed.","title":"Making Primitive Types Less Primitive"},{"location":"16-wrapper.html#auto-boxing-and-unboxing","text":"As conversion back-and-fro between a primitive type and its wrapper class is pretty common, Java provides a feature called auto-boxing/unboxing to perform type conversion between primitive type and its wrapper class. For instance, 1 2 Integer i = 4; int j = i; The first statement is an example of auto-boxing, where the primitive value int of 4 is converted into an instance of Integer . The second statement converts an instance of Integer back to int (without affecting its value of 4).","title":"Auto-boxing and Unboxing"},{"location":"16-wrapper.html#performance","text":"Since the wrapper classes allow us to write flexible programs, why not use them all the time and forget about primitive types? The answer: performance. Because using an object comes with the cost of allocating memory for the object and collecting garbage afterward, it is less efficient than primitive types. Consider the following two programs: 1 2 3 4 5 Double sum ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { sum += i ; } vs. 1 2 3 4 5 double sum ; for ( int i = 0 ; i < Integer . MAX_VALUE ; i ++ ) { sum += i ; } The second one can be about 2 times faster. All primitive wrapper class objects are immutable -- once you create an object, it cannot be changed. Thus, every time the sum in the first example above is updated, a new Double object gets created. Due to autoboxing and unboxing, the cost of creating objects becomes hidden and is often forgotten. The Java API in fact, provides multiple versions of the same method, one for all the reference types using Object , and one for each of the primitive types. This decision leads to multiple versions of the same code, but with the benefits of better performance. See the Arrays class for instance.","title":"Performance"},{"location":"17-casting.html","text":"Unit 17: Run-Time Class Mismatch After taking this unit, students should: Understand the need for narrowing type conversion and type casting when writing code that depends on higher-level abstraction Understand the possibility of encountering run-time errors if typecasting is not done properly. We have seen in Unit 15 how we can write code that is reusable and general by making our code dependent on types at a higher-level of abstraction. Our main example is the following findLargest method, which takes in an array of objects that support the getArea method, and returns the largest area among these objects. 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( GetAreable [] array ) { double maxArea = 0 ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } The method served our purpose well, but it is NOT a very well-designed method. Just returning the value of the largest area is not as useful as returning the object with the largest area. Once the caller has a reference of the object, the caller can call getArea to find the value of the largest area. Let's write our findLargest method to find which object has the largest area instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.4 GetAreable findLargest ( GetAreable [] array ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } Let's see how findLargest can be used: 1 2 3 4 5 6 7 8 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Circle ( new Point ( 0 , 0 ), 5 ) }; GetAreable ga = findLargest ( circles ); // ok Circle c1 = findLargest ( circles ); // error Circle c2 = ( Circle ) findLargest ( circles ); // ok The return type of findLargest (version 0.4) is now GetAreable . On Line 6 above, we assign the return object with a compile-time type of GetAreable to ga , which also has GetAreable as its compile-time type. Since the variable ga is of type GetAreable , however, it is not very useful. Recall that GetAreable is an interface with only one method getArea . We cannot use it as a circle. On Line 7, we try to return the return object to a variable with compile-time type Circle . This line, however, causes a compile-time error. Since Circle <: GetAreable , this is a narrowing type conversion and thus is not allowed (See Unit 12 ). We will have to make an explicit cast of the result to Circle (on Line 8). Only with casting, our code can compile and we get a reference with a compile-time type of Circle . Cast Carefully Typecasting, as we did in Line 8 above, is basically is a way for programmers to ask the compiler to trust that the object returned by findLargest has a run-time type of Circle (or its subtype). In the snippet above, we can be sure (even prove ) that the returned object from findLargest must have a run-time type of Circle since the input variable circles contains only Circle objects. The need to cast our returned object, however, leads to fragile code. Since the correctness of Line 8 depends on the run-time type, the compiler cannot help us. It is then up to the programmers to not make mistakes. Consider the following two snippets, which will compile perfectly, but will lead to the program crashing at run-time. 1 2 3 4 5 6 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Square ( new Point ( 1 , 1 ), 5 ) }; Circle c2 = ( Circle ) findLargest ( circles ); Or 1 2 3 4 5 6 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Circle ( new Point ( 1 , 1 ), 5 ) }; Square sq = ( Square ) findLargest ( circles ); We will see how to resolve this problem in later units.","title":"17. Casting"},{"location":"17-casting.html#unit-17-run-time-class-mismatch","text":"After taking this unit, students should: Understand the need for narrowing type conversion and type casting when writing code that depends on higher-level abstraction Understand the possibility of encountering run-time errors if typecasting is not done properly. We have seen in Unit 15 how we can write code that is reusable and general by making our code dependent on types at a higher-level of abstraction. Our main example is the following findLargest method, which takes in an array of objects that support the getArea method, and returns the largest area among these objects. 1 2 3 4 5 6 7 8 9 10 11 // version 0.3 double findLargest ( GetAreable [] array ) { double maxArea = 0 ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; } } return maxArea ; } The method served our purpose well, but it is NOT a very well-designed method. Just returning the value of the largest area is not as useful as returning the object with the largest area. Once the caller has a reference of the object, the caller can call getArea to find the value of the largest area. Let's write our findLargest method to find which object has the largest area instead. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.4 GetAreable findLargest ( GetAreable [] array ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } Let's see how findLargest can be used: 1 2 3 4 5 6 7 8 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Circle ( new Point ( 0 , 0 ), 5 ) }; GetAreable ga = findLargest ( circles ); // ok Circle c1 = findLargest ( circles ); // error Circle c2 = ( Circle ) findLargest ( circles ); // ok The return type of findLargest (version 0.4) is now GetAreable . On Line 6 above, we assign the return object with a compile-time type of GetAreable to ga , which also has GetAreable as its compile-time type. Since the variable ga is of type GetAreable , however, it is not very useful. Recall that GetAreable is an interface with only one method getArea . We cannot use it as a circle. On Line 7, we try to return the return object to a variable with compile-time type Circle . This line, however, causes a compile-time error. Since Circle <: GetAreable , this is a narrowing type conversion and thus is not allowed (See Unit 12 ). We will have to make an explicit cast of the result to Circle (on Line 8). Only with casting, our code can compile and we get a reference with a compile-time type of Circle .","title":"Unit 17: Run-Time Class Mismatch"},{"location":"17-casting.html#cast-carefully","text":"Typecasting, as we did in Line 8 above, is basically is a way for programmers to ask the compiler to trust that the object returned by findLargest has a run-time type of Circle (or its subtype). In the snippet above, we can be sure (even prove ) that the returned object from findLargest must have a run-time type of Circle since the input variable circles contains only Circle objects. The need to cast our returned object, however, leads to fragile code. Since the correctness of Line 8 depends on the run-time type, the compiler cannot help us. It is then up to the programmers to not make mistakes. Consider the following two snippets, which will compile perfectly, but will lead to the program crashing at run-time. 1 2 3 4 5 6 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Square ( new Point ( 1 , 1 ), 5 ) }; Circle c2 = ( Circle ) findLargest ( circles ); Or 1 2 3 4 5 6 GetAreable [] circles = new GetAreable [] { new Circle ( new Point ( 1 , 1 ), 2 ), new Circle ( new Point ( 1 , 1 ), 5 ) }; Square sq = ( Square ) findLargest ( circles ); We will see how to resolve this problem in later units.","title":"Cast Carefully"},{"location":"18-variance.html","text":"Unit 18: Variance After this unit, students should: understand the definition of the variance of types: covariant, contravariant, and invariant. be aware that the Java array is covariant and how it could lead to run-time errors that cannot be caught during compile time. Both the methods findLargest and contains takes in an array of reference types as parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.4 GetAreable findLargest ( GetAreable [] rray ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } What are some possible arrays that we can pass into these methods? Let's try this: 1 2 3 4 5 Object [] objArray = new Object [] { new Integer ( 1 ), new Integer ( 2 ) }; Integer [] intArray = new Integer [] { new Integer ( 1 ), new Integer ( 2 ) }; contains ( objArray , new Integer ( 1 )); // ok contains ( intArray , new Integer ( 1 )); // ok Line 4 is not surprising since the type for objArray matches that of parameter array . Line 5, however, shows that it is possible to assign an instance with run-time type Integer[] to a variable with compile-time type Object[] . Variance of Types So far, we have established the subtype relationship between classes and interfaces based on inheritance and implementation. The subtype relationship between complex types such as arrays, however, is not so trivial. Let's look at some definitions. The variance of types refers to how the subtype relationship between complex types relates to the subtype relationship between components. Let \\(C(S)\\) corresponds to some complex type based on type \\(S\\) . An array of type \\(S\\) is an example of a complex type. We say a complex type is: covariant if \\(S <: T\\) implies \\(C(S) <: C(T)\\) contravariant if \\(S <: T\\) implies \\(C(T) <: C(S)\\) invariant if it is neither covariant nor contravariant. Java Array is Covariant Array is covariant in Java. This means that, if \\(S <: T\\) , then \\(S[] <: T[]\\) . For example, because Integer <: Object , we have Integer[] <: Object[] and we can do the following: 1 2 3 Integer [] intArray ; Object [] objArray ; objArray = intArray ; // ok By making array covariant, however, Java opens up the possibility of run-time errors, even without typecasting! Consider the following code: 1 2 3 4 5 6 Integer [] intArray = new Integer [ 2 ] { new Integer ( 10 ), new Integer ( 20 ) }; Object [] objArray ; objArray = intArray ; objArray [ 0 ] = \"Hello!\" ; // <- compiles! On Line 5 above, we set objArray (with a compile-time type of Object[] ) to refer to an object with a run-time type of Integer[] . This is allowed since the array is covariant. On Line 6, we try to put a String object into the Object array. Since String <: Object , the compiler allows this. The compiler does not realize that at run-time, the Object array will refer to an array of Integer . So we now have a perfectly compilable code, that will crash on us when it executes Line 6 -- only then would Java realize that we are trying to stuff a string into an array of integers! This is an example of a type system rule that is unsafe. Since the array type is an essential part of the Java language, this rule cannot be changed without ruining existing code. We will see later how Java avoids this pitfall for other complex types (such as a list).","title":"18. Variance"},{"location":"18-variance.html#unit-18-variance","text":"After this unit, students should: understand the definition of the variance of types: covariant, contravariant, and invariant. be aware that the Java array is covariant and how it could lead to run-time errors that cannot be caught during compile time. Both the methods findLargest and contains takes in an array of reference types as parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.4 GetAreable findLargest ( GetAreable [] rray ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } // version 0.1 (with polymorphism) boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } What are some possible arrays that we can pass into these methods? Let's try this: 1 2 3 4 5 Object [] objArray = new Object [] { new Integer ( 1 ), new Integer ( 2 ) }; Integer [] intArray = new Integer [] { new Integer ( 1 ), new Integer ( 2 ) }; contains ( objArray , new Integer ( 1 )); // ok contains ( intArray , new Integer ( 1 )); // ok Line 4 is not surprising since the type for objArray matches that of parameter array . Line 5, however, shows that it is possible to assign an instance with run-time type Integer[] to a variable with compile-time type Object[] .","title":"Unit 18: Variance"},{"location":"18-variance.html#variance-of-types","text":"So far, we have established the subtype relationship between classes and interfaces based on inheritance and implementation. The subtype relationship between complex types such as arrays, however, is not so trivial. Let's look at some definitions. The variance of types refers to how the subtype relationship between complex types relates to the subtype relationship between components. Let \\(C(S)\\) corresponds to some complex type based on type \\(S\\) . An array of type \\(S\\) is an example of a complex type. We say a complex type is: covariant if \\(S <: T\\) implies \\(C(S) <: C(T)\\) contravariant if \\(S <: T\\) implies \\(C(T) <: C(S)\\) invariant if it is neither covariant nor contravariant.","title":"Variance of Types"},{"location":"18-variance.html#java-array-is-covariant","text":"Array is covariant in Java. This means that, if \\(S <: T\\) , then \\(S[] <: T[]\\) . For example, because Integer <: Object , we have Integer[] <: Object[] and we can do the following: 1 2 3 Integer [] intArray ; Object [] objArray ; objArray = intArray ; // ok By making array covariant, however, Java opens up the possibility of run-time errors, even without typecasting! Consider the following code: 1 2 3 4 5 6 Integer [] intArray = new Integer [ 2 ] { new Integer ( 10 ), new Integer ( 20 ) }; Object [] objArray ; objArray = intArray ; objArray [ 0 ] = \"Hello!\" ; // <- compiles! On Line 5 above, we set objArray (with a compile-time type of Object[] ) to refer to an object with a run-time type of Integer[] . This is allowed since the array is covariant. On Line 6, we try to put a String object into the Object array. Since String <: Object , the compiler allows this. The compiler does not realize that at run-time, the Object array will refer to an array of Integer . So we now have a perfectly compilable code, that will crash on us when it executes Line 6 -- only then would Java realize that we are trying to stuff a string into an array of integers! This is an example of a type system rule that is unsafe. Since the array type is an essential part of the Java language, this rule cannot be changed without ruining existing code. We will see later how Java avoids this pitfall for other complex types (such as a list).","title":"Java Array is Covariant"},{"location":"19-exception.html","text":"Unit 19: Exceptions After this unit, students should: understand about handling java exceptions and how to use the try - catch - finally blocks understand the hierarchy of exception classes and the difference between checked and unchecked exceptions be able to create their own exceptions understand the control flow of exceptions be aware of good practices for exception handling One of the nuances of programming is having to write code to deal with exceptions and errors. Consider writing a method that reads in a single integer value from a file. Here are some things that could go wrong: The file to read from may not exist The file to read from exists, but you may not have permission to read it You can open the file for reading, but it might contain non-numeric text where you expect numerical values The file might contain fewer values than expected The file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive) In C, we usually have to write code like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fd = fopen ( filename , \"r\" ); if ( fd == NULL ) { fprintf ( stderr , \"Unable to open file. \" ); if ( errno == ENFILE ) { fprintf ( stderr , \"Too many opened files. Unable to open another \\n \" ); } else if ( errno == ENOENT ) { fprintf ( stderr , \"No such file %s \\n \" , filename ); } else if ( errno == EACCES ) { fprintf ( stderr , \"No read permission to %s \\n \" , filename ); } return -1 ; } scanned = fscanf ( fd , \"%d\" , & value ); if ( scanned == 0 ) { fprintf ( stderr , \"Unable to scan for an integer \\n \" ); fclose ( fd ); return -2 ; } if ( scanned == EOF ) { fprintf ( stderr , \"No input found. \\n \" ); fclose ( fd ); return -3 ; } Out of the lines above, only TWO lines correspond to the actual task of opening and reading in a file, the others are for exception checking/handling. The actual tasks are interspersed between exception checking code, which makes reading and understanding the logic of the code difficult. The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors. Note that the POSIX API has a global variable errno that signifies the detailed error. First, we have to check for different errno values and react accordingly (we can use perror , but that has its limits). Second, errno is global, and using a global variable is a bad practice. In fact, the code above might not work because fprintf in Line 3 might have changed errno . Finally, there is the issue of having to repeatedly clean up after an error -- here we fclose the file if there is an error reading, twice. It is easy to forget to do so if we have to do this in multiple places. Furthermore, if we need to perform a more complex clean up, then we would end up with lots of repeated code. Many modern programming languages support exceptions as a programming construct. In Java, this is done with try , catch , finally keywords, and a hierarchy of Exception classes. The try / catch / finally keywords group statements that check/handle errors together making code easier to read. The Java equivalent to the above is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 try { reader = new FileReader ( filename ); scanner = new Scanner ( reader ); value = scanner . nextInt (); } catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } catch ( InputMismatchException e ) { System . err . println ( \"Unable to scan for an integer\" ); } catch ( NoSuchElementException e ) { System . err . println ( \"No input found\" ); } finally { if ( scanner != null ) scanner . close (); } Let's look at the example more carefully. The general syntax for try - catch - finally is the following: 1 2 3 4 5 6 7 8 try { // do something } catch ( an exception parameter ) { // handle exception } finally { // clean up code // regardless of there is an exception or not } In the example above, we have the try block: 1 2 3 4 5 6 try { reader = new FileReader ( filename ); scanner = new Scanner ( reader ); value = scanner . nextInt (); } : which opens the file and reads an integer from it. Thus the main task for the code is put together in one place, making it easier to read and understand (and thus less bug-prone). 1 2 3 4 5 6 7 8 : catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } catch ( InputMismatchException e ) { System . err . println ( \"Unable to scan for an integer\" ); } catch ( NoSuchElementException e ) { System . err . println ( \"No input found\" ); } The error handling comes under the catch clauses, each handling a different type of exception. In Java, exceptions are instances that are a subtype of the Exception class. Information about an exception is encapsulated in an exception instance and is \"passed\" into the catch block. In the example above, e is the variable containing an exception instance. With the exception, we no longer rely on a special return value from a function nor a global variable to indicate exceptions. 1 2 3 4 5 : finally { if ( scanner != null ) scanner . close (); } Finally, we have the optional finally clause for house-keeping tasks. Here, we close the scanner if it is opened. In cases where the code to handle the exceptions is the same, you can avoid repetition by combining multiple exceptions into one catch statement: 1 2 3 catch ( FileNotFoundException | InputMismatchException | NoSuchElementException e ) { System . err . println ( e ); } Throwing Exceptions The try - catch - finally blocks above show you how to handle exceptions. Let's see how we can throw an exception. Let's revisit our Circle class. A circle cannot have a negative radius. Let's say that we wish our constructor to throw an IllegalArgumentException when a negative radius is passed in. We need to do two things. First, we need to declare that the construct is throwing an exception, with the throws keyword. Second, we have to create a new IllegalArgumentException object and throw it to the caller with the throw keywords. 1 2 3 4 5 6 7 8 public Circle ( Point c , double r ) throws IllegalArgumentException { if ( r < 0 ) { throw new IllegalArgumentException ( \"radius cannot be negative.\" ); } this . c = c ; this . r = r ; } } Note that executing the throw statement causes the method to immediately return. In the example above, the initialization of the center c and radius r does not happen. The caller then can catch and handle this exception: 1 2 3 4 5 try { c = new Circle ( point , radius ); } catch ( IllegalArgumentException e ) { System . err . println ( \"Illegal arguement:\" + e . getMessage ()); } Checked vs Unchecked Exceptions Java distinguishes between two types of exceptions: checked and unchecked. An unchecked exception is an exception caused by a programmer's errors. They should not happen if perfect code is written. IllegalArgumentException , NullPointerException , ClassCastException are examples of unchecked exceptions. Generally, unchecked exceptions are not explicitly caught or thrown. They indicate that something is wrong with the program and cause run-time errors. A checked exception is an exception that a programmer has no control over. Even if the code written is perfect, such an exception might still happen. The programmer should thus actively anticipate the exception and handle them. For instance, when we open a file, we should anticipate that in some cases, the file cannot be opened. FileNotFoundException and InputMismatchException are two examples of checked exceptions. A checked exception must be either handled, or else the program will not compile. In Java, unchecked exceptions are subclasses of the class RuntimeException . Passing the Buck The caller of the method that generates (i.e., new and throws ) an exception need not catch the exception. The caller can pass the exception to its caller, and so on if the programmer deems that it is not the right place to handle it. An unchecked exception, if not caught, will propagate automatically down the stack until either, it is caught or if it is not caught at all, resulting in an error message displayed to the user. For instance, the following toy program would result in IllegalArgumentException being thrown out of main and displayed to the user. 1 2 3 4 5 6 7 8 9 10 11 class Toy { static Circle createCircles () { int radius = 10 ; for ( int i = 0 ; i <= 10 ; i ++ ) { new Circle ( new Point ( 1 , 1 ), radius -- ); } } public static void main ( String [] args ) { createCircles (); } } A checked exception, on the other hand, must be handled. Consider the following example: 1 2 3 4 5 6 7 8 9 // version 0.1 (won't compile) class Toy { static FileReader openFile ( String filename ) { return new FileReader ( filename ); } public static void main ( String [] args ) { openFile (); } } This program won't compile because the checked exception FileNotFoundException is not handled. As the example we have seen, we could handle it in openFile . In this case, openFile does not throw any exception. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.2 (handle where exception occur) class Toy { static FileReader openFile ( String filename ) { try { return new FileReader ( filename ); } catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } } public static void main ( String [] args ) { openFile (); } } Alternatively, openFile can pass the buck to the caller instead of catching it. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.3 (passing exception to caller) class Toy { static FileReader openFile ( String filename ) throws FileNotFoundException { return new FileReader ( filename ); } public static void main ( String [] args ) { try { openFile (); } catch ( FileNotFoundException e ) { // warn user and pop up dialog box to select another file. } } } Sometimes the caller is a better place to handle the exception. Where an exception should be handled is a design decision. We will see some considerations for this later in this unit. What should not happen is the following: 1 2 3 4 5 6 7 8 9 // version 0.4 (pass exception to user) class Toy { static FileReader openFile ( String filename ) throws FileNotFoundException { return new FileReader ( filename ); } public static void main ( String [] args ) throws FileNotFoundException { openFile (); } } In the code above, every method passes the buck around. No one takes the responsibility to handle it and the user ends up with the exception. The ugly internals of the program (such as the call stack) is then revealed to the user. A good program always handle checked exception gracefully and hide the details from the users. Control Flow of Exceptions Here is a more detailed description of the control flow of exceptions. Consider we have a try - catch - finally block that catches two exceptions E1 and E2 . Inside the try block, we call a method m1() ; m1() calls m2() ; m2() calls m3() , and m3() calls m4() . 1 2 3 4 5 6 7 8 9 try { m1 (); } catch ( E1 e ) { : } catch ( E2 e ) { : } finally { : } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void m1 () { : m2 (); : } void m2 () { : m3 (); : } void m3 () { : m4 (); : } void m4 () { : throw new E2 (); : } In a normal (no exception) situation, the control flow looks like this: The statements in the try block are executed, followed by the statements in the finally block. Now, let's suppose something went wrong deep inside the nested call, in m4() . One of the statement executes throw new E2(); , which causes the execution in m4() to stop. JVM now looks for the block of code that catches E2 , going down the call stack, until it can find a place where the exception is handled. In this example, we suppose that none of m1() - m4() handles (i.e., catch ) the exception. Thus, JVM then jumps to the code that handles E2 . Finally, JVM executes the finally block. Note that the finally block is always executed even when return or throw is called in a catch block. Creating Our Own Exceptions If you find that none of the exceptions provided by Java meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones. But, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class IllegalCircleException extends IllegalArgumentException { Point center ; IllegalCircleException ( String message ) { super ( message ); } IllegalCircleException ( Point c , String message ) { super ( message ); this . center = c ; } @Override public String toString () { return \"The circle centered at \" + this . center + \" cannot be created:\" + getMessage (); } } Overriding Method that Throws Exceptions When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method. This rule follows the Liskov Substitution Principle. The caller of the overridden method cannot expect any new checked exception beyond what has already been \"promised\" in the method specification. Good Practices for Exception Handling Catch Exceptions to Clean Up While it is convenient to just pass the buck and let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so. Consider the example earlier, where m1() , m2() , and m3() do not handle exception E2 . Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly. Also, suppose that m2() allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method. By not handling the exception, the code that deallocates these resources does not get called when an exception occurs. It is better for m2() to catch the exception, handle the resource deallocation in a finally block. If there is a need for the calling methods to be aware of the exception, m2() can always re-throw the exception: 1 2 3 4 5 6 7 8 9 10 11 12 public void m2 () throws E2 { try { // setup resources m3 (); } catch ( E2 e ) { throw e ; } finally { // clean up resources } } Do not catch-them-all! Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions. Since Java uses checked exceptions, it forces you to handle the exceptions, or else your code will not compile. One way to quickly get around this is to write: 1 2 3 4 5 6 try { // your code } catch ( Exception e ) { // do nothing } to stop the compiler from complaining. DO NOT DO THIS. Since Exception is the superclass of all exceptions, every exception that is thrown, checked or unchecked, is now silently ignored! You will not be able to figure out if something is wrong with your program. This practice is such a bad practice that there is a name for it -- this is called Pokemon Exception Handling . Overreacting Do not exit a program just because of an exception. This would prevent the calling function from cleaning up their resources. Worse, do not exit a program silently. 1 2 3 4 5 6 try { // your code } catch ( Exception e ) { System . exit ( 0 ); } Do Not Break Abstraction Barrier Sometimes, letting the calling method handle the exception causes the implementation details to be leaked, and make it harder to change the implementation later. For instance, suppose we design a class ClassRoster with a method getStudents() , which reads the list of students from a text file. 1 2 3 4 5 6 class ClassRoster { : public Students [] getStudents () throws FileNotFoundException { : } } Here, the fact that a FileNotFoundException is thrown leaks the information that the information is read from a file. Suppose that, later, we change the implementation to reading the list from an SQL database. We may have to change the exception thrown to something else: 1 2 3 4 5 6 class ClassRoster { : public Students [] getStudents () throws SQLException { : } } The caller will have to change their exception handling code accordingly. We should, as much as possible, handle the implementation-specific exceptions within the abstraction barrier. Do NOT Use Exception As a Control Flow Mechanism This is probably the most commonly seen mistakes among new programmers. Exceptions are meant to handle unexpected errors, not to handle the logic of your program. Consider the following snippet: 1 2 3 4 5 if ( obj != null ) { obj . doSomething (); } else { doTheOtherThing (); } We use an if condition to handle the logic. Some programmers wrote this: 1 2 3 4 5 try { obj . doSomething (); } catch ( NullPointerException e ) { doTheOtherThing (); } Not only is this less efficient, but it also might not be correct, since a NullPointerException might be triggered by something else other than obj being null. The Error class Java has another class called Error for situations where the program should terminate as generally there is no way to recover from the error. For instance, when the heap is full ( OutOfMemoryError ) or the stack is full ( StackOverflowError ). Typically we don't need to create or handle such errors.","title":"19. Exception"},{"location":"19-exception.html#unit-19-exceptions","text":"After this unit, students should: understand about handling java exceptions and how to use the try - catch - finally blocks understand the hierarchy of exception classes and the difference between checked and unchecked exceptions be able to create their own exceptions understand the control flow of exceptions be aware of good practices for exception handling One of the nuances of programming is having to write code to deal with exceptions and errors. Consider writing a method that reads in a single integer value from a file. Here are some things that could go wrong: The file to read from may not exist The file to read from exists, but you may not have permission to read it You can open the file for reading, but it might contain non-numeric text where you expect numerical values The file might contain fewer values than expected The file might become unreadable as you are reading through it (e.g., someone unplugs the USB drive) In C, we usually have to write code like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fd = fopen ( filename , \"r\" ); if ( fd == NULL ) { fprintf ( stderr , \"Unable to open file. \" ); if ( errno == ENFILE ) { fprintf ( stderr , \"Too many opened files. Unable to open another \\n \" ); } else if ( errno == ENOENT ) { fprintf ( stderr , \"No such file %s \\n \" , filename ); } else if ( errno == EACCES ) { fprintf ( stderr , \"No read permission to %s \\n \" , filename ); } return -1 ; } scanned = fscanf ( fd , \"%d\" , & value ); if ( scanned == 0 ) { fprintf ( stderr , \"Unable to scan for an integer \\n \" ); fclose ( fd ); return -2 ; } if ( scanned == EOF ) { fprintf ( stderr , \"No input found. \\n \" ); fclose ( fd ); return -3 ; } Out of the lines above, only TWO lines correspond to the actual task of opening and reading in a file, the others are for exception checking/handling. The actual tasks are interspersed between exception checking code, which makes reading and understanding the logic of the code difficult. The examples above also have to return different values to the calling method, because the calling method may have to do something to handle the errors. Note that the POSIX API has a global variable errno that signifies the detailed error. First, we have to check for different errno values and react accordingly (we can use perror , but that has its limits). Second, errno is global, and using a global variable is a bad practice. In fact, the code above might not work because fprintf in Line 3 might have changed errno . Finally, there is the issue of having to repeatedly clean up after an error -- here we fclose the file if there is an error reading, twice. It is easy to forget to do so if we have to do this in multiple places. Furthermore, if we need to perform a more complex clean up, then we would end up with lots of repeated code. Many modern programming languages support exceptions as a programming construct. In Java, this is done with try , catch , finally keywords, and a hierarchy of Exception classes. The try / catch / finally keywords group statements that check/handle errors together making code easier to read. The Java equivalent to the above is: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 try { reader = new FileReader ( filename ); scanner = new Scanner ( reader ); value = scanner . nextInt (); } catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } catch ( InputMismatchException e ) { System . err . println ( \"Unable to scan for an integer\" ); } catch ( NoSuchElementException e ) { System . err . println ( \"No input found\" ); } finally { if ( scanner != null ) scanner . close (); } Let's look at the example more carefully. The general syntax for try - catch - finally is the following: 1 2 3 4 5 6 7 8 try { // do something } catch ( an exception parameter ) { // handle exception } finally { // clean up code // regardless of there is an exception or not } In the example above, we have the try block: 1 2 3 4 5 6 try { reader = new FileReader ( filename ); scanner = new Scanner ( reader ); value = scanner . nextInt (); } : which opens the file and reads an integer from it. Thus the main task for the code is put together in one place, making it easier to read and understand (and thus less bug-prone). 1 2 3 4 5 6 7 8 : catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } catch ( InputMismatchException e ) { System . err . println ( \"Unable to scan for an integer\" ); } catch ( NoSuchElementException e ) { System . err . println ( \"No input found\" ); } The error handling comes under the catch clauses, each handling a different type of exception. In Java, exceptions are instances that are a subtype of the Exception class. Information about an exception is encapsulated in an exception instance and is \"passed\" into the catch block. In the example above, e is the variable containing an exception instance. With the exception, we no longer rely on a special return value from a function nor a global variable to indicate exceptions. 1 2 3 4 5 : finally { if ( scanner != null ) scanner . close (); } Finally, we have the optional finally clause for house-keeping tasks. Here, we close the scanner if it is opened. In cases where the code to handle the exceptions is the same, you can avoid repetition by combining multiple exceptions into one catch statement: 1 2 3 catch ( FileNotFoundException | InputMismatchException | NoSuchElementException e ) { System . err . println ( e ); }","title":"Unit 19: Exceptions"},{"location":"19-exception.html#throwing-exceptions","text":"The try - catch - finally blocks above show you how to handle exceptions. Let's see how we can throw an exception. Let's revisit our Circle class. A circle cannot have a negative radius. Let's say that we wish our constructor to throw an IllegalArgumentException when a negative radius is passed in. We need to do two things. First, we need to declare that the construct is throwing an exception, with the throws keyword. Second, we have to create a new IllegalArgumentException object and throw it to the caller with the throw keywords. 1 2 3 4 5 6 7 8 public Circle ( Point c , double r ) throws IllegalArgumentException { if ( r < 0 ) { throw new IllegalArgumentException ( \"radius cannot be negative.\" ); } this . c = c ; this . r = r ; } } Note that executing the throw statement causes the method to immediately return. In the example above, the initialization of the center c and radius r does not happen. The caller then can catch and handle this exception: 1 2 3 4 5 try { c = new Circle ( point , radius ); } catch ( IllegalArgumentException e ) { System . err . println ( \"Illegal arguement:\" + e . getMessage ()); }","title":"Throwing Exceptions"},{"location":"19-exception.html#checked-vs-unchecked-exceptions","text":"Java distinguishes between two types of exceptions: checked and unchecked. An unchecked exception is an exception caused by a programmer's errors. They should not happen if perfect code is written. IllegalArgumentException , NullPointerException , ClassCastException are examples of unchecked exceptions. Generally, unchecked exceptions are not explicitly caught or thrown. They indicate that something is wrong with the program and cause run-time errors. A checked exception is an exception that a programmer has no control over. Even if the code written is perfect, such an exception might still happen. The programmer should thus actively anticipate the exception and handle them. For instance, when we open a file, we should anticipate that in some cases, the file cannot be opened. FileNotFoundException and InputMismatchException are two examples of checked exceptions. A checked exception must be either handled, or else the program will not compile. In Java, unchecked exceptions are subclasses of the class RuntimeException .","title":"Checked vs Unchecked Exceptions"},{"location":"19-exception.html#passing-the-buck","text":"The caller of the method that generates (i.e., new and throws ) an exception need not catch the exception. The caller can pass the exception to its caller, and so on if the programmer deems that it is not the right place to handle it. An unchecked exception, if not caught, will propagate automatically down the stack until either, it is caught or if it is not caught at all, resulting in an error message displayed to the user. For instance, the following toy program would result in IllegalArgumentException being thrown out of main and displayed to the user. 1 2 3 4 5 6 7 8 9 10 11 class Toy { static Circle createCircles () { int radius = 10 ; for ( int i = 0 ; i <= 10 ; i ++ ) { new Circle ( new Point ( 1 , 1 ), radius -- ); } } public static void main ( String [] args ) { createCircles (); } } A checked exception, on the other hand, must be handled. Consider the following example: 1 2 3 4 5 6 7 8 9 // version 0.1 (won't compile) class Toy { static FileReader openFile ( String filename ) { return new FileReader ( filename ); } public static void main ( String [] args ) { openFile (); } } This program won't compile because the checked exception FileNotFoundException is not handled. As the example we have seen, we could handle it in openFile . In this case, openFile does not throw any exception. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.2 (handle where exception occur) class Toy { static FileReader openFile ( String filename ) { try { return new FileReader ( filename ); } catch ( FileNotFoundException e ) { System . err . println ( \"Unable to open \" + filename + \" \" + e ); } } public static void main ( String [] args ) { openFile (); } } Alternatively, openFile can pass the buck to the caller instead of catching it. 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.3 (passing exception to caller) class Toy { static FileReader openFile ( String filename ) throws FileNotFoundException { return new FileReader ( filename ); } public static void main ( String [] args ) { try { openFile (); } catch ( FileNotFoundException e ) { // warn user and pop up dialog box to select another file. } } } Sometimes the caller is a better place to handle the exception. Where an exception should be handled is a design decision. We will see some considerations for this later in this unit. What should not happen is the following: 1 2 3 4 5 6 7 8 9 // version 0.4 (pass exception to user) class Toy { static FileReader openFile ( String filename ) throws FileNotFoundException { return new FileReader ( filename ); } public static void main ( String [] args ) throws FileNotFoundException { openFile (); } } In the code above, every method passes the buck around. No one takes the responsibility to handle it and the user ends up with the exception. The ugly internals of the program (such as the call stack) is then revealed to the user. A good program always handle checked exception gracefully and hide the details from the users.","title":"Passing the Buck"},{"location":"19-exception.html#control-flow-of-exceptions","text":"Here is a more detailed description of the control flow of exceptions. Consider we have a try - catch - finally block that catches two exceptions E1 and E2 . Inside the try block, we call a method m1() ; m1() calls m2() ; m2() calls m3() , and m3() calls m4() . 1 2 3 4 5 6 7 8 9 try { m1 (); } catch ( E1 e ) { : } catch ( E2 e ) { : } finally { : } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void m1 () { : m2 (); : } void m2 () { : m3 (); : } void m3 () { : m4 (); : } void m4 () { : throw new E2 (); : } In a normal (no exception) situation, the control flow looks like this: The statements in the try block are executed, followed by the statements in the finally block. Now, let's suppose something went wrong deep inside the nested call, in m4() . One of the statement executes throw new E2(); , which causes the execution in m4() to stop. JVM now looks for the block of code that catches E2 , going down the call stack, until it can find a place where the exception is handled. In this example, we suppose that none of m1() - m4() handles (i.e., catch ) the exception. Thus, JVM then jumps to the code that handles E2 . Finally, JVM executes the finally block. Note that the finally block is always executed even when return or throw is called in a catch block.","title":"Control Flow of Exceptions"},{"location":"19-exception.html#creating-our-own-exceptions","text":"If you find that none of the exceptions provided by Java meet your needs, you can create your own exceptions, by simply inheriting from one of the existing ones. But, you should only do so if there is a good reason, for instance, to provide additional useful information to the exception handler. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class IllegalCircleException extends IllegalArgumentException { Point center ; IllegalCircleException ( String message ) { super ( message ); } IllegalCircleException ( Point c , String message ) { super ( message ); this . center = c ; } @Override public String toString () { return \"The circle centered at \" + this . center + \" cannot be created:\" + getMessage (); } }","title":"Creating Our Own Exceptions"},{"location":"19-exception.html#overriding-method-that-throws-exceptions","text":"When you override a method that throws a checked exception, the overriding method must throw only the same, or a more specific checked exception, than the overridden method. This rule follows the Liskov Substitution Principle. The caller of the overridden method cannot expect any new checked exception beyond what has already been \"promised\" in the method specification.","title":"Overriding Method that Throws Exceptions"},{"location":"19-exception.html#good-practices-for-exception-handling","text":"","title":"Good Practices for Exception Handling"},{"location":"19-exception.html#catch-exceptions-to-clean-up","text":"While it is convenient to just pass the buck and let the calling method deals with exceptions (\"Hey! Not my problem!\"), it is not always responsible to do so. Consider the example earlier, where m1() , m2() , and m3() do not handle exception E2 . Let's say that E2 is a checked exception, and it is possible to react to this and let the program continues properly. Also, suppose that m2() allocated some system resources (e.g., temporary files, network connections) at the beginning of the method, and deallocated the resources at the end of the method. By not handling the exception, the code that deallocates these resources does not get called when an exception occurs. It is better for m2() to catch the exception, handle the resource deallocation in a finally block. If there is a need for the calling methods to be aware of the exception, m2() can always re-throw the exception: 1 2 3 4 5 6 7 8 9 10 11 12 public void m2 () throws E2 { try { // setup resources m3 (); } catch ( E2 e ) { throw e ; } finally { // clean up resources } }","title":"Catch Exceptions to Clean Up"},{"location":"19-exception.html#do-not-catch-them-all","text":"Sometimes, you just want to focus on the main logic of the program and get it working instead of dealing with the exceptions. Since Java uses checked exceptions, it forces you to handle the exceptions, or else your code will not compile. One way to quickly get around this is to write: 1 2 3 4 5 6 try { // your code } catch ( Exception e ) { // do nothing } to stop the compiler from complaining. DO NOT DO THIS. Since Exception is the superclass of all exceptions, every exception that is thrown, checked or unchecked, is now silently ignored! You will not be able to figure out if something is wrong with your program. This practice is such a bad practice that there is a name for it -- this is called Pokemon Exception Handling .","title":"Do not catch-them-all!"},{"location":"19-exception.html#overreacting","text":"Do not exit a program just because of an exception. This would prevent the calling function from cleaning up their resources. Worse, do not exit a program silently. 1 2 3 4 5 6 try { // your code } catch ( Exception e ) { System . exit ( 0 ); }","title":"Overreacting"},{"location":"19-exception.html#do-not-break-abstraction-barrier","text":"Sometimes, letting the calling method handle the exception causes the implementation details to be leaked, and make it harder to change the implementation later. For instance, suppose we design a class ClassRoster with a method getStudents() , which reads the list of students from a text file. 1 2 3 4 5 6 class ClassRoster { : public Students [] getStudents () throws FileNotFoundException { : } } Here, the fact that a FileNotFoundException is thrown leaks the information that the information is read from a file. Suppose that, later, we change the implementation to reading the list from an SQL database. We may have to change the exception thrown to something else: 1 2 3 4 5 6 class ClassRoster { : public Students [] getStudents () throws SQLException { : } } The caller will have to change their exception handling code accordingly. We should, as much as possible, handle the implementation-specific exceptions within the abstraction barrier.","title":"Do Not Break Abstraction Barrier"},{"location":"19-exception.html#do-not-use-exception-as-a-control-flow-mechanism","text":"This is probably the most commonly seen mistakes among new programmers. Exceptions are meant to handle unexpected errors, not to handle the logic of your program. Consider the following snippet: 1 2 3 4 5 if ( obj != null ) { obj . doSomething (); } else { doTheOtherThing (); } We use an if condition to handle the logic. Some programmers wrote this: 1 2 3 4 5 try { obj . doSomething (); } catch ( NullPointerException e ) { doTheOtherThing (); } Not only is this less efficient, but it also might not be correct, since a NullPointerException might be triggered by something else other than obj being null.","title":"Do NOT Use Exception As a Control Flow Mechanism"},{"location":"19-exception.html#the-error-class","text":"Java has another class called Error for situations where the program should terminate as generally there is no way to recover from the error. For instance, when the heap is full ( OutOfMemoryError ) or the stack is full ( StackOverflowError ). Typically we don't need to create or handle such errors.","title":"The Error class"},{"location":"20-generics.html","text":"Unit 20: Generics After taking this unit, students should: know how to define and instantiate a generic type and a generic method be familiar with the term parameterized types, type arguments, type parameters appreciate how generics can reduce duplication of code and improve type safety The Pair class Sometimes it is useful to have a lightweight class to bundle a pair of variables together. One could, for instance, write a method that returns two values. The example defines a class IntPair that bundles two int variables together. This is a utility class with no semantics nor methods associated with it and so, we did not attempt to hide the implementation details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class IntPair { private int first ; private int second ; public IntPair ( int first , int second ) { this . first = first ; this . second = second ; } int getFirst () { return this . first ; } int getSecond () { return this . second ; } } This class can be used, for instance, in a function that returns two int values. 1 2 3 4 5 6 7 8 9 10 11 12 13 IntPair findMinMax ( int [] array ) { int min = Integer . MAX_VALUE ; // stores the min int max = Integer . MIN . VALUE ; // stores the max for ( int i : array ) { if ( i < min ) { min = i ; } if ( i > max ) { max = i ; } } return new IntPair ( min , max ); } We could similarly define a pair class for two doubles ( DoublePair ), two booleans ( BooleanPair ), etc. In other situations, it is useful to define a pair class that bundles two variables of two different types, say, a Customer and a ServiceCounter ; a String and an int ; etc. We should not, however, create one class for each possible combination of types. A better idea is to define a class that stores two Object references: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair { private Object first ; private Object second ; public Pair ( Object first , Object second ) { this . first = first ; this . second = second ; } Object getFirst () { return this . first ; } Object getSecond () { return this . second ; } } At the cost of using a wrapper class in place of primitive types, we get a single class that can be used to store any type of values. You might recall that we used a similar approach for our contains method to implement a general method that works for any type of object. Here, we are using this approach for a general class that encapsulates any type of object. Unfortunately, the issues we faced with narrowing type conversion and potential run-time errors apply to the Pair class as well. Suppose that a function returns a Pair containing a String and an Integer , and we accidentally treat this as an Integer and a String instead, the compiler will not be able to detect the type mismatch and stop the program from crashing during run-time. 1 2 3 4 5 6 Pair foo () { return new Pair ( \"hello\" , 4 ); } Pair p = foo (); Integer i = ( Integer ) p . getFirst (); // run-time ClassCastException To reduce the risk of human error, what we need is a way to specify the following: suppose the type of first is \\(S\\) and type of second is \\(T\\) , then we want the return type of getFirst to be \\(S\\) and of getSecond to be \\(T\\) . Generic Types In Java and many other programming languages, the mechanism to do this is called generics or templates. Java allows us to define a generic type that takes other types as type parameters , just like how we can write methods that take in variables as parameters. Declaring a Generic Type Let's see how we can do this for Pair : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair < S , T > { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } } We declare a generic type by specifying its type parameters between < and > when we declare the type. By convention, we use a single capital letter to name each type parameter. These type parameters are scoped within the definition of the type. In the example above, we have a generic class Pair<S,T> (read \"pair of S and T\") with S and T as type parameters. We use S and T as the type of the fields first and second . We ensure that getFirst() returns type S and getSecond() returns type T , so that the compiler will give an error if we mix up the types. Note that the constructor is still declared as Pair (without the type parameters). Using/Instanting a Generic Type To use a generic type, we have to pass in type arguments , which itself can be a non-generic type, a generic type, or another type parameter that has been declared. Once a generic type is instantiated, it is called a parameterized type . To avoid potential human errors leading to ClassCastException in the example above, we can use the generic version of Pair as follows, taking in two non-generic types: 1 2 3 4 5 6 Pair < String , Integer > foo () { return new Pair < String , Integer > ( \"hello\" , 4 ); } Pair < String , Integer > p = foo (); Integer i = ( Integer ) p . getFirst (); // compile-time error With the parameterized type Pair<String,Integer> , the return type of getFirst is bound to String , and the compiler now have enough type information to check and give us an error since we try to cast a String to an Integer . Note that we use Integer instead of int , since only reference types can be used as type arguments. Just like you can pass a parameter of a method to another method, we can pass the type parameter of a generic type to another: 1 2 3 class DictEntry < T > extends Pair < String , T > { : } We define a generic class called DictEntry<T> with a single type parameter T that extends from Pair<String,T> , where String is the first type argument (in place of S ), while the type parameter T from DictEntry<T> is passed as the type argument for T of Pair<String,T> . Generic Methods Methods can be parameterized with a type parameter as well. Consider the contains method, which we now put within a class for clarity. 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.1 (with polymorphism) public static boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } While using this method does not involve narrowing type conversion and type casting, it is a little to general -- it allows us to call contains in a nonsensical way, like this: 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . contains ( strArray , 123 ); Searching for an integer within an array of strings is a futile attempt! Let's constrain the type of the object to search for to be the same as the type of the array. We can make this type the parameter to this method: 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.4 (with generics) public static < T > boolean contains ( T [] array , T obj ) { for ( T curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } The above shows an example of a generic method . The type parameter T is declared within < and > and is added before the return type of the method. This parameter T is then scoped within the whole method. To call a generic method, we need to pass in the type argument placed before the name of the method 1 . For instance, 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . < String > contains ( strArray , 123 ); // type mismatch error The code above won't compile since the compiler expects the second argument to also be a String . Bounded Type Parameters Let's now try to apply our newly acquired trick to fix the issue with findLargest . Recall that we have the following findLargest method (which we now put into an ad hoc class just for clarity), which requires us to perform a narrowing type conversion to cast from GetAreable and possibly leading to a run-time error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.4 public static GetAreable findLargest ( GetAreable [] array ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } Let's try to make this method generic, by forcing the return type to be the same as the type of the elements in the input array, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.4 public static < T > T findLargest ( T [] array ) { double maxArea = 0 ; T maxObj = null ; for ( T curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } The code above won't compile, since the compiler cannot be sure that it can find the method getArea() in type T . In contrast, when we run contains , we had no issue since we are invoking the method equals , which exists in any reference type in Java. Since we intend to use findLargest only in classes that implement the GetAreable interface and supports the getArea() method, we can put a constraint on T . We can say that T must be a subtype of GetAreable when we specify the type parameter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.5 public static < T extends GetAreable > T findLargest ( T [] array ) { double maxArea = 0 ; T maxObj = null ; for ( T curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } We use the keyword extends here to indicate that T must be a subtype of GetAreable . It is unfortunate that Java decides to use the term extends for any type of subtyping when declaring a bounded type parameter, even if the supertype (such as GetAreable ) is an interface. We can use bounded type parameters for declaring generic classes as well. For instance, Java has a generic interface Comparable<T> , which dictates the implementation of the following int compareTo(T t) for any concrete class that implements the interface. Any class that implements the Comparable<T> interface can be compared with an instance of type T to establish an ordering. Such ordering can be useful for sorting objects, for instance. Suppose we want to compare two Pair instances, by comparing the first element in the pair, we could do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Pair < S extends Comparable < S > , T > implements Comparable < Pair < S , T >> { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } @Override public int compareTo ( Pair < S , T > s1 ) { return this . first . compareTo ( s1 . first ); } @Override public String toString () { return this . first + \" \" + this . second ; } } Let's look at what it means: We declared Pair to be a generic type of two type parameters: the first one S is bounded and must be a subtype of Comparable<S> . This bound is self-referential, but it is intuitive -- we say that S must be comparable to itself, which is common in many use cases. Since we want to compare two Pair instances, we make Pair implements the Comparable interface too, passing in Pair<S,T> as the type argument to Comparable . Let's see this in action with Arrays::sort method, which sorts an array based on the ordering defined by compareTo . 1 2 3 4 5 6 7 8 9 10 11 12 Object [] array = new Object [] { new Pair < String , Integer > ( \"Alice\" , 1 ), new Pair < String , Integer > ( \"Carol\" , 2 ), new Pair < String , Integer > ( \"Bob\" , 3 ), new Pair < String , Integer > ( \"Dave\" , 4 ), }; java . util . Arrays . sort ( array ); for ( Object o : array ) { System . out . println ( o ); } You will see the pairs are sorted by the first element. Java actually can infer the type using the type inference mechanism and allows us to skip the type argument, but for clarity, we insist on specifying the type explicitly until students get used to the generic types and reasoning about types. \u21a9","title":"20. Generics"},{"location":"20-generics.html#unit-20-generics","text":"After taking this unit, students should: know how to define and instantiate a generic type and a generic method be familiar with the term parameterized types, type arguments, type parameters appreciate how generics can reduce duplication of code and improve type safety","title":"Unit 20: Generics"},{"location":"20-generics.html#the-pair-class","text":"Sometimes it is useful to have a lightweight class to bundle a pair of variables together. One could, for instance, write a method that returns two values. The example defines a class IntPair that bundles two int variables together. This is a utility class with no semantics nor methods associated with it and so, we did not attempt to hide the implementation details. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class IntPair { private int first ; private int second ; public IntPair ( int first , int second ) { this . first = first ; this . second = second ; } int getFirst () { return this . first ; } int getSecond () { return this . second ; } } This class can be used, for instance, in a function that returns two int values. 1 2 3 4 5 6 7 8 9 10 11 12 13 IntPair findMinMax ( int [] array ) { int min = Integer . MAX_VALUE ; // stores the min int max = Integer . MIN . VALUE ; // stores the max for ( int i : array ) { if ( i < min ) { min = i ; } if ( i > max ) { max = i ; } } return new IntPair ( min , max ); } We could similarly define a pair class for two doubles ( DoublePair ), two booleans ( BooleanPair ), etc. In other situations, it is useful to define a pair class that bundles two variables of two different types, say, a Customer and a ServiceCounter ; a String and an int ; etc. We should not, however, create one class for each possible combination of types. A better idea is to define a class that stores two Object references: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair { private Object first ; private Object second ; public Pair ( Object first , Object second ) { this . first = first ; this . second = second ; } Object getFirst () { return this . first ; } Object getSecond () { return this . second ; } } At the cost of using a wrapper class in place of primitive types, we get a single class that can be used to store any type of values. You might recall that we used a similar approach for our contains method to implement a general method that works for any type of object. Here, we are using this approach for a general class that encapsulates any type of object. Unfortunately, the issues we faced with narrowing type conversion and potential run-time errors apply to the Pair class as well. Suppose that a function returns a Pair containing a String and an Integer , and we accidentally treat this as an Integer and a String instead, the compiler will not be able to detect the type mismatch and stop the program from crashing during run-time. 1 2 3 4 5 6 Pair foo () { return new Pair ( \"hello\" , 4 ); } Pair p = foo (); Integer i = ( Integer ) p . getFirst (); // run-time ClassCastException To reduce the risk of human error, what we need is a way to specify the following: suppose the type of first is \\(S\\) and type of second is \\(T\\) , then we want the return type of getFirst to be \\(S\\) and of getSecond to be \\(T\\) .","title":"The Pair class"},{"location":"20-generics.html#generic-types","text":"In Java and many other programming languages, the mechanism to do this is called generics or templates. Java allows us to define a generic type that takes other types as type parameters , just like how we can write methods that take in variables as parameters.","title":"Generic Types"},{"location":"20-generics.html#declaring-a-generic-type","text":"Let's see how we can do this for Pair : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair < S , T > { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } } We declare a generic type by specifying its type parameters between < and > when we declare the type. By convention, we use a single capital letter to name each type parameter. These type parameters are scoped within the definition of the type. In the example above, we have a generic class Pair<S,T> (read \"pair of S and T\") with S and T as type parameters. We use S and T as the type of the fields first and second . We ensure that getFirst() returns type S and getSecond() returns type T , so that the compiler will give an error if we mix up the types. Note that the constructor is still declared as Pair (without the type parameters).","title":"Declaring a Generic Type"},{"location":"20-generics.html#usinginstanting-a-generic-type","text":"To use a generic type, we have to pass in type arguments , which itself can be a non-generic type, a generic type, or another type parameter that has been declared. Once a generic type is instantiated, it is called a parameterized type . To avoid potential human errors leading to ClassCastException in the example above, we can use the generic version of Pair as follows, taking in two non-generic types: 1 2 3 4 5 6 Pair < String , Integer > foo () { return new Pair < String , Integer > ( \"hello\" , 4 ); } Pair < String , Integer > p = foo (); Integer i = ( Integer ) p . getFirst (); // compile-time error With the parameterized type Pair<String,Integer> , the return type of getFirst is bound to String , and the compiler now have enough type information to check and give us an error since we try to cast a String to an Integer . Note that we use Integer instead of int , since only reference types can be used as type arguments. Just like you can pass a parameter of a method to another method, we can pass the type parameter of a generic type to another: 1 2 3 class DictEntry < T > extends Pair < String , T > { : } We define a generic class called DictEntry<T> with a single type parameter T that extends from Pair<String,T> , where String is the first type argument (in place of S ), while the type parameter T from DictEntry<T> is passed as the type argument for T of Pair<String,T> .","title":"Using/Instanting a Generic Type"},{"location":"20-generics.html#generic-methods","text":"Methods can be parameterized with a type parameter as well. Consider the contains method, which we now put within a class for clarity. 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.1 (with polymorphism) public static boolean contains ( Object [] array , Object obj ) { for ( Object curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } While using this method does not involve narrowing type conversion and type casting, it is a little to general -- it allows us to call contains in a nonsensical way, like this: 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . contains ( strArray , 123 ); Searching for an integer within an array of strings is a futile attempt! Let's constrain the type of the object to search for to be the same as the type of the array. We can make this type the parameter to this method: 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.4 (with generics) public static < T > boolean contains ( T [] array , T obj ) { for ( T curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } The above shows an example of a generic method . The type parameter T is declared within < and > and is added before the return type of the method. This parameter T is then scoped within the whole method. To call a generic method, we need to pass in the type argument placed before the name of the method 1 . For instance, 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . < String > contains ( strArray , 123 ); // type mismatch error The code above won't compile since the compiler expects the second argument to also be a String .","title":"Generic Methods"},{"location":"20-generics.html#bounded-type-parameters","text":"Let's now try to apply our newly acquired trick to fix the issue with findLargest . Recall that we have the following findLargest method (which we now put into an ad hoc class just for clarity), which requires us to perform a narrowing type conversion to cast from GetAreable and possibly leading to a run-time error. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.4 public static GetAreable findLargest ( GetAreable [] array ) { double maxArea = 0 ; GetAreable maxObj = null ; for ( GetAreable curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } Let's try to make this method generic, by forcing the return type to be the same as the type of the elements in the input array, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.4 public static < T > T findLargest ( T [] array ) { double maxArea = 0 ; T maxObj = null ; for ( T curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } The code above won't compile, since the compiler cannot be sure that it can find the method getArea() in type T . In contrast, when we run contains , we had no issue since we are invoking the method equals , which exists in any reference type in Java. Since we intend to use findLargest only in classes that implement the GetAreable interface and supports the getArea() method, we can put a constraint on T . We can say that T must be a subtype of GetAreable when we specify the type parameter: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { // version 0.5 public static < T extends GetAreable > T findLargest ( T [] array ) { double maxArea = 0 ; T maxObj = null ; for ( T curr : array ) { double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } } We use the keyword extends here to indicate that T must be a subtype of GetAreable . It is unfortunate that Java decides to use the term extends for any type of subtyping when declaring a bounded type parameter, even if the supertype (such as GetAreable ) is an interface. We can use bounded type parameters for declaring generic classes as well. For instance, Java has a generic interface Comparable<T> , which dictates the implementation of the following int compareTo(T t) for any concrete class that implements the interface. Any class that implements the Comparable<T> interface can be compared with an instance of type T to establish an ordering. Such ordering can be useful for sorting objects, for instance. Suppose we want to compare two Pair instances, by comparing the first element in the pair, we could do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Pair < S extends Comparable < S > , T > implements Comparable < Pair < S , T >> { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } @Override public int compareTo ( Pair < S , T > s1 ) { return this . first . compareTo ( s1 . first ); } @Override public String toString () { return this . first + \" \" + this . second ; } } Let's look at what it means: We declared Pair to be a generic type of two type parameters: the first one S is bounded and must be a subtype of Comparable<S> . This bound is self-referential, but it is intuitive -- we say that S must be comparable to itself, which is common in many use cases. Since we want to compare two Pair instances, we make Pair implements the Comparable interface too, passing in Pair<S,T> as the type argument to Comparable . Let's see this in action with Arrays::sort method, which sorts an array based on the ordering defined by compareTo . 1 2 3 4 5 6 7 8 9 10 11 12 Object [] array = new Object [] { new Pair < String , Integer > ( \"Alice\" , 1 ), new Pair < String , Integer > ( \"Carol\" , 2 ), new Pair < String , Integer > ( \"Bob\" , 3 ), new Pair < String , Integer > ( \"Dave\" , 4 ), }; java . util . Arrays . sort ( array ); for ( Object o : array ) { System . out . println ( o ); } You will see the pairs are sorted by the first element. Java actually can infer the type using the type inference mechanism and allows us to skip the type argument, but for clarity, we insist on specifying the type explicitly until students get used to the generic types and reasoning about types. \u21a9","title":"Bounded Type Parameters"},{"location":"21-erasure.html","text":"Unit 21: Type Erasure After taking this unit, students are expected to: understand that generics are implemented with type erasure in Java understand that type information is not fully available during run-time when generics are used, and problems that this could cause be aware that arrays and generics don't mix well in Java know the terms reifiable type and heap pollution. Implementing Generics There are several ways one could implement generics in a programming language. For instance, in C#, every instantiation of a generic type causes new code to be generated for that instantiated type. For instance, instantiating Pair<S,T> into Pair<String,Integer> causes a new type to be generated during run-time. In C++ and in Rust, instantiating Pair<String,Integer> causes new code to be generated during compile-time. This approach is sometimes called code specialization . Java takes a code sharing approach, instead of creating a new type for every instantiation, it chooses to erase the type parameters and type arguments during compilation (after type checking, of course). Thus, there is only one representation of the generic type in the generated code, representing all the instantiated generic types, regardless of the type arguments. Part of the reason to do this is for compatibility with the older version of Java. Java introduces generics only from version 5 onwards. Prior to version 5, one has to use Object to implement classes that are general enough to works on multiple types, similar to what we did with Pair here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair { private Object first ; private Object second ; public Pair ( Object first , Object second ) { this . first = first ; this . second = second ; } Object getFirst () { return this . first ; } Object getSecond () { return this . second ; } } The Java type erasure process transforms: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair < S , T > { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } } to the version above. Note that each type parameter S and T are replaced with Object . If the type parameter is bounded, it is replaced by the bounds instead (e.g., If T extends GetAreable , then T is replaced with GetAreable ). Where a generic type is instantiated and used, the code 1 Integer i = new Pair < String , Integer > ( \"hello\" , 4 ). getSecond (); is transformed into 1 Integer i = ( Integer ) new Pair ( \"hello\" , 4 ). getSecond (); The generated code is similar to what we would write earlier, but this is generated by the compiler after type checking, it ensures that the casting will not lead to ClassCastException during run-time. Type erasures have several important implications. We will explore some of them below, and a few others during recitation. Generics and Arrays Can't Mix Let's consider the hypothetical code below: 1 2 3 4 5 6 7 8 // create a new array of pairs Pair < String , Integer >[] pairArray = new Pair < String , Integer >[ 2 ] ; // pass around the array of pairs as an array of object Object [] objArray = pairArray ; // put a pair into the array -- no ArrayStoreException! objArray [ 0 ] = new Pair < Double , Boolean > ( 3.14 , true ); This is similar to what we have in Unit 18 , where we showed we could get an ArrayStoreException due to Java arrays being covariant. We would not, however, get an exception when we try to put a pair of double and boolean, into an array meant to store a pair of string and integer! This type checking is done during run-time, and due to type erasure, the run-time has no information about what is the type arguments to Pair . The run-time sees: 1 2 3 4 5 6 7 8 // create a new array of pairs Pair [] pairArray = new Pair [ 2 ] ; // pass around the array of pairs as an array of object Object [] objArray = pairArray ; // put a pair into the array -- no ArrayStoreException! objArray [ 0 ] = new Pair ( 3.14 , true ); It checks that we have an array of pairs and we are putting another pair inside. Everything checks out. This would have caused a heap pollution , a term that refers to the situation where a variable of a parameterized type refers to an object that is not of that parameterized type. Heap pollution is dangerous, as now, we will get a ClassCastException when we do: 1 2 // getting back a string? -- now we get ClassCastException String str = pairArray [ 0 ] . getFirst (); The example above shows why generics and arrays don't mix well together. An array is what is called reifiable type -- a type where full type information is available during run-time. It is because Java array is reifiable that the Java run-time can check what we store into the array matches the type of the array and throw an ArrayStoreException at us if there is a mismatch. Java generics, however, is not reifiable due to type erasure. Java designers have decided not to mix the two. The hypothetical code above actually is not a valid Java syntax. We can't compile this line: 1 Pair < String , Integer >[] pairArray = new Pair < String , Integer >[ 2 ] ; The following is illegal as well: 1 2 new Pair < S , T >[ 2 ] ; new T [ 2 ] ;","title":"21. Type Erasure"},{"location":"21-erasure.html#unit-21-type-erasure","text":"After taking this unit, students are expected to: understand that generics are implemented with type erasure in Java understand that type information is not fully available during run-time when generics are used, and problems that this could cause be aware that arrays and generics don't mix well in Java know the terms reifiable type and heap pollution.","title":"Unit 21: Type Erasure"},{"location":"21-erasure.html#implementing-generics","text":"There are several ways one could implement generics in a programming language. For instance, in C#, every instantiation of a generic type causes new code to be generated for that instantiated type. For instance, instantiating Pair<S,T> into Pair<String,Integer> causes a new type to be generated during run-time. In C++ and in Rust, instantiating Pair<String,Integer> causes new code to be generated during compile-time. This approach is sometimes called code specialization . Java takes a code sharing approach, instead of creating a new type for every instantiation, it chooses to erase the type parameters and type arguments during compilation (after type checking, of course). Thus, there is only one representation of the generic type in the generated code, representing all the instantiated generic types, regardless of the type arguments. Part of the reason to do this is for compatibility with the older version of Java. Java introduces generics only from version 5 onwards. Prior to version 5, one has to use Object to implement classes that are general enough to works on multiple types, similar to what we did with Pair here: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair { private Object first ; private Object second ; public Pair ( Object first , Object second ) { this . first = first ; this . second = second ; } Object getFirst () { return this . first ; } Object getSecond () { return this . second ; } } The Java type erasure process transforms: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Pair < S , T > { private S first ; private T second ; public Pair ( S first , T second ) { this . first = first ; this . second = second ; } S getFirst () { return this . first ; } T getSecond () { return this . second ; } } to the version above. Note that each type parameter S and T are replaced with Object . If the type parameter is bounded, it is replaced by the bounds instead (e.g., If T extends GetAreable , then T is replaced with GetAreable ). Where a generic type is instantiated and used, the code 1 Integer i = new Pair < String , Integer > ( \"hello\" , 4 ). getSecond (); is transformed into 1 Integer i = ( Integer ) new Pair ( \"hello\" , 4 ). getSecond (); The generated code is similar to what we would write earlier, but this is generated by the compiler after type checking, it ensures that the casting will not lead to ClassCastException during run-time. Type erasures have several important implications. We will explore some of them below, and a few others during recitation.","title":"Implementing Generics"},{"location":"21-erasure.html#generics-and-arrays-cant-mix","text":"Let's consider the hypothetical code below: 1 2 3 4 5 6 7 8 // create a new array of pairs Pair < String , Integer >[] pairArray = new Pair < String , Integer >[ 2 ] ; // pass around the array of pairs as an array of object Object [] objArray = pairArray ; // put a pair into the array -- no ArrayStoreException! objArray [ 0 ] = new Pair < Double , Boolean > ( 3.14 , true ); This is similar to what we have in Unit 18 , where we showed we could get an ArrayStoreException due to Java arrays being covariant. We would not, however, get an exception when we try to put a pair of double and boolean, into an array meant to store a pair of string and integer! This type checking is done during run-time, and due to type erasure, the run-time has no information about what is the type arguments to Pair . The run-time sees: 1 2 3 4 5 6 7 8 // create a new array of pairs Pair [] pairArray = new Pair [ 2 ] ; // pass around the array of pairs as an array of object Object [] objArray = pairArray ; // put a pair into the array -- no ArrayStoreException! objArray [ 0 ] = new Pair ( 3.14 , true ); It checks that we have an array of pairs and we are putting another pair inside. Everything checks out. This would have caused a heap pollution , a term that refers to the situation where a variable of a parameterized type refers to an object that is not of that parameterized type. Heap pollution is dangerous, as now, we will get a ClassCastException when we do: 1 2 // getting back a string? -- now we get ClassCastException String str = pairArray [ 0 ] . getFirst (); The example above shows why generics and arrays don't mix well together. An array is what is called reifiable type -- a type where full type information is available during run-time. It is because Java array is reifiable that the Java run-time can check what we store into the array matches the type of the array and throw an ArrayStoreException at us if there is a mismatch. Java generics, however, is not reifiable due to type erasure. Java designers have decided not to mix the two. The hypothetical code above actually is not a valid Java syntax. We can't compile this line: 1 Pair < String , Integer >[] pairArray = new Pair < String , Integer >[ 2 ] ; The following is illegal as well: 1 2 new Pair < S , T >[ 2 ] ; new T [ 2 ] ;","title":"Generics and Arrays Can't Mix"},{"location":"22-unchecked.html","text":"Unit 22: Unchecked Warnings After this unit, students should: be aware of how to use generics with an array be aware of unchecked warnings that compilers can give when we are using generics be able to make arguments why a piece of code is type-safe for simple cases know how to suppress warnings from compilers be aware of the ethics when using the @SuppressWarnings(\"unchecked\") annotation know what is a raw type be aware that raw types should never never be used in modern Java Creating Arrays with Type Parameters We have seen how arrays and generics do not mix well. One way to get around this is to use Java Collections, a library of data structures provided by Java, instead of arrays, to store our items. The ArrayList class provides similar functionality to an array, with some performance overhead. 1 2 3 4 5 6 ArrayList < Pair < String , Integer >> pairList ; pairList = new ArrayList < Pair < String , Integer >> (); // ok pairList . add ( 0 , new Pair < Double , Boolean > ( 3.14 , true )); // error ArrayList < Object > objList = pairList ; // error ArrayList itself is a generic class, and when parameterized, it ensures type-safety by checking for appropriate types during compile time. We can't add a Pair<Double,Boolean> object to a list of Pair<String,Integer> . Furthermore, unlike Java array, which is covariant, generics are invariant. There is no subtyping relationship between ArrayList<Object> and ArrayList<Pair<String,Integer>> so we can't alias one with another, preventing the possibility of heap pollution. Using ArrayList instead of arrays only gets around the problem of mixing arrays and generics, as a user. ArrayList is implemented with an array internally after all. As computing students, especially computer science students, it is important to know how to implement your own data structures instead of using ones provided by Java or other libraries. Let's try to build one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.1 class Array < T > { private T [] array ; Array ( int size ) { this . array = ( T [] ) new Object [ size ] ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public T [] getArray () { return this . array ; } } This generic class is a wrapper around an array of type T . Recall that we can't new T[] directly. On Line 6, to get around this restriction, we new an Object array instead, and cast it to an array of T[] instead. The code now compiles, but we receive the following message: 1 2 3 $ javac Array.java Note: Array.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Let's do what the compiler tells us, and compile with the `-Xlint:unchecked\" flags. 1 2 3 4 5 6 7 8 9 $ javac -Xlint:unchecked Array.java Array.java:6: warning: [unchecked] unchecked cast array = (T[]) new Object[size]; ^ required: T[] found: Object[] where T is a type-variable: T extends Object declared in class Array 1 warning We get a warning that our Line 6 is doing an unchecked cast. Unchecked Warnings An unchecked warning is basically a message from the compiler that it has done what it can, and because of type erasures, there could be a run-time error that it cannot prevent. Recall that type erasure generates the following code: 1 ( String ) array . get ( 0 ); Since array is an array of Object instances and Java array is covariant, the compiler can't guarantee that the code it generated is safe anymore. Consider the following: 1 2 3 4 Array < String > array = new Array < String > ( 4 ); Object [] objArray = array . getArray (); objArray [ 0 ] = 4 ; array . get ( 0 ); // ClassCastException The last line would generate a ClassCastException , exactly a scenario that the compiler has warned us. It is now up to us humans to change our code so that the code is safe. Suppose we remove the getArray method from the Array class, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // version 0.2 class Array < T > { private T [] array ; Array ( int size ) { this . array = ( T [] ) new Object [ size ] ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } } Can we prove that our code is type-safe? In this case, yes. Since array is declared as private , the only way someone can put something into the array is through the Array::set method 1 . Array::set only put items of type T into array . So the only type of objects we can get out of array must be of type T . So we, as humans, can see that casting Object[] to T[] is type-safe. If we are sure (and only if we are sure) that the line 1 array = (T[]) new Object[size]; is safe, we can thank the compiler for its warning and assure the compiler that everything is going to be fine. We can do so with the @SuppressWarning(\"unchecked\") annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // version 0.3 class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into array is through // the method set() and we only put object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } } @SuppressWarning is a powerful annotation that suppresses warning messages from compilers. Like everything that is powerful, we have the responsibility to use it properly: @SuppressWarning can apply to declaration at a different scope: a local variable, a method, a type, etc. We must always use @SuppressWarning to the most limited scope to avoid unintentionally suppressing warnings that are valid concerns from the compiler. We must suppress a warning only if we are sure that it will not cause a type error later. We must always add a note (as a comment) to fellow programmers explaining why a warning can be safely suppressed. Note that since @SuppressWarnings cannot apply to an assignment but only to declaration, we declare a local variable a in the example above before assigning this.array to a . Raw Types Another common scenario where we can get an unchecked warning is the use of raw types . A raw type is a generic type used without type arguments. Suppose we do: 1 Array a = new Array ( 4 ); The code would compile perfectly. We are using the generic Array<T> as a raw type Array . Java allows this code to compile for backward compatibility. This is anyway what the code looks like after type erasure and how we would write the code in Java before version 5. Without a type argument, the compiler can't do any type checking at all. We are back to the uncertainty that our code could bomb with ClassCastException after it ships. Mixing raw types with paramterized types can also lead to errors. Consider: 1 2 3 Array < String > a = new Array < String > ( 4 ); populateArray ( a ); String s = a . get ( 0 ); where the method populateArray uses raw types: 1 2 3 vod populateArray ( Array a ) { a . set ( 0 , 1234 ); } Since we use raw types in this method, the compiler can't help us. It will warn us: 1 2 3 4 5 6 Array.java:24: warning: [unchecked] unchecked call to set(int,T) as a member of the raw type Array a.set(0, 1234); ^ where T is a type-variable: T extends Object declared in class Array 1 warning If we ignore this warning or worse, suppress this warning, we will get a run-time error when we execute a.get(0) . Raw types must not be used in your code, ever. The only exception to this rule is using it as an operand of the instanceof operator. Since instanceof checks for run-time type and type arguments have been erased, we can only use the instanceof operator on raw types. Another win for information hiding! \u21a9","title":"22. Unchecked Warnings"},{"location":"22-unchecked.html#unit-22-unchecked-warnings","text":"After this unit, students should: be aware of how to use generics with an array be aware of unchecked warnings that compilers can give when we are using generics be able to make arguments why a piece of code is type-safe for simple cases know how to suppress warnings from compilers be aware of the ethics when using the @SuppressWarnings(\"unchecked\") annotation know what is a raw type be aware that raw types should never never be used in modern Java","title":"Unit 22: Unchecked Warnings"},{"location":"22-unchecked.html#creating-arrays-with-type-parameters","text":"We have seen how arrays and generics do not mix well. One way to get around this is to use Java Collections, a library of data structures provided by Java, instead of arrays, to store our items. The ArrayList class provides similar functionality to an array, with some performance overhead. 1 2 3 4 5 6 ArrayList < Pair < String , Integer >> pairList ; pairList = new ArrayList < Pair < String , Integer >> (); // ok pairList . add ( 0 , new Pair < Double , Boolean > ( 3.14 , true )); // error ArrayList < Object > objList = pairList ; // error ArrayList itself is a generic class, and when parameterized, it ensures type-safety by checking for appropriate types during compile time. We can't add a Pair<Double,Boolean> object to a list of Pair<String,Integer> . Furthermore, unlike Java array, which is covariant, generics are invariant. There is no subtyping relationship between ArrayList<Object> and ArrayList<Pair<String,Integer>> so we can't alias one with another, preventing the possibility of heap pollution. Using ArrayList instead of arrays only gets around the problem of mixing arrays and generics, as a user. ArrayList is implemented with an array internally after all. As computing students, especially computer science students, it is important to know how to implement your own data structures instead of using ones provided by Java or other libraries. Let's try to build one: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // version 0.1 class Array < T > { private T [] array ; Array ( int size ) { this . array = ( T [] ) new Object [ size ] ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public T [] getArray () { return this . array ; } } This generic class is a wrapper around an array of type T . Recall that we can't new T[] directly. On Line 6, to get around this restriction, we new an Object array instead, and cast it to an array of T[] instead. The code now compiles, but we receive the following message: 1 2 3 $ javac Array.java Note: Array.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Let's do what the compiler tells us, and compile with the `-Xlint:unchecked\" flags. 1 2 3 4 5 6 7 8 9 $ javac -Xlint:unchecked Array.java Array.java:6: warning: [unchecked] unchecked cast array = (T[]) new Object[size]; ^ required: T[] found: Object[] where T is a type-variable: T extends Object declared in class Array 1 warning We get a warning that our Line 6 is doing an unchecked cast.","title":"Creating Arrays with Type Parameters"},{"location":"22-unchecked.html#unchecked-warnings","text":"An unchecked warning is basically a message from the compiler that it has done what it can, and because of type erasures, there could be a run-time error that it cannot prevent. Recall that type erasure generates the following code: 1 ( String ) array . get ( 0 ); Since array is an array of Object instances and Java array is covariant, the compiler can't guarantee that the code it generated is safe anymore. Consider the following: 1 2 3 4 Array < String > array = new Array < String > ( 4 ); Object [] objArray = array . getArray (); objArray [ 0 ] = 4 ; array . get ( 0 ); // ClassCastException The last line would generate a ClassCastException , exactly a scenario that the compiler has warned us. It is now up to us humans to change our code so that the code is safe. Suppose we remove the getArray method from the Array class, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // version 0.2 class Array < T > { private T [] array ; Array ( int size ) { this . array = ( T [] ) new Object [ size ] ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } } Can we prove that our code is type-safe? In this case, yes. Since array is declared as private , the only way someone can put something into the array is through the Array::set method 1 . Array::set only put items of type T into array . So the only type of objects we can get out of array must be of type T . So we, as humans, can see that casting Object[] to T[] is type-safe. If we are sure (and only if we are sure) that the line 1 array = (T[]) new Object[size]; is safe, we can thank the compiler for its warning and assure the compiler that everything is going to be fine. We can do so with the @SuppressWarning(\"unchecked\") annotation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // version 0.3 class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into array is through // the method set() and we only put object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } } @SuppressWarning is a powerful annotation that suppresses warning messages from compilers. Like everything that is powerful, we have the responsibility to use it properly: @SuppressWarning can apply to declaration at a different scope: a local variable, a method, a type, etc. We must always use @SuppressWarning to the most limited scope to avoid unintentionally suppressing warnings that are valid concerns from the compiler. We must suppress a warning only if we are sure that it will not cause a type error later. We must always add a note (as a comment) to fellow programmers explaining why a warning can be safely suppressed. Note that since @SuppressWarnings cannot apply to an assignment but only to declaration, we declare a local variable a in the example above before assigning this.array to a .","title":"Unchecked Warnings"},{"location":"22-unchecked.html#raw-types","text":"Another common scenario where we can get an unchecked warning is the use of raw types . A raw type is a generic type used without type arguments. Suppose we do: 1 Array a = new Array ( 4 ); The code would compile perfectly. We are using the generic Array<T> as a raw type Array . Java allows this code to compile for backward compatibility. This is anyway what the code looks like after type erasure and how we would write the code in Java before version 5. Without a type argument, the compiler can't do any type checking at all. We are back to the uncertainty that our code could bomb with ClassCastException after it ships. Mixing raw types with paramterized types can also lead to errors. Consider: 1 2 3 Array < String > a = new Array < String > ( 4 ); populateArray ( a ); String s = a . get ( 0 ); where the method populateArray uses raw types: 1 2 3 vod populateArray ( Array a ) { a . set ( 0 , 1234 ); } Since we use raw types in this method, the compiler can't help us. It will warn us: 1 2 3 4 5 6 Array.java:24: warning: [unchecked] unchecked call to set(int,T) as a member of the raw type Array a.set(0, 1234); ^ where T is a type-variable: T extends Object declared in class Array 1 warning If we ignore this warning or worse, suppress this warning, we will get a run-time error when we execute a.get(0) . Raw types must not be used in your code, ever. The only exception to this rule is using it as an operand of the instanceof operator. Since instanceof checks for run-time type and type arguments have been erased, we can only use the instanceof operator on raw types. Another win for information hiding! \u21a9","title":"Raw Types"},{"location":"23-wildcard.html","text":"Unit 23: Wildcards After going through this unit, students should: be aware of the meaning of wildcard ? and bounded wildcards know how to use wildcards to write methods that are more flexible in accepting a range of types know that upper-bounded wildcard is covariant and lower-bounded wildcard is contravariant know the PECS principle and how to apply it: contains with Array<T> Now that we have our Array<T> class, let's modify our generic contains method and replace the type of the argument T[] with Array<T> . 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.5 (with generic array) public static < T > boolean contains ( Array < T > array , T obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } Similar to the version that takes in T[] , using generics allows us to constrain the type of the elements of the array and the object to search for to be the same. This allows the following code to type-check correctly: 1 2 3 4 5 6 Array < String > stringArray ; Array < Circle > circleArray ; Circle circle ; : A . < String > contains ( stringArray , \"hello\" ); // ok A . < Circle > contains ( circleArray , circle ); // ok But trying to search for a circle in an array of string would lead to a type error: 1 A . < String > contains ( stringArray , circle ); // error Consider now having an array of shapes. 1 2 3 4 5 6 7 Array < Shape > shapeArray ; Array < Circle > circleArray ; Shape shape ; Circle circle ; : A . < Shape > contains ( shapeArray , shape ); // ok A . < Circle > contains ( circleArray , circle ); // ok As expected, we can pass Shape as the argument for T , and search for a Shape in an instance of Array<Shape> . Similarly, we can pass Circle as the argument for T and search for a Circle in an instance of Array<Circle> . We could also look for a Circle instance from Array<Shape> if we pass Shape as the argument for T . 1 A . < Shape > contains ( shapeArray , circle ); // ok Note that we can pass in a Circle instance as a Shape , since Circle <: Shape . Recall that generics are invariant in Java, i.e, there is no subtyping relationship between Array<Shape> and Array<Circle> . Array<Circle> is not a subtype of Array<Shape> . Otherwise, it would violate the Liskov Substitution Principle, we can put a square into an Array<Shape> instance, but we can't put a square into an Array<Circle> instance. So, we can't call: 1 A . < Circle > contains ( shapeArray , circle ); // compilation error The following would result in compilation errors as well: 1 2 A . < Shape > contains ( circleArray , shape ); // compilation error A . < Circle > contains ( circleArray , shape ); // compilation error Thus, with our current implementation, we can't look for a shape (which may be a circle) in an array of circles, even though this is something reasonable that a programmer might want to do. This constraint is due to the invariance of generics -- while we avoided the possibility of run-time errors by avoiding covariance arrays, our methods have become less general. Let's see how we can fix this with bounded type parameters first. We can introduce another type parameter, say S , to remove the constraints that the type of the array must be the same as the type of the object to search for. I.e., we change from 1 public static < T > boolean contains ( Array < T > array , T obj ) { .. } to: 1 public static < S , T > boolean contains ( Array < T > array , S obj ) { .. } But we don't want to completely decouple T and S , as we want T to be a subtype of S . We can thus make T a bounded type parameter, and write: 1 public static < S , T extends S > boolean contains ( Array < T > array , S obj ) { .. } Now, we can search for a shape in an array of circles. 1 A . < Shape , Circle > contains ( circleArray , shape ); Copying to and from Array<T> Let's consider another example. Let's add two methods copyFrom and copyTo , to Array<T> so that we can copy to and from one array to another. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 (with copy) class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into the array is through // the method set() and we only put an object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public void copyFrom ( Array < T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } public void copyTo ( Array < T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } } With this implementation, we can copy, say, an Array<Circle> to another Array<Circle> , an Array<Shape> to another Array<Shape> , but not an Array<Circle> into an Array<Shape> , even though each circle is a shape! 1 2 3 4 5 Array < Circle > circleArray ; Array < Shape > shapeArray ; : shapeArray . copyFrom ( circleArray ); // error circleArray . copyTo ( shapeArray ); // error Upper-Bounded Wildcards Let's consider the method copyFrom . We should be able to copy from an array of shapes, an array of circles, an array of squares, etc, into an array of shapes. In other words, we should be able to copy from an array of any subtype of shapes into an array of shapes. Is there such a type in Java? The type that we are looking for is Array<? extends Shape> . This generic type uses the wildcard ? . Just like a wild card in card games, it is a substitute for any type. A wildcard can be bounded. Here, this wildcard is upper-bounded by Shape , i.e., it can be substituted with either Shape or any subtype of Shape . The upper-bounded wildcard is an example of covariance. The upper-bounded wildcard has the following subtyping relations: If S <: T , then A<? extends S> <: A<? extends T> (covariance) For any type S , A<S> <: A<? extends S> For instance, we have: Array<Circle> <: Array<? extends Circle> Since Circle <: Shape , Array<? extends Circle> <: Array<? extends Shape> Since subtyping is transitive, we have Array<Circle> <: Array<? extends Shape> Because Array<Circle> <: Array<? extends Shape> , if we change the type of the parameter to copyFrom to Array<? extends T> , 1 2 3 4 5 6 public void copyFrom ( Array <? extends T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } We can now call: 1 shapeArray.copyFrom(circleArray); // ok without error. Lower-Bounded Wildcards Let's now try to allow copying of an Array<Circle> to Array<Shape> . 1 circleArray . copyTo ( shapeArray ); by doing the same thing: 1 2 3 4 5 6 public void copyTo ( Array <? extends T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } The code above would not compile. We will get the following somewhat cryptic message when we compile with the -Xdiags:verbose flag: 1 2 3 4 5 6 7 8 9 10 11 Array . java : 32 : error : method set in class Array < T > cannot be applied to given types ; dest . set ( i , this . get ( i )); ^ required : int , CAP # 1 found : int , T reason : argument mismatch ; T cannot be converted to CAP # 1 where T is a type - variable : T extends Object declared in class Array where CAP # 1 is a fresh type - variable : CAP # 1 extends T from capture of ? extends T 1 error Let's try not to understand what the error message means first, and think about what could go wrong if the compiler allows: 1 dest . set ( i , this . get ( i )); Here, we are trying to put an instance with compile-time type T into an array that contains elements with the compile-time type of T or subtype of T . The copyTo method of Array<Shape> would allow an Array<Circle> as an argument, and we would end up putting instance with compile-time type Shape into Array<Circle> . If all the shapes are circles, we are fine, but there might be other shapes (rectangles, squares) in this instance of Array<Shape> , and we can't fit them into Array<Circle> ! Thus, the line 1 dest . set ( i , this . get ( i )); is not type-safe and could lead to ClassCastException during run-time. Where can we copy our shapes into? We can only copy them safely into an Array<Shape> , Array<Object> , Array<GetAreable> , for instance. In other words, into arrays containing Shape or supertype of Shape . We need a wildcard lower-bounded by Shape , and Java's syntax for this is ? super Shape . Using this new notation, we can replace the type for dest with: 1 2 3 4 5 6 public void copyTo ( Array <? super T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } The code would now type-check and compile. The lower-bounded wildcard is an example of contravariance. We have the following subtyping relations: If S <: T , then A<? super T> <: A<? super S> (contravariance) For any type S , A<S> <: A<? super S> For instance, we have: Array<Shape> <: Array<? super Shape> Since Circle <: Shape , Array<? super Shape> <: Array<? super Circle> Since subtyping is transitive, we have Array<Shape> <: Array<? super Circle> The line of code below now compiles: 1 circleArray . copyTo ( shapeArray ); Our new `Array is now 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.5 (with flexible copy using wildcards) class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into the array is through // the method set() and we only put an object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public void copyFrom ( Array <? extends T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } public void copyTo ( Array <? super T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } } PECS Now we will introduce the rule that governs when we should use the upper-bounded wildcard ? extends T and a lower-bounded wildcard ? super T . It depends on the role of the variable. If the variable is a producer that returns a variable of type T , it should be declared with the wildcard ? extends T . Otherwise, if it is a consumer that accepts a variable of type T , it should be declared with the wildcard ? super T . As an example, the variable src in copyFrom above acts as a producer . It produces a variable of type T . The type parameter for src must be either T or a subtype of T to ensure type safety. So the type for src is Array<? extends T> . On the other hand, the variable dest in copyTo above acts as a consumer . It consumes a variable of type T . The type parameter of dest must be either T or supertype of T for it to be type-safe. As such, the type for dest is Array<? super T> . This rule can be remembered with the mnemonic PECS, or \"Producer Extends; Consumer Super\". Unbounded Wildcards It is also possible to have unbounded wildcards, such as Array<?> . Array<?> is the supertype of all generic Array<T> . A method that takes in generic type with unbounded wildcard would be pretty restrictive, however. Consider this: 1 2 3 4 5 6 void foo ( Array <?> array ) { : x = array . get ( 0 ); array . set ( 0 , y ); } What should the type of the returned element x be? Since Array<?> is the supertype of all possible Array<T> , the method foo can receive an instance of Array<Circle> , Array<String> , etc. as an argument. The only safe choice for the type of x is Object . The type for y is every more restrictive. Since there are many possibilities of what type of array it is receiving, we can only put null into array ! Back to contains Now, let's simplify our contains methods with the help of wildcards. Recall that to add flexibility into the method parameter and allow us to search for a shape in an array of circles, we have modified our method into the following: 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.6 (with generic array) public static < S , T extends S > boolean contains ( Array < T > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } Can we make this simpler using wildcards? Since we want to search for an object of type S in an array of its subtype, we can remove the second parameter type T and change the type of array to Array<? extends S> : 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.7 (with wild cards array) public static < S > boolean contains ( Array <? extends S > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { S curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } We can double-check that array is a producer (it produces curr on Line 5) and this follows the PECS rules. Now, we can search for a shape in an array of circles. 1 A . < Shape > contains ( circleArray , shape );","title":"23. Wildcards"},{"location":"23-wildcard.html#unit-23-wildcards","text":"After going through this unit, students should: be aware of the meaning of wildcard ? and bounded wildcards know how to use wildcards to write methods that are more flexible in accepting a range of types know that upper-bounded wildcard is covariant and lower-bounded wildcard is contravariant know the PECS principle and how to apply it:","title":"Unit 23: Wildcards"},{"location":"23-wildcard.html#contains-with-arrayt","text":"Now that we have our Array<T> class, let's modify our generic contains method and replace the type of the argument T[] with Array<T> . 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.5 (with generic array) public static < T > boolean contains ( Array < T > array , T obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } Similar to the version that takes in T[] , using generics allows us to constrain the type of the elements of the array and the object to search for to be the same. This allows the following code to type-check correctly: 1 2 3 4 5 6 Array < String > stringArray ; Array < Circle > circleArray ; Circle circle ; : A . < String > contains ( stringArray , \"hello\" ); // ok A . < Circle > contains ( circleArray , circle ); // ok But trying to search for a circle in an array of string would lead to a type error: 1 A . < String > contains ( stringArray , circle ); // error Consider now having an array of shapes. 1 2 3 4 5 6 7 Array < Shape > shapeArray ; Array < Circle > circleArray ; Shape shape ; Circle circle ; : A . < Shape > contains ( shapeArray , shape ); // ok A . < Circle > contains ( circleArray , circle ); // ok As expected, we can pass Shape as the argument for T , and search for a Shape in an instance of Array<Shape> . Similarly, we can pass Circle as the argument for T and search for a Circle in an instance of Array<Circle> . We could also look for a Circle instance from Array<Shape> if we pass Shape as the argument for T . 1 A . < Shape > contains ( shapeArray , circle ); // ok Note that we can pass in a Circle instance as a Shape , since Circle <: Shape . Recall that generics are invariant in Java, i.e, there is no subtyping relationship between Array<Shape> and Array<Circle> . Array<Circle> is not a subtype of Array<Shape> . Otherwise, it would violate the Liskov Substitution Principle, we can put a square into an Array<Shape> instance, but we can't put a square into an Array<Circle> instance. So, we can't call: 1 A . < Circle > contains ( shapeArray , circle ); // compilation error The following would result in compilation errors as well: 1 2 A . < Shape > contains ( circleArray , shape ); // compilation error A . < Circle > contains ( circleArray , shape ); // compilation error Thus, with our current implementation, we can't look for a shape (which may be a circle) in an array of circles, even though this is something reasonable that a programmer might want to do. This constraint is due to the invariance of generics -- while we avoided the possibility of run-time errors by avoiding covariance arrays, our methods have become less general. Let's see how we can fix this with bounded type parameters first. We can introduce another type parameter, say S , to remove the constraints that the type of the array must be the same as the type of the object to search for. I.e., we change from 1 public static < T > boolean contains ( Array < T > array , T obj ) { .. } to: 1 public static < S , T > boolean contains ( Array < T > array , S obj ) { .. } But we don't want to completely decouple T and S , as we want T to be a subtype of S . We can thus make T a bounded type parameter, and write: 1 public static < S , T extends S > boolean contains ( Array < T > array , S obj ) { .. } Now, we can search for a shape in an array of circles. 1 A . < Shape , Circle > contains ( circleArray , shape );","title":"contains with Array&lt;T&gt;"},{"location":"23-wildcard.html#copying-to-and-from-arrayt","text":"Let's consider another example. Let's add two methods copyFrom and copyTo , to Array<T> so that we can copy to and from one array to another. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.4 (with copy) class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into the array is through // the method set() and we only put an object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public void copyFrom ( Array < T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } public void copyTo ( Array < T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } } With this implementation, we can copy, say, an Array<Circle> to another Array<Circle> , an Array<Shape> to another Array<Shape> , but not an Array<Circle> into an Array<Shape> , even though each circle is a shape! 1 2 3 4 5 Array < Circle > circleArray ; Array < Shape > shapeArray ; : shapeArray . copyFrom ( circleArray ); // error circleArray . copyTo ( shapeArray ); // error","title":"Copying to and from Array&lt;T&gt;"},{"location":"23-wildcard.html#upper-bounded-wildcards","text":"Let's consider the method copyFrom . We should be able to copy from an array of shapes, an array of circles, an array of squares, etc, into an array of shapes. In other words, we should be able to copy from an array of any subtype of shapes into an array of shapes. Is there such a type in Java? The type that we are looking for is Array<? extends Shape> . This generic type uses the wildcard ? . Just like a wild card in card games, it is a substitute for any type. A wildcard can be bounded. Here, this wildcard is upper-bounded by Shape , i.e., it can be substituted with either Shape or any subtype of Shape . The upper-bounded wildcard is an example of covariance. The upper-bounded wildcard has the following subtyping relations: If S <: T , then A<? extends S> <: A<? extends T> (covariance) For any type S , A<S> <: A<? extends S> For instance, we have: Array<Circle> <: Array<? extends Circle> Since Circle <: Shape , Array<? extends Circle> <: Array<? extends Shape> Since subtyping is transitive, we have Array<Circle> <: Array<? extends Shape> Because Array<Circle> <: Array<? extends Shape> , if we change the type of the parameter to copyFrom to Array<? extends T> , 1 2 3 4 5 6 public void copyFrom ( Array <? extends T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } We can now call: 1 shapeArray.copyFrom(circleArray); // ok without error.","title":"Upper-Bounded Wildcards"},{"location":"23-wildcard.html#lower-bounded-wildcards","text":"Let's now try to allow copying of an Array<Circle> to Array<Shape> . 1 circleArray . copyTo ( shapeArray ); by doing the same thing: 1 2 3 4 5 6 public void copyTo ( Array <? extends T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } The code above would not compile. We will get the following somewhat cryptic message when we compile with the -Xdiags:verbose flag: 1 2 3 4 5 6 7 8 9 10 11 Array . java : 32 : error : method set in class Array < T > cannot be applied to given types ; dest . set ( i , this . get ( i )); ^ required : int , CAP # 1 found : int , T reason : argument mismatch ; T cannot be converted to CAP # 1 where T is a type - variable : T extends Object declared in class Array where CAP # 1 is a fresh type - variable : CAP # 1 extends T from capture of ? extends T 1 error Let's try not to understand what the error message means first, and think about what could go wrong if the compiler allows: 1 dest . set ( i , this . get ( i )); Here, we are trying to put an instance with compile-time type T into an array that contains elements with the compile-time type of T or subtype of T . The copyTo method of Array<Shape> would allow an Array<Circle> as an argument, and we would end up putting instance with compile-time type Shape into Array<Circle> . If all the shapes are circles, we are fine, but there might be other shapes (rectangles, squares) in this instance of Array<Shape> , and we can't fit them into Array<Circle> ! Thus, the line 1 dest . set ( i , this . get ( i )); is not type-safe and could lead to ClassCastException during run-time. Where can we copy our shapes into? We can only copy them safely into an Array<Shape> , Array<Object> , Array<GetAreable> , for instance. In other words, into arrays containing Shape or supertype of Shape . We need a wildcard lower-bounded by Shape , and Java's syntax for this is ? super Shape . Using this new notation, we can replace the type for dest with: 1 2 3 4 5 6 public void copyTo ( Array <? super T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } The code would now type-check and compile. The lower-bounded wildcard is an example of contravariance. We have the following subtyping relations: If S <: T , then A<? super T> <: A<? super S> (contravariance) For any type S , A<S> <: A<? super S> For instance, we have: Array<Shape> <: Array<? super Shape> Since Circle <: Shape , Array<? super Shape> <: Array<? super Circle> Since subtyping is transitive, we have Array<Shape> <: Array<? super Circle> The line of code below now compiles: 1 circleArray . copyTo ( shapeArray ); Our new `Array is now 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // version 0.5 (with flexible copy using wildcards) class Array < T > { private T [] array ; Array ( int size ) { // The only way we can put an object into the array is through // the method set() and we only put an object of type T inside. // So it is safe to cast `Object[]` to `T[]`. @SuppressWarnings ( \"unchecked\" ) T [] a = ( T [] ) new Object [ size ] ; this . array = a ; } public void set ( int index , T item ) { this . array [ index ] = item ; } public T get ( int index ) { return this . array [ index ] ; } public void copyFrom ( Array <? extends T > src ) { int len = Math . min ( this . array . length , src . array . length ); for ( int i = 0 ; i < len ; i ++ ) { this . set ( i , src . get ( i )); } } public void copyTo ( Array <? super T > dest ) { int len = Math . min ( this . array . length , dest . array . length ); for ( int i = 0 ; i < len ; i ++ ) { dest . set ( i , this . get ( i )); } } }","title":"Lower-Bounded Wildcards"},{"location":"23-wildcard.html#pecs","text":"Now we will introduce the rule that governs when we should use the upper-bounded wildcard ? extends T and a lower-bounded wildcard ? super T . It depends on the role of the variable. If the variable is a producer that returns a variable of type T , it should be declared with the wildcard ? extends T . Otherwise, if it is a consumer that accepts a variable of type T , it should be declared with the wildcard ? super T . As an example, the variable src in copyFrom above acts as a producer . It produces a variable of type T . The type parameter for src must be either T or a subtype of T to ensure type safety. So the type for src is Array<? extends T> . On the other hand, the variable dest in copyTo above acts as a consumer . It consumes a variable of type T . The type parameter of dest must be either T or supertype of T for it to be type-safe. As such, the type for dest is Array<? super T> . This rule can be remembered with the mnemonic PECS, or \"Producer Extends; Consumer Super\".","title":"PECS"},{"location":"23-wildcard.html#unbounded-wildcards","text":"It is also possible to have unbounded wildcards, such as Array<?> . Array<?> is the supertype of all generic Array<T> . A method that takes in generic type with unbounded wildcard would be pretty restrictive, however. Consider this: 1 2 3 4 5 6 void foo ( Array <?> array ) { : x = array . get ( 0 ); array . set ( 0 , y ); } What should the type of the returned element x be? Since Array<?> is the supertype of all possible Array<T> , the method foo can receive an instance of Array<Circle> , Array<String> , etc. as an argument. The only safe choice for the type of x is Object . The type for y is every more restrictive. Since there are many possibilities of what type of array it is receiving, we can only put null into array !","title":"Unbounded Wildcards"},{"location":"23-wildcard.html#back-to-contains","text":"Now, let's simplify our contains methods with the help of wildcards. Recall that to add flexibility into the method parameter and allow us to search for a shape in an array of circles, we have modified our method into the following: 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.6 (with generic array) public static < S , T extends S > boolean contains ( Array < T > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } Can we make this simpler using wildcards? Since we want to search for an object of type S in an array of its subtype, we can remove the second parameter type T and change the type of array to Array<? extends S> : 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.7 (with wild cards array) public static < S > boolean contains ( Array <? extends S > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { S curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } We can double-check that array is a producer (it produces curr on Line 5) and this follows the PECS rules. Now, we can search for a shape in an array of circles. 1 A . < Shape > contains ( circleArray , shape );","title":"Back to contains"},{"location":"24-inference.html","text":"Unit 24: Type Inference After this unit, students should: be familiar how Java infers missing type arguments We have seen in the past units the importance of types in preventing run-time errors. Utilizing types properly can help programmers catch type mismatch errors that could have caused a program to fail during run-time, possibly after it is released and shipped. By including type information everywhere in the code, we make the code explicit in communicating the intention of the programmers to the readers. Although it makes the code more verbose and cluttered -- it is a small price to pay for ensuring the type correctness of the code and reducing the likelihood of bugs as the code complexity increases. Java, however, allows the programmer to skip some of the type annotations and try to infer the type argument of a generic method and a generic type, through the type inference process. The basic idea of type inference is simple: Java will looking among the matching types that would lead to successful type checks, and pick the most specific ones. Diamond Operator One example of type inference is the diamond operator <> when we new an instance of a generic type: 1 Pair < String , Integer > p = new Pair <> (); Java can infer that p should be an instance of Pair<String,Integer> since the compile-time type of p is Pair<String,Integer> . The line above is equivalent to: 1 Pair < String , Integer > p = new Pair < String , Integer > (); Type Inferencing We have been invoking 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.7 (with wild cards array) public static < S > boolean contains ( Array <? extends S > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { S curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } by explicitly passing in the type argument Shape (also called type witness in the context of type inference). 1 A . < Shape > contains ( circleArray , shape ); We could remove the type argument <Shape> so that we can call contains just like a non-generic method: 1 A . contains ( circleArray , shape ); and Java could still infer that S should be Shape . The type inference process looks for all possible types that match. In this example, the type of the two parameters must match. Let's consider each individually first: An object of type Shape is passed as an argument to the parameter obj . So S might be Shape or, if widening type conversion has occurred, one of the other supertypes of Shape . An Array<Circle> has been passed into Array<? extends S> . A widening type conversion occurred here, so we need to find all possible S such that Array<Circle> <: Array<? extends S> . This is true only if S is Circle , or another supertype of Circle . Intersecting the two lists, we know that S could be Shape or one of its supertypes: GetAreable and Object . The most specific type among these is Shape . So, S is inferred to be Shape . Type inferencing can have unexpected consequences. Let's consider an older version of contains that we wrote : 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.4 (with generics) public static < T > boolean contains ( T [] array , T obj ) { for ( T curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } Recall that we want to prevent nonsensical calls where we are searching for an integer in an array of strings. 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . < String > contains ( strArray , 123 ); // type mismatch error But, if we write: 1 A . contains ( strArray , 123 ); // ok! (huh?) The code compiles! Let's go through the type inferencing steps to understand what happened. Again, we have two parameters: strArray has the type String[] and is passed to T[] . So T must be String or its superclass Object . The latter is possible since Java array is covariant. 123 is passed as type T . The value is treated as Integer and, therefore, T must be either Integer or its superclass Object . The intersection between the two is the type Object , which is also the most specific type. So, Java infers T to be Object . The code above is equivalent to: 1 A . < Object > contains ( strArray , 123 ); And our version 0.4 of contains actually is quite fragile and does not work as intended. We were bitten by the fact that the Java array is covariant, again. Target Typing The example above performs type inferencing on the parameters of the generic methods. Type inferencing can involve the type of the expression as well. This is known as target typing . Take the following upgraded version of findLargest : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.6 (with Array<T>) public static < T extends GetAreable > T findLargest ( Array <? extends T > array ) { double maxArea = 0 ; T maxObj = null ; for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } and we call 1 Shape o = A.findLargest(new Array<Circle>(0)); We have a few more constraints to check: Due to target typing, the returning type of T must be a subtype of Shape (including Shape ) Due to the bound of the type parameter, T must be a subtype of GetAreable (including GetAreable ) Array<Circle> must be a subtype of Array<? extends T> , so T must be a supertype of Circle (including Circle ) Intersecting all these possibilities, only two possibilities emerge: Shape and Circle . The most specific one is Circle , so the call above is equivalent to: 1 Shape o = A.<Circle>findLargest(new Array<Circle>(0));","title":"24. Type Inference"},{"location":"24-inference.html#unit-24-type-inference","text":"After this unit, students should: be familiar how Java infers missing type arguments We have seen in the past units the importance of types in preventing run-time errors. Utilizing types properly can help programmers catch type mismatch errors that could have caused a program to fail during run-time, possibly after it is released and shipped. By including type information everywhere in the code, we make the code explicit in communicating the intention of the programmers to the readers. Although it makes the code more verbose and cluttered -- it is a small price to pay for ensuring the type correctness of the code and reducing the likelihood of bugs as the code complexity increases. Java, however, allows the programmer to skip some of the type annotations and try to infer the type argument of a generic method and a generic type, through the type inference process. The basic idea of type inference is simple: Java will looking among the matching types that would lead to successful type checks, and pick the most specific ones.","title":"Unit 24: Type Inference"},{"location":"24-inference.html#diamond-operator","text":"One example of type inference is the diamond operator <> when we new an instance of a generic type: 1 Pair < String , Integer > p = new Pair <> (); Java can infer that p should be an instance of Pair<String,Integer> since the compile-time type of p is Pair<String,Integer> . The line above is equivalent to: 1 Pair < String , Integer > p = new Pair < String , Integer > ();","title":"Diamond Operator"},{"location":"24-inference.html#type-inferencing","text":"We have been invoking 1 2 3 4 5 6 7 8 9 10 11 12 class A { // version 0.7 (with wild cards array) public static < S > boolean contains ( Array <? extends S > array , S obj ) { for ( int i = 0 ; i < array . getLength (); i ++ ) { S curr = array . get ( i ); if ( curr . equals ( obj )) { return true ; } } return false ; } } by explicitly passing in the type argument Shape (also called type witness in the context of type inference). 1 A . < Shape > contains ( circleArray , shape ); We could remove the type argument <Shape> so that we can call contains just like a non-generic method: 1 A . contains ( circleArray , shape ); and Java could still infer that S should be Shape . The type inference process looks for all possible types that match. In this example, the type of the two parameters must match. Let's consider each individually first: An object of type Shape is passed as an argument to the parameter obj . So S might be Shape or, if widening type conversion has occurred, one of the other supertypes of Shape . An Array<Circle> has been passed into Array<? extends S> . A widening type conversion occurred here, so we need to find all possible S such that Array<Circle> <: Array<? extends S> . This is true only if S is Circle , or another supertype of Circle . Intersecting the two lists, we know that S could be Shape or one of its supertypes: GetAreable and Object . The most specific type among these is Shape . So, S is inferred to be Shape . Type inferencing can have unexpected consequences. Let's consider an older version of contains that we wrote : 1 2 3 4 5 6 7 8 9 10 11 class A { // version 0.4 (with generics) public static < T > boolean contains ( T [] array , T obj ) { for ( T curr : array ) { if ( curr . equals ( obj )) { return true ; } } return false ; } } Recall that we want to prevent nonsensical calls where we are searching for an integer in an array of strings. 1 2 String [] strArray = new String [] { \"hello\" , \"world\" }; A . < String > contains ( strArray , 123 ); // type mismatch error But, if we write: 1 A . contains ( strArray , 123 ); // ok! (huh?) The code compiles! Let's go through the type inferencing steps to understand what happened. Again, we have two parameters: strArray has the type String[] and is passed to T[] . So T must be String or its superclass Object . The latter is possible since Java array is covariant. 123 is passed as type T . The value is treated as Integer and, therefore, T must be either Integer or its superclass Object . The intersection between the two is the type Object , which is also the most specific type. So, Java infers T to be Object . The code above is equivalent to: 1 A . < Object > contains ( strArray , 123 ); And our version 0.4 of contains actually is quite fragile and does not work as intended. We were bitten by the fact that the Java array is covariant, again.","title":"Type Inferencing"},{"location":"24-inference.html#target-typing","text":"The example above performs type inferencing on the parameters of the generic methods. Type inferencing can involve the type of the expression as well. This is known as target typing . Take the following upgraded version of findLargest : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // version 0.6 (with Array<T>) public static < T extends GetAreable > T findLargest ( Array <? extends T > array ) { double maxArea = 0 ; T maxObj = null ; for ( int i = 0 ; i < array . getLength (); i ++ ) { T curr = array . get ( i ); double area = curr . getArea (); if ( area > maxArea ) { maxArea = area ; maxObj = curr ; } } return maxObj ; } and we call 1 Shape o = A.findLargest(new Array<Circle>(0)); We have a few more constraints to check: Due to target typing, the returning type of T must be a subtype of Shape (including Shape ) Due to the bound of the type parameter, T must be a subtype of GetAreable (including GetAreable ) Array<Circle> must be a subtype of Array<? extends T> , so T must be a supertype of Circle (including Circle ) Intersecting all these possibilities, only two possibilities emerge: Shape and Circle . The most specific one is Circle , so the call above is equivalent to: 1 Shape o = A.<Circle>findLargest(new Array<Circle>(0));","title":"Target Typing"},{"location":"25-immutability.html","text":"Unit 25: Immutability So far in this class, we have been focusing on three ways of dealing with software complexity: by encapsulating and hiding the complexity behind abstraction barriers, by using a language with a strong type system and adhering to the subtyping substitution principle, and applying the abstraction principles and reusing code written as functions, classes, and generics types. Another useful strategy to reduce bugs when code complexity increases is to avoid change altogether. This can be done by making our classes immutable . we create an instance of an immutable class, the instance cannot have any visible changes outside its abstraction barrier . This means that every call of the instance's method must behave the same way throughout the lifetime of the instance. There are many advantages of why we want to make our class immutable when possible. To start, let's revisit a common bug due to aliasing. Recall the following example from Unit 9 , where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we have the moveTo method in both Circle and Point , to move the circle and point respectively. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Point { private double x ; private double y ; : public void moveTo ( double x , double y ) { this . x = x ; this . y = y ; } } class Circle { private Point c ; private double r ; public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } : public void moveTo ( double x , double y ) { c . moveTo ( x , y ); } } Suppose we want to move c1 and only c1 to be centered at (1,1). 1 c1 . moveTo ( 1 , 1 ); The line of code above surprisingly moved the center of both c1 and c2 , due to both circles c1 and c2 sharing the same point. We have explored a solution below: 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); c1 . moveTo ( 1 , 1 ); This approach avoids sharing references by creating copies of our points so that no two references point to the same instance, avoiding aliasing altogether. This fix, however, comes with extra costs in computational resources as the number of objects may proliferate. Let's now see how immutability can help us resolve our problem. Immutable Points and Circles Let's start by making our Point class immutable. We start by making the fields final to signal our intention that we do not intend to change them. Now that the x and y cannot be changed, to move a point, we shouldn't mutate the fields x and y anymore. Instead, we return a new Point instance, as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 final class Point { final private double x ; final private double y ; public Point ( double x , double y ) { this . x = x ; this . y = y ; } public Point moveTo ( double x , double y ) { return new Point ( x , y ); } : @Override public String toString () { return \"(\" + this . x + \",\" + this . y + \")\" ; } } Note that, to avoid (likely malicious or ignorant) subclasses of Point overriding the methods to make it appears that the point has mutated, it is recommended that we declare immutable classes as final to disallow inheritance. Now, let's make Circle immutable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 final class Circle { final private Point c ; final private double r ; public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } : public Circle moveTo ( double x , double y ) { return new Circle ( c . moveTo ( x , y ), r ); } } With both Point and Circle immutable, we can be sure that once an instance is created, it remains unchanged (outside the abstraction barrier): 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( 1 , 1 ); // c1 remains unchanged To update the variable c1 , we need to explicitly reassign it. 1 c1 = c1 . moveTo ( 1 , 1 ); Now, c1 moves to a new location, but c2 remains unchanged. Compare our new immutable approach to the two approaches above. The first shares all the references and is bug-prone. The second creates a new copy of the instance every time and is resource-intensive. Our third approach, using immutable classes, allows us to share all the references until we need to modify the instance, in which case we make a copy. Such a copy-on-write semantic allows us to avoid aliasing bugs without creating excessive copies of objects. Advantages of Being Immutable We have seen how making our classes immutable helps us remove the risk of potential bugs when we use composition and aliasing. Immutability has other advantages as well. Ease of Understanding Code written with immutable objects is easier to reason with and easier to understand. Suppose we create a Circle and assign it to a local variable: 1 Circle c = new Circle ( new Point ( 0 , 0 ), 8 ); We pass c around to many other methods. These other methods may invoke c 's methods; we may invoke c 's methods locally as well. But, despite putting c through so much, unless we have explicitly reassigned c , we can guarantee that c is still a circle centered at (0,0) with a radius of 8. This immutable property makes it significantly easier to read, understand, and debug our code. Without this property, we have to trace through all the methods that we pass c to, and each call of c 's methods to make sure that none of these codes modifies c . Enabling Safe Sharing of Objects Making a class immutable allows us to safely share instances of the class and therefore reducing the need to create multiple copies of the same object. For instance, the origin (0, 0) is commonly used. If the instance is immutable, we can just create and cache a single copy of the origin, and always return this copy when the origin is required. Let modify our Point class so that it creates a single copy of the origin and returns the same copy every time the origin is required. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 final class Point { private Point ( double x , double y ) { this . x = x ; this . y = y ; } private final static Point ORIGIN = new Point ( 0 , 0 ); public static Point of ( double x , double y ) { if ( x == 0 && y == 0 ) { return ORIGIN ; } return new Point ( x , y ); } : } We made a few changes in the above: We made the constructor for Point private so that one cannot call the constructor directly. We provide a class factory method named of for the client to create a Point instance. The of method returns the same instance ORIGIN every time Point.of(0, 0) is called. Such a design pattern is only safe when the class is immutable. Consider the mutable version of Point -- calling Point.of(0, 0).moveTo(1, 1) would change every reference to the origin to (1, 1), causing chaos in the code! Enabling Safe Sharing of Internals Immutable instances can also share their internals freely. Consider an immutable implementation of our Array<T> , called ImmutableArray<T> . Let's start with a simple version first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // version 0.1 final class ImmutableArray < T > { private final T [] array ; // Only items of type T goes into the array. @SafeVarargs public static < T > ImmutableArray < T > of ( T ... items ) { return new ImmutableArray <> ( items ); } private ImmutableArray ( T [] a ) { this . array = a ; } public T get ( int index ) { return this . array [ index ] ; } } There are a few things to note here. Varargs The parameter to the class factory method of has the form T... items . The triple . notation is a Java syntax for a variable number of arguments of the same type ( T ). Often called varargs , this is just syntactic sugar for passing in an array of items to a method. We can then call of with a variable number of arguments, such as: 1 2 3 ImmutableArray < Integer > a ; a = ImmutableArray . of ( 1 , 2 , 3 ); a = ImmutableArray . of ( 1 , 2 , 3 , 4 , 5 ); @SafeVarargs Since the varargs is just an array, and array and generics do not mix well in Java, the compiler would throw us an unchecked warning. In this instance, however, we know that our code is safe because we never put anything other than items of type T into the array. We can use the @SafeVarargs annotation to tell the compiler that we know what we are doing and this varargs is safe. Notice that we removed the set method and there is no other way an external client can modify the array once it is created. Now, suppose that we wish to support a subarray method, that returns a new array containing only a range of elements in the original array. It behaves as follows: 1 2 3 4 5 ImmutableArray < Integer > a = ImmutableArray . of ( 10 , 20 , 30 , 40 , 50 , 60 ); ImmutableArray < Integer > b = a . subarray ( 2 , 4 ); // b is [30, 40, 50] b . get ( 0 ) // returns 30 ImmutableArray < Integer > c = b . subarray ( 1 , 2 ); // c is [40, 50] c . get ( 1 ) // returns 50 A typical way to implement subarray is to allocate a new T[] and copy the elements over. This operation can be expensive if our ImmutableArray has millions of elements. But, since our class is immutable and the internal field array is guaranteed not to mutate, we can safely let b and c refer to the same array from a , and only store the starting and ending index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ImmutableArray < T > { private final int start ; private final int end ; private final T [] array ; @SafeVarargs public static < T > ImmutableArray < T > of ( T ... items ) { return new ImmutableArray <> ( items , 0 , items . length - 1 ); } private ImmutableArray ( T [] a , int start , int end ) { this . start = start ; this . end = end ; this . array = a ; } public T get ( int index ) { if ( index < 0 || this . start + index > this . end ) { throw new IllegalArgumentException ( \"Index out of bound\" ); } return this . array [ this . start + index ] ; } public ImmutableArray < T > subarray ( int start , int end ) { return new ImmutableArray <> ( this . array , this . start + start , this . start + end ); } } Enabling Safe Concurrent Execution We will explore concurrent execution of code towards the end of the module, but making our classes immutable goes a long way in reducing bugs related to concurrent execution. Without going into details here (you will learn the details later), concurrent programming allows multiple threads of code to run in an interleaved fashion, in an arbitrary interleaving order. If we have complex code that is difficult to debug to begin with, imagine having code where we have to ensure its correctness regardless of how the execution interleaves! Immutability helps us ensure that regardless of how the code interleaves, our objects remain unchanged.","title":"25. Immutability"},{"location":"25-immutability.html#unit-25-immutability","text":"So far in this class, we have been focusing on three ways of dealing with software complexity: by encapsulating and hiding the complexity behind abstraction barriers, by using a language with a strong type system and adhering to the subtyping substitution principle, and applying the abstraction principles and reusing code written as functions, classes, and generics types. Another useful strategy to reduce bugs when code complexity increases is to avoid change altogether. This can be done by making our classes immutable . we create an instance of an immutable class, the instance cannot have any visible changes outside its abstraction barrier . This means that every call of the instance's method must behave the same way throughout the lifetime of the instance. There are many advantages of why we want to make our class immutable when possible. To start, let's revisit a common bug due to aliasing. Recall the following example from Unit 9 , where we create two circles c1 and c2 centered at the origin (0, 0). 1 2 3 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); Let's say that we have the moveTo method in both Circle and Point , to move the circle and point respectively. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Point { private double x ; private double y ; : public void moveTo ( double x , double y ) { this . x = x ; this . y = y ; } } class Circle { private Point c ; private double r ; public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } : public void moveTo ( double x , double y ) { c . moveTo ( x , y ); } } Suppose we want to move c1 and only c1 to be centered at (1,1). 1 c1 . moveTo ( 1 , 1 ); The line of code above surprisingly moved the center of both c1 and c2 , due to both circles c1 and c2 sharing the same point. We have explored a solution below: 1 2 3 4 5 6 7 Point p1 = new Point ( 0 , 0 ); Circle c1 = new Circle ( p1 , 1 ); Point p2 = new Point ( 0 , 0 ); Circle c2 = new Circle ( p2 , 4 ); c1 . moveTo ( 1 , 1 ); This approach avoids sharing references by creating copies of our points so that no two references point to the same instance, avoiding aliasing altogether. This fix, however, comes with extra costs in computational resources as the number of objects may proliferate. Let's now see how immutability can help us resolve our problem.","title":"Unit 25: Immutability"},{"location":"25-immutability.html#immutable-points-and-circles","text":"Let's start by making our Point class immutable. We start by making the fields final to signal our intention that we do not intend to change them. Now that the x and y cannot be changed, to move a point, we shouldn't mutate the fields x and y anymore. Instead, we return a new Point instance, as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 final class Point { final private double x ; final private double y ; public Point ( double x , double y ) { this . x = x ; this . y = y ; } public Point moveTo ( double x , double y ) { return new Point ( x , y ); } : @Override public String toString () { return \"(\" + this . x + \",\" + this . y + \")\" ; } } Note that, to avoid (likely malicious or ignorant) subclasses of Point overriding the methods to make it appears that the point has mutated, it is recommended that we declare immutable classes as final to disallow inheritance. Now, let's make Circle immutable: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 final class Circle { final private Point c ; final private double r ; public Circle ( Point c , double r ) { this . c = c ; this . r = r ; } : public Circle moveTo ( double x , double y ) { return new Circle ( c . moveTo ( x , y ), r ); } } With both Point and Circle immutable, we can be sure that once an instance is created, it remains unchanged (outside the abstraction barrier): 1 2 3 4 Point p = new Point ( 0 , 0 ); Circle c1 = new Circle ( p , 1 ); Circle c2 = new Circle ( p , 4 ); c1 . moveTo ( 1 , 1 ); // c1 remains unchanged To update the variable c1 , we need to explicitly reassign it. 1 c1 = c1 . moveTo ( 1 , 1 ); Now, c1 moves to a new location, but c2 remains unchanged. Compare our new immutable approach to the two approaches above. The first shares all the references and is bug-prone. The second creates a new copy of the instance every time and is resource-intensive. Our third approach, using immutable classes, allows us to share all the references until we need to modify the instance, in which case we make a copy. Such a copy-on-write semantic allows us to avoid aliasing bugs without creating excessive copies of objects.","title":"Immutable Points and Circles"},{"location":"25-immutability.html#advantages-of-being-immutable","text":"We have seen how making our classes immutable helps us remove the risk of potential bugs when we use composition and aliasing. Immutability has other advantages as well.","title":"Advantages of Being Immutable"},{"location":"25-immutability.html#ease-of-understanding","text":"Code written with immutable objects is easier to reason with and easier to understand. Suppose we create a Circle and assign it to a local variable: 1 Circle c = new Circle ( new Point ( 0 , 0 ), 8 ); We pass c around to many other methods. These other methods may invoke c 's methods; we may invoke c 's methods locally as well. But, despite putting c through so much, unless we have explicitly reassigned c , we can guarantee that c is still a circle centered at (0,0) with a radius of 8. This immutable property makes it significantly easier to read, understand, and debug our code. Without this property, we have to trace through all the methods that we pass c to, and each call of c 's methods to make sure that none of these codes modifies c .","title":"Ease of Understanding"},{"location":"25-immutability.html#enabling-safe-sharing-of-objects","text":"Making a class immutable allows us to safely share instances of the class and therefore reducing the need to create multiple copies of the same object. For instance, the origin (0, 0) is commonly used. If the instance is immutable, we can just create and cache a single copy of the origin, and always return this copy when the origin is required. Let modify our Point class so that it creates a single copy of the origin and returns the same copy every time the origin is required. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 final class Point { private Point ( double x , double y ) { this . x = x ; this . y = y ; } private final static Point ORIGIN = new Point ( 0 , 0 ); public static Point of ( double x , double y ) { if ( x == 0 && y == 0 ) { return ORIGIN ; } return new Point ( x , y ); } : } We made a few changes in the above: We made the constructor for Point private so that one cannot call the constructor directly. We provide a class factory method named of for the client to create a Point instance. The of method returns the same instance ORIGIN every time Point.of(0, 0) is called. Such a design pattern is only safe when the class is immutable. Consider the mutable version of Point -- calling Point.of(0, 0).moveTo(1, 1) would change every reference to the origin to (1, 1), causing chaos in the code!","title":"Enabling Safe Sharing of Objects"},{"location":"25-immutability.html#enabling-safe-sharing-of-internals","text":"Immutable instances can also share their internals freely. Consider an immutable implementation of our Array<T> , called ImmutableArray<T> . Let's start with a simple version first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // version 0.1 final class ImmutableArray < T > { private final T [] array ; // Only items of type T goes into the array. @SafeVarargs public static < T > ImmutableArray < T > of ( T ... items ) { return new ImmutableArray <> ( items ); } private ImmutableArray ( T [] a ) { this . array = a ; } public T get ( int index ) { return this . array [ index ] ; } } There are a few things to note here. Varargs The parameter to the class factory method of has the form T... items . The triple . notation is a Java syntax for a variable number of arguments of the same type ( T ). Often called varargs , this is just syntactic sugar for passing in an array of items to a method. We can then call of with a variable number of arguments, such as: 1 2 3 ImmutableArray < Integer > a ; a = ImmutableArray . of ( 1 , 2 , 3 ); a = ImmutableArray . of ( 1 , 2 , 3 , 4 , 5 ); @SafeVarargs Since the varargs is just an array, and array and generics do not mix well in Java, the compiler would throw us an unchecked warning. In this instance, however, we know that our code is safe because we never put anything other than items of type T into the array. We can use the @SafeVarargs annotation to tell the compiler that we know what we are doing and this varargs is safe. Notice that we removed the set method and there is no other way an external client can modify the array once it is created. Now, suppose that we wish to support a subarray method, that returns a new array containing only a range of elements in the original array. It behaves as follows: 1 2 3 4 5 ImmutableArray < Integer > a = ImmutableArray . of ( 10 , 20 , 30 , 40 , 50 , 60 ); ImmutableArray < Integer > b = a . subarray ( 2 , 4 ); // b is [30, 40, 50] b . get ( 0 ) // returns 30 ImmutableArray < Integer > c = b . subarray ( 1 , 2 ); // c is [40, 50] c . get ( 1 ) // returns 50 A typical way to implement subarray is to allocate a new T[] and copy the elements over. This operation can be expensive if our ImmutableArray has millions of elements. But, since our class is immutable and the internal field array is guaranteed not to mutate, we can safely let b and c refer to the same array from a , and only store the starting and ending index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class ImmutableArray < T > { private final int start ; private final int end ; private final T [] array ; @SafeVarargs public static < T > ImmutableArray < T > of ( T ... items ) { return new ImmutableArray <> ( items , 0 , items . length - 1 ); } private ImmutableArray ( T [] a , int start , int end ) { this . start = start ; this . end = end ; this . array = a ; } public T get ( int index ) { if ( index < 0 || this . start + index > this . end ) { throw new IllegalArgumentException ( \"Index out of bound\" ); } return this . array [ this . start + index ] ; } public ImmutableArray < T > subarray ( int start , int end ) { return new ImmutableArray <> ( this . array , this . start + start , this . start + end ); } }","title":"Enabling Safe Sharing of Internals"},{"location":"25-immutability.html#enabling-safe-concurrent-execution","text":"We will explore concurrent execution of code towards the end of the module, but making our classes immutable goes a long way in reducing bugs related to concurrent execution. Without going into details here (you will learn the details later), concurrent programming allows multiple threads of code to run in an interleaved fashion, in an arbitrary interleaving order. If we have complex code that is difficult to debug to begin with, imagine having code where we have to ensure its correctness regardless of how the execution interleaves! Immutability helps us ensure that regardless of how the code interleaves, our objects remain unchanged.","title":"Enabling Safe Concurrent Execution"},{"location":"26-nested-classes.html","text":"Unit 26: Nested Class So far, we have defined a class only at the \"top-level\" of our program. Java allows us to define a class within another class, or within a method. Nested Class A nested class is a class defined within another containing class. For example, the following declaration declares a private nested class named B within the class A . 1 2 3 4 5 class A { private class B { : } } Nested classes are used to group logically relevant classes together. Typically, a nested class is tightly coupled with the container class and would have no use outside of the container class. Nested classes can be used to encapsulate information within a container class, for instance, when the implementation of the container class becomes too complex. As such, it is useful for \"helper\" classes that serve specific purposes. A nested class is a field of the containing class and can access fields and methods of the container class, including those declared as private . We can keep the nested class within the abstraction barrier by declaring the nested class as private if there is no need for it to be exposed to the client outside the barrier. Since the nested class can access the private fields of the container class, we should introduce a nested class only if the nested class belongs to the same encapsulation as the container class. Otherwise, the container class would leak its implementation details to the nested class. Take the HashMap<K,V> class for instance. The implementation of HashMap<K,V> contains several nested classes, including HashIterator , which implement an Iterator<E> interface for iterating through the key and value pairs in the map, and an Entry<K,V> class, which encapsulates a key-value pair in the map. Some of these classes are declared private if they are only used within the HashMap<K,V> class. Example from CS2030S This Semester We can take another example from your labs on shop simulation. In one of many possible designs, the subclasses of Event : ArrivalEvent , DepartureEvent , etc. are not used anywhere outside of ShopSimulation . They can be safely encapsulated within ShopSimulation as inner classes, so that these classes can access the fields within the ShopSimulation class, simplifying their implementation. A nested class can be either static or non-static. Just like static fields and static methods, a static nested class is associated with the containing class , NOT an instance . So, it can only access static fields and static methods of the containing class. A non-static nested class , on the other hand, can access all fields and methods of the containing class. A non-static nested class is also known as an inner class . The example below shows a container class A with two nested classes, a non-static inner class B , and a static nested class C . B can access instance fields, instance methods, class fields, and class methods in A . C can only access the class fields and class methods in A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A { private int x ; static int y ; class B { void foo () { x = 1 ; // accessing x from A is OK y = 1 ; // accessing y from A is OK } } static class C { void bar () { x = 1 ; // accessing x from A is not OK since C is static y = 1 ; // accessing y is OK } } } Recall that we recommend that all access to instance fields be done through the this reference. In the example above, however, we can't access this.x from within B . 1 2 3 4 5 6 7 8 9 class A { private int x ; class B { void foo () { this . x = 1 ; // error } } } Since this.x is called within a method of B , this would refer to the instance of B , rather than the instance of A . Java has a piece of syntax called qualified this to resolve this. A qualified this reference is prefixed with the enclosing class name, to differentiate between the this of the inner class and the this of the enclosing class. In the example above, we can access x from A through the A.this reference. 1 2 3 4 5 6 7 8 9 class A { private int x ; class B { void foo () { A . this . x = 1 ; // ok } } } Local Class We can also declare a class within a function, just like a local variable. To motivate this, let's consider how one would use the java.util.Comparator interface. The Comparator interface allows us to specify how to compare two elements, by implementing this interface with a customized compare() method. compare(o1,o2) should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise. Suppose we have a list of strings, and we want to sort them in the order of their length, we can write the following method: 1 2 3 4 5 6 7 8 9 10 void sortNames ( List < String > names ) { class NameComparator implements Comparator < String > { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } } names . sort ( new NameComparator ()); } This makes the code easier to read since we keep the definition of the class and its usage closer together. Classes like NameComparator that are declared inside a method (or to be more precise, inside a block of code between { and } ) is called a local class . Just like a local variable, a local class is scoped within the method. Like a nested class, a local class has access to the variables of the enclosing class through the qualified this reference. Further, it can access the local variables of the enclosing method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { int x = 1 ; void f () { int y = 1 ; class B { void g () { x = y ; // accessing x and y is OK. } } new B (). g (); } } Here, B is a local class defined in method f() . It has access to all the local variables accessible from within f , as well as the fields of its enclosing class. Variable Capture Recall that when a method returns, all local variables of the methods are removed from the stack. But, an instance of that local class might still exist. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 interface C { void g (); } class A { int x = 1 ; C f () { int y = 1 ; class B implements C { void g () { x = y ; // accessing x and y is OK. } } B b = new B (); return b ; } } Calling 1 2 3 A a = new A (); C b = a . f (); b . g (); will give us a reference to an object of type B now. But, if we call b.g() , what is the value of y ? For this reason, even though a local class can access the local variables in the enclosing method, the local class makes a copy of local variables inside itself. We say that a local class captures the local variables. Effectively final Variable captures can be confusing. Consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void sortNames ( List < String > names ) { boolean ascendingOrder = true ; class NameComparator implements Comparator < String > { public int compare ( String s1 , String s2 ) { if ( ascendingOrder ) return s1 . length () - s2 . length (); else return s2 . length () - s1 . length (); } } ascendingOrder = false ; names . sort ( new NameComparator ()); } Will sort sorts in ascending order or descending order? To avoid confusing code like this, Java only allows a local class to access variables that are explicitly declared final or implicitly final (or effectively final). An implicitly final variable does not change after initialization. Therefore, Java saves us from such a hair-pulling situation and disallows such code -- ascendingOrder is not effectively final so the code above does not compile. Variable Capture in Javascript Those of you who did CS1101S or otherwise familiar with Javascript might want to note that this is different from Javascript, which does not enforce the final/effectively final restriction in variable captures. Anonymous Class An anonymous class is one where you declare a class and instantiate it in a single statement. It's anonymous since We do not even have to give the class a name. 1 2 3 4 5 names . sort ( new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }); The example above removes the need to declare a class just to compare two strings. An anonymous class has the following format: new X (arguments) { body } , where: X is a class that the anonymous class extends or an interface that the anonymous class implements. X cannot be empty. This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time. Furthermore, an anonymous class cannot implement more than one interface. arguments are the arguments that you want to pass into the constructor of the anonymous class. If the anonymous class is extending an interface, then there is no constructor, but we still need () . body is the body of the class as per normal, except that we cannot have a constructor for an anonymous class. The syntax might look overwhelming at the beginning, but we can also write it as: 1 2 3 4 5 6 Comparator < String > cmp = new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }; names . sort ( cmp ); Line 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a { .. } body. An anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local classes applies.","title":"26. Nested Classes"},{"location":"26-nested-classes.html#unit-26-nested-class","text":"So far, we have defined a class only at the \"top-level\" of our program. Java allows us to define a class within another class, or within a method.","title":"Unit 26: Nested Class"},{"location":"26-nested-classes.html#nested-class","text":"A nested class is a class defined within another containing class. For example, the following declaration declares a private nested class named B within the class A . 1 2 3 4 5 class A { private class B { : } } Nested classes are used to group logically relevant classes together. Typically, a nested class is tightly coupled with the container class and would have no use outside of the container class. Nested classes can be used to encapsulate information within a container class, for instance, when the implementation of the container class becomes too complex. As such, it is useful for \"helper\" classes that serve specific purposes. A nested class is a field of the containing class and can access fields and methods of the container class, including those declared as private . We can keep the nested class within the abstraction barrier by declaring the nested class as private if there is no need for it to be exposed to the client outside the barrier. Since the nested class can access the private fields of the container class, we should introduce a nested class only if the nested class belongs to the same encapsulation as the container class. Otherwise, the container class would leak its implementation details to the nested class. Take the HashMap<K,V> class for instance. The implementation of HashMap<K,V> contains several nested classes, including HashIterator , which implement an Iterator<E> interface for iterating through the key and value pairs in the map, and an Entry<K,V> class, which encapsulates a key-value pair in the map. Some of these classes are declared private if they are only used within the HashMap<K,V> class. Example from CS2030S This Semester We can take another example from your labs on shop simulation. In one of many possible designs, the subclasses of Event : ArrivalEvent , DepartureEvent , etc. are not used anywhere outside of ShopSimulation . They can be safely encapsulated within ShopSimulation as inner classes, so that these classes can access the fields within the ShopSimulation class, simplifying their implementation. A nested class can be either static or non-static. Just like static fields and static methods, a static nested class is associated with the containing class , NOT an instance . So, it can only access static fields and static methods of the containing class. A non-static nested class , on the other hand, can access all fields and methods of the containing class. A non-static nested class is also known as an inner class . The example below shows a container class A with two nested classes, a non-static inner class B , and a static nested class C . B can access instance fields, instance methods, class fields, and class methods in A . C can only access the class fields and class methods in A . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A { private int x ; static int y ; class B { void foo () { x = 1 ; // accessing x from A is OK y = 1 ; // accessing y from A is OK } } static class C { void bar () { x = 1 ; // accessing x from A is not OK since C is static y = 1 ; // accessing y is OK } } } Recall that we recommend that all access to instance fields be done through the this reference. In the example above, however, we can't access this.x from within B . 1 2 3 4 5 6 7 8 9 class A { private int x ; class B { void foo () { this . x = 1 ; // error } } } Since this.x is called within a method of B , this would refer to the instance of B , rather than the instance of A . Java has a piece of syntax called qualified this to resolve this. A qualified this reference is prefixed with the enclosing class name, to differentiate between the this of the inner class and the this of the enclosing class. In the example above, we can access x from A through the A.this reference. 1 2 3 4 5 6 7 8 9 class A { private int x ; class B { void foo () { A . this . x = 1 ; // ok } } }","title":"Nested Class"},{"location":"26-nested-classes.html#local-class","text":"We can also declare a class within a function, just like a local variable. To motivate this, let's consider how one would use the java.util.Comparator interface. The Comparator interface allows us to specify how to compare two elements, by implementing this interface with a customized compare() method. compare(o1,o2) should return 0 if the two elements are equals, a negative integer if o1 is \"less than\" o2, and a positive integer otherwise. Suppose we have a list of strings, and we want to sort them in the order of their length, we can write the following method: 1 2 3 4 5 6 7 8 9 10 void sortNames ( List < String > names ) { class NameComparator implements Comparator < String > { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } } names . sort ( new NameComparator ()); } This makes the code easier to read since we keep the definition of the class and its usage closer together. Classes like NameComparator that are declared inside a method (or to be more precise, inside a block of code between { and } ) is called a local class . Just like a local variable, a local class is scoped within the method. Like a nested class, a local class has access to the variables of the enclosing class through the qualified this reference. Further, it can access the local variables of the enclosing method. For example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class A { int x = 1 ; void f () { int y = 1 ; class B { void g () { x = y ; // accessing x and y is OK. } } new B (). g (); } } Here, B is a local class defined in method f() . It has access to all the local variables accessible from within f , as well as the fields of its enclosing class.","title":"Local Class"},{"location":"26-nested-classes.html#variable-capture","text":"Recall that when a method returns, all local variables of the methods are removed from the stack. But, an instance of that local class might still exist. Consider the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 interface C { void g (); } class A { int x = 1 ; C f () { int y = 1 ; class B implements C { void g () { x = y ; // accessing x and y is OK. } } B b = new B (); return b ; } } Calling 1 2 3 A a = new A (); C b = a . f (); b . g (); will give us a reference to an object of type B now. But, if we call b.g() , what is the value of y ? For this reason, even though a local class can access the local variables in the enclosing method, the local class makes a copy of local variables inside itself. We say that a local class captures the local variables.","title":"Variable Capture"},{"location":"26-nested-classes.html#effectively-final","text":"Variable captures can be confusing. Consider the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void sortNames ( List < String > names ) { boolean ascendingOrder = true ; class NameComparator implements Comparator < String > { public int compare ( String s1 , String s2 ) { if ( ascendingOrder ) return s1 . length () - s2 . length (); else return s2 . length () - s1 . length (); } } ascendingOrder = false ; names . sort ( new NameComparator ()); } Will sort sorts in ascending order or descending order? To avoid confusing code like this, Java only allows a local class to access variables that are explicitly declared final or implicitly final (or effectively final). An implicitly final variable does not change after initialization. Therefore, Java saves us from such a hair-pulling situation and disallows such code -- ascendingOrder is not effectively final so the code above does not compile. Variable Capture in Javascript Those of you who did CS1101S or otherwise familiar with Javascript might want to note that this is different from Javascript, which does not enforce the final/effectively final restriction in variable captures.","title":"Effectively final"},{"location":"26-nested-classes.html#anonymous-class","text":"An anonymous class is one where you declare a class and instantiate it in a single statement. It's anonymous since We do not even have to give the class a name. 1 2 3 4 5 names . sort ( new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }); The example above removes the need to declare a class just to compare two strings. An anonymous class has the following format: new X (arguments) { body } , where: X is a class that the anonymous class extends or an interface that the anonymous class implements. X cannot be empty. This syntax also implies an anonymous class cannot extend another class and implement an interface at the same time. Furthermore, an anonymous class cannot implement more than one interface. arguments are the arguments that you want to pass into the constructor of the anonymous class. If the anonymous class is extending an interface, then there is no constructor, but we still need () . body is the body of the class as per normal, except that we cannot have a constructor for an anonymous class. The syntax might look overwhelming at the beginning, but we can also write it as: 1 2 3 4 5 6 Comparator < String > cmp = new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }; names . sort ( cmp ); Line 1 above looks just like what we do when we instantiate a class, except that we are instantiating an interface with a { .. } body. An anonymous class is just like a local class, it captures the variables of the enclosing scope as well -- the same rules to variable access as local classes applies.","title":"Anonymous Class"},{"location":"27-functions.html","text":"Unit 27: Side Effect-Free Programming Learning Objectives After this lecture, students should be familiar with: the concept of functions as side-effect-free programming constructs and its relation to functions in mathematics. understand the importance of writing code that is free of side effects how functions can be first-class citizens in Java through using local anonymous class how we can succinctly use a lambda expression or a method reference in place of using local anonymous class how we can use currying to generalize to functions with higher arity how we can create a closure with lambda and environment capture Functions Recall that, a function, in mathematics, refers to a mapping from a set of inputs ( domain ) \\(X\\) to a set of output values ( codomain ) \\(Y\\) . We write \\(f: X \\rightarrow Y\\) . Every input in the domain must map to exactly one output but multiple inputs can map to the same output. Not all values in the codomain need to be mapped. We know how to deal with mathematical functions very well. There are certain rules that we follow when we reason about functions. For instance, suppose we have an unknown \\(x\\) and a function \\(f\\) , we know that applying \\(f\\) on \\(x\\) , i.e., \\(f(x)\\) does not change the value of \\(x\\) , or any other unknowns \\(y\\) , \\(z\\) , etc. We say that mathematical functions have no side effects . It simply computes and returns the value. Another property of mathematical function is referential transparency . Let \\(f(x) = a\\) . Then in every formula that \\(f(x)\\) appears in, we can safely replace occurances of \\(f(x)\\) with \\(a\\) . Conversely, everywhere \\(a\\) appears, we can replace it with \\(f(x)\\) . We can be guarantee that the resulting formulas are still equivalent. These two fundamental properties of mathematical functions allow us to solve equations, prove theorems, and reason about mathematical objects rigorously. Unfortunately, we can't always reason about our program the same way as we reason about mathematical functions. For instance, consider the line: 1 a.get(0) where a is an instance of Array<T> . Suppose we know that a.get(0) is 5 for some a . When we reason about the behavior of our code, we cannot replace (mentally) every invocation of a.get(0) with the value 5. This is because the array a may not be immutable and therefore a.get(0) cannot be guaranteed to be the same. The reserve should be true as well. Suppose we have a variable 1 T t = a.get(0); Then everywhere in our code where we use t , we should be able to replace it with a.get(0) , and the behavior of the code should still be the same. This behavior is only guaranteed if a.get(0) has no side effects (such as modifying a field or print something to the standard output). To be able to reason about our code using the mathematical reasoning techniques we are familiar with, it is important to write our code as if we are writing mathematical functions -- our methods should be free of side effects and our code should be referentially transparent. Our program is then just a sequence of functions, chained and composed together. To achieve this, functions need to be a first class citizen in our program, so that we can assign functions to a variable, pass it as parameters, return a function from another function, etc, just like an integer. Pure Functions Ideally, methods in our programs should behave the same as functions in mathematics. Given an input, the function computes and returns an output. A pure function does nothing else -- it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments. That is, a pure function does not cause any side effect . Here are two examples of pure functions: 1 2 3 4 5 6 7 int square ( int i ) { return i * i ; } int add ( int i , int j ) { return i + j ; } and some examples of non-pure functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int div ( int i , int j ) { return i / j ; // may throw an exception } int incrCount ( int i ) { return this . count + i ; // assume that count is not final. // this may give diff results for the same i. } void incrCount ( int i ) { this . count += i ; // does not return a value // and has side effects on count } int addToQ ( Queue < Integer > queue , int i ) { queue . enq ( i ); // has side effects on queue } A pure function must also be deterministic. Given the same input, the function must produce the same output, every single time . This deterministic property ensures referential transparency. In the OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance. Such methods are not pure functions. On the other hand, if our class is immutable, then its methods must not have side effects and thus is pure. In computer science, we refer to the style of programming where we build a program from pure functions as functional programming (FP). Examples of functional programming languages include Haskell, OCaml, Erlang, Clojure, F#, and Elixir. Many modern programming languages, such as Java, C++, Python, Rust, Swift, support this style of programming. As these languages are not designed to be functional, we cannot build a program from only pure functions. Java, for instance, is still an OO language at its core. As such, we will refer to this style as functional-style programming . We won't be able to write code consists of only pure functions in Java, but we can write methods that has no side effects and objects that are immutable, as much as possible. Function as First-Class Citizen in Java Let's explore functions as a first-class citizen in Java. We have seen some examples of this when we use the Comparator interface. 1 2 3 4 5 6 7 8 void sortNames ( List < String > names ) { Comparator < String > cmp = new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }; names . sort ( cmp ); } First, let's take a moment to appreciate the beauty of the List::sort method. We can use this method to sort items of any type , in any defined order . We achieve the generality of types with generics, and the generality of sorting order through passing in the comparison function as a parameter. The latter the need to write one sorting method for every possible sorting order for a list of strings, ( sortAlphabeticallyIncreasing , sortByLengthDecreasing , etc..) The comparison function here is implemented as a method in an anonymous class that implements an interface . We can think of an instance of this anonymous class as the function. Since a function is now just an instance of an object in Java, we can pass it around, return it from a function, and assign it to a variable, just like any other reference type. Let's look at another example. Consider the following interface: 1 2 3 interface Transformer < T , R > { R transform ( T t ); } Transformer<T, R> is a generic interface with two type parameters: T is the type of the input, R is the type of the result. It has one abstract method R transform(T t) that applies the function to a given argument. We can use this interface to write any function that takes in a value and return another value. (Java has a similar interface called, unsurprisingly, [java.util.function.Function<T, R>](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html) ). For instance, a function that computes the square of an integer can be written as: 1 2 3 4 5 6 new Transformer < Integer , Integer > () { @Override public Integer transform ( Integer x ) { return x * x ; } }; We can write a method chain that composes two given computations together and return the new computation: 1 2 3 4 5 6 7 8 // Use of PECS left as an exercise < T , R , S > Transformer < T , R > chain ( Transformer < T , S > t1 , Transformer < S , R > t2 ) { return new Transformer < T , R > () { public R transform ( T value ) { return t2 . transform ( t1 . transform ( value )); } } } Lambda Expression While we have achieved functions as first-class citizens in Java, the code is verbose and ugly. Fortunately, there is a much cleaner syntax to write functions that applies to interfaces with a single abstract method. An interface in Java with only one abstract method is called a functional interface . Both Comparator and Transformer are functional interfaces. It is recommended that, if a programmer intends an interface to be a functional interface, they should annotate the interface with the @FunctionalInterface annotation. 1 2 3 4 @FunctionalInterface interface Transformer < T , R > { R transform ( T t ); } A key advantage of a functional interface is that there is no ambiguity about which method is being overridden by an implementing subclass. For instance, consider: 1 2 3 4 5 6 7 8 9 10 11 12 Transformer < Integer , Integer > square = new Transformer <> () { @Override public Integer transform ( Integer x ) { return x * x ; } }; Transformer < Integer , Integer > incr = new Transformer <> () { @Override public Integer transform ( Integer x ) { return x + 1 ; } }; You can see that there is much boilerplate code in the two functions above. Since we are assigning it to a variable of type Transformer interface, we don't have to write new Transformer<>() { .. } . Since there is only one abstract method to overwrite, we don't have to write @Override public Integer transform(..) { .. } . What remain after we eliminate the obvious and biolerplate are (i) the parameter Integer x and (ii) the body of transform , which is { return x * x; } . We can use the Java arrow notation -> to now link the parameter and the body: 1 2 Transformer < Integer , Integer > square = ( Integer x ) -> { return x * x ; }; Transformer < Integer , Integer > incr = ( Integer x ) -> { return x + 1 ; }; You might notice that the type of the parameter is redundant as well since the type argument to Transformer already tells us this function takes in an Integer . We can further simplify it to: 1 2 Transformer < Integer , Integer > square = ( x ) -> { return x * x ; }; Transformer < Integer , Integer > incr = ( x ) -> { return x + 1 ; }; or simply: 1 2 Transformer < Integer , Integer > square = x -> { return x * x ; }; Transformer < Integer , Integer > incr = x -> { return x + 1 ; }; where there is only one parameter. Since the body has only a single return statement, we can simplify it further: 1 2 Transformer < Integer , Integer > square = x -> x * x ; Transformer < Integer , Integer > incr = x -> x + 1 ; Now, that's much better! The expressions above, including x -> x * x , are called lambda expressions . You can recognize one by the use of -> . The left-hand side lists the parameters (use () if there is no parameter), while the right-hand side is the computation. We do not need the type in cases where Java can infer the type, nor need the return keyword and the curly brackets when there is only a single return statement. lambda Alonzo Church invented lambda calculus ( \\(\\lambda\\) -calculus) in 1936, before electronic computers, as a way to express computation. In \\(\\lambda\\) -calculus, all functions are anonymous. The term lambda expression originated from there. Method Reference Lambda expression is useful for specifying a new anonymous method. Sometimes, we want to use an existing method as a first-class citizen instead. Recall the distanceTo method in Point , which takes in another point as a parameter and returns the distance between this point and the given point. 1 2 3 4 5 6 class Point { : public double distanceTo ( Point p ) { : } } We can write our Transformer like this using an anonymous class: 1 2 3 4 5 6 7 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = new Transformer <> () { @Override public Double transform ( Point p ) { return origin . distanceTo ( p ); } } or using a lambda expression: 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = p -> origin . distanceTo ( p ); but since distanceTo takes in one parameter and returns a value, it already fits as a transformer, and we can write it as: 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = origin :: distanceTo ; The double-colon notation :: is used to specify a method reference . We can use method references to refer to a (i) static method in a class, (ii) instance method of a class or interface, (iii) constructor of a class. Here are some examples (and their equivalent lambda expression) 1 2 3 4 Box: : of // x -> Box.of(x) Box: : new // x -> new Box(x) x: : compareTo // y -> x.compareTo(y) A: : foo // (x, y) -> x.foo(y) or (x, y) -> A.foo(x,y) The last example shows that the same method reference expression can be interpreted in two different ways. The actual interpretation depends on how many parameters foo takes and whether foo is a class method or an instance method. When compiling, Java searches for the matching method, performing type inferences to find the method that matches the given method reference. A compilation error will be thrown if there are multiple matches or if there is ambiguity in which method matches. Curried Functions Mathematically, a function takes in only one value and returns one value (e.g., square above). In programming, we often need to write functions that take in more than one argument (e.g., add above). Even though Transformer only supports function with a single parameter, we can build functions that take in multiple arguments. Let's look at this mathematically first. Consider a binary function \\(f: (X, Y) \\rightarrow Z\\) . We can introduce \\(F\\) as a set of all functions \\(f': Y \\rightarrow Z\\) , and rewrite \\(f\\) as \\(f: X \\rightarrow F\\) , of \\(f: X \\rightarrow Y \\rightarrow Z\\) . A trivial example of this is the add method that adds two int values. 1 2 3 int add ( int x , int y ) { return x + y ; } This can be written as 1 Transformer < Integer , Transformer < Integer , Integer >> add = x -> y -> ( x + y ); To calculate 1 + 1, we call 1 add . transform ( 1 ). transform ( 1 ); Let's break it down a little, add is a function that takes in an Integer object and returns a unary Function over Integer . So add.transform(1) returns the function y -> 1 + y . We could assign this to a variable: 1 Transformer < Integer , Integer > incr = add . transform ( 1 ); Note that add is no longer a function that takes two arguments and returns a value. It is a higher-order function that takes in a single argument and returns another function. The technique that translates a general \\(n\\) -ary function to a sequence of \\(n\\) unary functions is called currying . After currying, we have a sequence of curried functions. Curry Currying is not related to food but rather is named after computer scientist Haskell Curry, who popularized the technique. How is currying useful? Consider add(1, 1) -- we have to have both arguments available at the same time to compute the function. With currying, we no longer have to. We can evaluate the different arguments at a different time (as incr example above). This feature is useful in cases where some arguments are not available until later. We can partially apply a function first. This is also useful if one of the arguments does not change often, or is expensive to compute. We can save the partial results as a function and continue applying later. We can dynamically create functions as needed, save them, and invoke them later. Lambda as Closure In the example, we showed earlier, 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = origin :: distanceTo ; the variable origin is captured by the lambda expression dist . Just like in local and anonymous classes, a captured variable must be either explicitly declared as final or is effectively final. A lambda expression stores more than just the function to invoke -- it also stores the data from the environment where it is defined. We call such a construct that stores a function together with the enclosing environment a closure . Being able to save the current execution environment, and then continue to compute it later, adds new power to how we can write our program. We can make our code cleaner with fewer parameters to pass around and less duplicated code. We can separate the logic to do different tasks in a different part of our program easier. We will see more examples of this later.","title":"27. Functions"},{"location":"27-functions.html#unit-27-side-effect-free-programming","text":"","title":"Unit 27: Side Effect-Free Programming"},{"location":"27-functions.html#learning-objectives","text":"After this lecture, students should be familiar with: the concept of functions as side-effect-free programming constructs and its relation to functions in mathematics. understand the importance of writing code that is free of side effects how functions can be first-class citizens in Java through using local anonymous class how we can succinctly use a lambda expression or a method reference in place of using local anonymous class how we can use currying to generalize to functions with higher arity how we can create a closure with lambda and environment capture","title":"Learning Objectives"},{"location":"27-functions.html#functions","text":"Recall that, a function, in mathematics, refers to a mapping from a set of inputs ( domain ) \\(X\\) to a set of output values ( codomain ) \\(Y\\) . We write \\(f: X \\rightarrow Y\\) . Every input in the domain must map to exactly one output but multiple inputs can map to the same output. Not all values in the codomain need to be mapped. We know how to deal with mathematical functions very well. There are certain rules that we follow when we reason about functions. For instance, suppose we have an unknown \\(x\\) and a function \\(f\\) , we know that applying \\(f\\) on \\(x\\) , i.e., \\(f(x)\\) does not change the value of \\(x\\) , or any other unknowns \\(y\\) , \\(z\\) , etc. We say that mathematical functions have no side effects . It simply computes and returns the value. Another property of mathematical function is referential transparency . Let \\(f(x) = a\\) . Then in every formula that \\(f(x)\\) appears in, we can safely replace occurances of \\(f(x)\\) with \\(a\\) . Conversely, everywhere \\(a\\) appears, we can replace it with \\(f(x)\\) . We can be guarantee that the resulting formulas are still equivalent. These two fundamental properties of mathematical functions allow us to solve equations, prove theorems, and reason about mathematical objects rigorously. Unfortunately, we can't always reason about our program the same way as we reason about mathematical functions. For instance, consider the line: 1 a.get(0) where a is an instance of Array<T> . Suppose we know that a.get(0) is 5 for some a . When we reason about the behavior of our code, we cannot replace (mentally) every invocation of a.get(0) with the value 5. This is because the array a may not be immutable and therefore a.get(0) cannot be guaranteed to be the same. The reserve should be true as well. Suppose we have a variable 1 T t = a.get(0); Then everywhere in our code where we use t , we should be able to replace it with a.get(0) , and the behavior of the code should still be the same. This behavior is only guaranteed if a.get(0) has no side effects (such as modifying a field or print something to the standard output). To be able to reason about our code using the mathematical reasoning techniques we are familiar with, it is important to write our code as if we are writing mathematical functions -- our methods should be free of side effects and our code should be referentially transparent. Our program is then just a sequence of functions, chained and composed together. To achieve this, functions need to be a first class citizen in our program, so that we can assign functions to a variable, pass it as parameters, return a function from another function, etc, just like an integer.","title":"Functions"},{"location":"27-functions.html#pure-functions","text":"Ideally, methods in our programs should behave the same as functions in mathematics. Given an input, the function computes and returns an output. A pure function does nothing else -- it does not print to the screen, write to files, throw exceptions, change other variables, modify the values of the arguments. That is, a pure function does not cause any side effect . Here are two examples of pure functions: 1 2 3 4 5 6 7 int square ( int i ) { return i * i ; } int add ( int i , int j ) { return i + j ; } and some examples of non-pure functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int div ( int i , int j ) { return i / j ; // may throw an exception } int incrCount ( int i ) { return this . count + i ; // assume that count is not final. // this may give diff results for the same i. } void incrCount ( int i ) { this . count += i ; // does not return a value // and has side effects on count } int addToQ ( Queue < Integer > queue , int i ) { queue . enq ( i ); // has side effects on queue } A pure function must also be deterministic. Given the same input, the function must produce the same output, every single time . This deterministic property ensures referential transparency. In the OO paradigm, we commonly need to write methods that update the fields of an instance or compute values using the fields of an instance. Such methods are not pure functions. On the other hand, if our class is immutable, then its methods must not have side effects and thus is pure. In computer science, we refer to the style of programming where we build a program from pure functions as functional programming (FP). Examples of functional programming languages include Haskell, OCaml, Erlang, Clojure, F#, and Elixir. Many modern programming languages, such as Java, C++, Python, Rust, Swift, support this style of programming. As these languages are not designed to be functional, we cannot build a program from only pure functions. Java, for instance, is still an OO language at its core. As such, we will refer to this style as functional-style programming . We won't be able to write code consists of only pure functions in Java, but we can write methods that has no side effects and objects that are immutable, as much as possible.","title":"Pure Functions"},{"location":"27-functions.html#function-as-first-class-citizen-in-java","text":"Let's explore functions as a first-class citizen in Java. We have seen some examples of this when we use the Comparator interface. 1 2 3 4 5 6 7 8 void sortNames ( List < String > names ) { Comparator < String > cmp = new Comparator < String > () { public int compare ( String s1 , String s2 ) { return s1 . length () - s2 . length (); } }; names . sort ( cmp ); } First, let's take a moment to appreciate the beauty of the List::sort method. We can use this method to sort items of any type , in any defined order . We achieve the generality of types with generics, and the generality of sorting order through passing in the comparison function as a parameter. The latter the need to write one sorting method for every possible sorting order for a list of strings, ( sortAlphabeticallyIncreasing , sortByLengthDecreasing , etc..) The comparison function here is implemented as a method in an anonymous class that implements an interface . We can think of an instance of this anonymous class as the function. Since a function is now just an instance of an object in Java, we can pass it around, return it from a function, and assign it to a variable, just like any other reference type. Let's look at another example. Consider the following interface: 1 2 3 interface Transformer < T , R > { R transform ( T t ); } Transformer<T, R> is a generic interface with two type parameters: T is the type of the input, R is the type of the result. It has one abstract method R transform(T t) that applies the function to a given argument. We can use this interface to write any function that takes in a value and return another value. (Java has a similar interface called, unsurprisingly, [java.util.function.Function<T, R>](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html) ). For instance, a function that computes the square of an integer can be written as: 1 2 3 4 5 6 new Transformer < Integer , Integer > () { @Override public Integer transform ( Integer x ) { return x * x ; } }; We can write a method chain that composes two given computations together and return the new computation: 1 2 3 4 5 6 7 8 // Use of PECS left as an exercise < T , R , S > Transformer < T , R > chain ( Transformer < T , S > t1 , Transformer < S , R > t2 ) { return new Transformer < T , R > () { public R transform ( T value ) { return t2 . transform ( t1 . transform ( value )); } } }","title":"Function as First-Class Citizen in Java"},{"location":"27-functions.html#lambda-expression","text":"While we have achieved functions as first-class citizens in Java, the code is verbose and ugly. Fortunately, there is a much cleaner syntax to write functions that applies to interfaces with a single abstract method. An interface in Java with only one abstract method is called a functional interface . Both Comparator and Transformer are functional interfaces. It is recommended that, if a programmer intends an interface to be a functional interface, they should annotate the interface with the @FunctionalInterface annotation. 1 2 3 4 @FunctionalInterface interface Transformer < T , R > { R transform ( T t ); } A key advantage of a functional interface is that there is no ambiguity about which method is being overridden by an implementing subclass. For instance, consider: 1 2 3 4 5 6 7 8 9 10 11 12 Transformer < Integer , Integer > square = new Transformer <> () { @Override public Integer transform ( Integer x ) { return x * x ; } }; Transformer < Integer , Integer > incr = new Transformer <> () { @Override public Integer transform ( Integer x ) { return x + 1 ; } }; You can see that there is much boilerplate code in the two functions above. Since we are assigning it to a variable of type Transformer interface, we don't have to write new Transformer<>() { .. } . Since there is only one abstract method to overwrite, we don't have to write @Override public Integer transform(..) { .. } . What remain after we eliminate the obvious and biolerplate are (i) the parameter Integer x and (ii) the body of transform , which is { return x * x; } . We can use the Java arrow notation -> to now link the parameter and the body: 1 2 Transformer < Integer , Integer > square = ( Integer x ) -> { return x * x ; }; Transformer < Integer , Integer > incr = ( Integer x ) -> { return x + 1 ; }; You might notice that the type of the parameter is redundant as well since the type argument to Transformer already tells us this function takes in an Integer . We can further simplify it to: 1 2 Transformer < Integer , Integer > square = ( x ) -> { return x * x ; }; Transformer < Integer , Integer > incr = ( x ) -> { return x + 1 ; }; or simply: 1 2 Transformer < Integer , Integer > square = x -> { return x * x ; }; Transformer < Integer , Integer > incr = x -> { return x + 1 ; }; where there is only one parameter. Since the body has only a single return statement, we can simplify it further: 1 2 Transformer < Integer , Integer > square = x -> x * x ; Transformer < Integer , Integer > incr = x -> x + 1 ; Now, that's much better! The expressions above, including x -> x * x , are called lambda expressions . You can recognize one by the use of -> . The left-hand side lists the parameters (use () if there is no parameter), while the right-hand side is the computation. We do not need the type in cases where Java can infer the type, nor need the return keyword and the curly brackets when there is only a single return statement. lambda Alonzo Church invented lambda calculus ( \\(\\lambda\\) -calculus) in 1936, before electronic computers, as a way to express computation. In \\(\\lambda\\) -calculus, all functions are anonymous. The term lambda expression originated from there.","title":"Lambda Expression"},{"location":"27-functions.html#method-reference","text":"Lambda expression is useful for specifying a new anonymous method. Sometimes, we want to use an existing method as a first-class citizen instead. Recall the distanceTo method in Point , which takes in another point as a parameter and returns the distance between this point and the given point. 1 2 3 4 5 6 class Point { : public double distanceTo ( Point p ) { : } } We can write our Transformer like this using an anonymous class: 1 2 3 4 5 6 7 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = new Transformer <> () { @Override public Double transform ( Point p ) { return origin . distanceTo ( p ); } } or using a lambda expression: 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = p -> origin . distanceTo ( p ); but since distanceTo takes in one parameter and returns a value, it already fits as a transformer, and we can write it as: 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = origin :: distanceTo ; The double-colon notation :: is used to specify a method reference . We can use method references to refer to a (i) static method in a class, (ii) instance method of a class or interface, (iii) constructor of a class. Here are some examples (and their equivalent lambda expression) 1 2 3 4 Box: : of // x -> Box.of(x) Box: : new // x -> new Box(x) x: : compareTo // y -> x.compareTo(y) A: : foo // (x, y) -> x.foo(y) or (x, y) -> A.foo(x,y) The last example shows that the same method reference expression can be interpreted in two different ways. The actual interpretation depends on how many parameters foo takes and whether foo is a class method or an instance method. When compiling, Java searches for the matching method, performing type inferences to find the method that matches the given method reference. A compilation error will be thrown if there are multiple matches or if there is ambiguity in which method matches.","title":"Method Reference"},{"location":"27-functions.html#curried-functions","text":"Mathematically, a function takes in only one value and returns one value (e.g., square above). In programming, we often need to write functions that take in more than one argument (e.g., add above). Even though Transformer only supports function with a single parameter, we can build functions that take in multiple arguments. Let's look at this mathematically first. Consider a binary function \\(f: (X, Y) \\rightarrow Z\\) . We can introduce \\(F\\) as a set of all functions \\(f': Y \\rightarrow Z\\) , and rewrite \\(f\\) as \\(f: X \\rightarrow F\\) , of \\(f: X \\rightarrow Y \\rightarrow Z\\) . A trivial example of this is the add method that adds two int values. 1 2 3 int add ( int x , int y ) { return x + y ; } This can be written as 1 Transformer < Integer , Transformer < Integer , Integer >> add = x -> y -> ( x + y ); To calculate 1 + 1, we call 1 add . transform ( 1 ). transform ( 1 ); Let's break it down a little, add is a function that takes in an Integer object and returns a unary Function over Integer . So add.transform(1) returns the function y -> 1 + y . We could assign this to a variable: 1 Transformer < Integer , Integer > incr = add . transform ( 1 ); Note that add is no longer a function that takes two arguments and returns a value. It is a higher-order function that takes in a single argument and returns another function. The technique that translates a general \\(n\\) -ary function to a sequence of \\(n\\) unary functions is called currying . After currying, we have a sequence of curried functions. Curry Currying is not related to food but rather is named after computer scientist Haskell Curry, who popularized the technique. How is currying useful? Consider add(1, 1) -- we have to have both arguments available at the same time to compute the function. With currying, we no longer have to. We can evaluate the different arguments at a different time (as incr example above). This feature is useful in cases where some arguments are not available until later. We can partially apply a function first. This is also useful if one of the arguments does not change often, or is expensive to compute. We can save the partial results as a function and continue applying later. We can dynamically create functions as needed, save them, and invoke them later.","title":"Curried Functions"},{"location":"27-functions.html#lambda-as-closure","text":"In the example, we showed earlier, 1 2 Point origin = new Point ( 0 , 0 ); Transformer < Point , Double > dist = origin :: distanceTo ; the variable origin is captured by the lambda expression dist . Just like in local and anonymous classes, a captured variable must be either explicitly declared as final or is effectively final. A lambda expression stores more than just the function to invoke -- it also stores the data from the environment where it is defined. We call such a construct that stores a function together with the enclosing environment a closure . Being able to save the current execution environment, and then continue to compute it later, adds new power to how we can write our program. We can make our code cleaner with fewer parameters to pass around and less duplicated code. We can separate the logic to do different tasks in a different part of our program easier. We will see more examples of this later.","title":"Lambda as Closure"},{"location":"28-box-maybe.html","text":"Unit 28: Box and Maybe Learning Objectives After this lecture, students should appreciate: the generality of the class Box<T> and Maybe<T> how passing in functions as parameter can lead to highly general abstractions how Maybe<T> preserves the \"maybe null\" semantics over a reference type by internalizing checks for null Lambda as a Cross-Barrier State Manipulator Recall that every class has an abstraction barrier between the client and the implementer. The internal states of the class are heavily protected and hidden. The implementer selectively provides a set of methods to access and manipulate the internal states of instances. This approach allows the implementer to control what the client can and cannot do to the internal states. This is good if we want to build abstractions over specific entities such as shapes or data structures such as a stack, but it is not flexible enough to build general abstraction. Let's consider the following class: 1 2 3 class Box < T > { private T item ; } It is a box containing a single item of type T . Suppose that we want to keep the item hidden and we want to have certain rules and maintain some semantics about the use of the item . As such, we don't want to provide any setter or getter, so that the client may not break our rules. What are some ways we can still operate on this item ? The only way we can do this is to provide methods that accept a lambda expression, apply the lambda expression on the item, and return the new box with the new value. For instance, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Box < T > { private T item ; : public < U > Box < U > map ( Transformer <? super T , ? extends U > transformer ) { if ( ! isPresent ()) { return empty (); } return Box . ofNullable ( transformer . transform ( this . item )); } : public Box < T > filter ( BooleanCondition <? super T > condition ) { if ( ! isPresent () || ! ( condition . test ( this . item )) { return empty (); } return this ; } : } The method map takes in a lambda expression and allows us to arbitrarily apply a function to the item, while the method filter allows us to perform an arbitrary check on the property of the item. Methods such as these, which accept a function as a parameter, allows the client to manipulate the data behind the abstraction barrier without knowing the internals of the object. Here, we are treating lambda expressions as \"manipulators\" that we can pass in behind the abstraction barrier and modify the internals arbitrarily for us, while the container or the box tries to maintain the semantics for us. Maybe Let's now look at Box<T> in a slightly different light. Let's rename it to Maybe<T> . Maybe<T> is an option type , a common abstraction in programming languages ( java.util.Optional in Java, option in Scala, Maybe in Haskell, Nullable<T> in C#, etc) that is a wrapper around a value that is either there or is null . The Maybe<T> abstraction allows us to write code without mostly not worrying about the possibility that our value is missing. When we call map on a value that is missing, nothing happens. Recall that we wish to write a program that is as close to pure mathematical functions as possible, a mathematical function always has a well-defined domain and codomain. If we have a method that looks this like this: 1 Counter c = shop . findCounter (); Then findCounter is mapping from the domain on shops or counters. However, if we implement findCounter such that it returns null if no counter is available, then findCounter is not a function anymore. The return value null is not a counter, as we cannot do things that we can normally do on counters to it. So findCounter now maps to a value outside its codomain! This violation of the purity of function adds complications to our code, as we now have to specifically filter out null value, and is a common source of bugs. One way to fix this is to have a special counter (say, class NullCounter extends Counter ) that is returned whenever no counter is available. This way, our findCounter remains a pure function. But this is not a general solution. If we adopt this solution, everywhere we return null in place of a non-null instance we have to create a special subclass. Another way, that is more general, is to expand the codomain of the function to include null , and wrap both null and Counter under a type called Maybe<Counter> . We make findCounter returns a Maybe<Counter> instead 1 Maybe < Counter > c = shop . findCounter (); With this design, findCounter is now the domain Shop to codomain Maybe<Counter> , and it is pure. Another way to view the Maybe<T> class is that it internalizes all the checks for null on the client's behalf. Maybe<T> ensures that if null represents a missing value, then the semantics of this missing value is preserved throughout the chain of map and filter operations. Within its implementation, Maybe<T> do the right thing when the value is missing to prevent us from encountering NullPointerException . There is a check for null when needed, internally, within Maybe<T> . This internalization removes the burden of checking for null on the programmer and removes the possibility of run-time crashes due to missing null checks.","title":"28. Box and Maybe"},{"location":"28-box-maybe.html#unit-28-box-and-maybe","text":"","title":"Unit 28: Box and Maybe"},{"location":"28-box-maybe.html#learning-objectives","text":"After this lecture, students should appreciate: the generality of the class Box<T> and Maybe<T> how passing in functions as parameter can lead to highly general abstractions how Maybe<T> preserves the \"maybe null\" semantics over a reference type by internalizing checks for null","title":"Learning Objectives"},{"location":"28-box-maybe.html#lambda-as-a-cross-barrier-state-manipulator","text":"Recall that every class has an abstraction barrier between the client and the implementer. The internal states of the class are heavily protected and hidden. The implementer selectively provides a set of methods to access and manipulate the internal states of instances. This approach allows the implementer to control what the client can and cannot do to the internal states. This is good if we want to build abstractions over specific entities such as shapes or data structures such as a stack, but it is not flexible enough to build general abstraction. Let's consider the following class: 1 2 3 class Box < T > { private T item ; } It is a box containing a single item of type T . Suppose that we want to keep the item hidden and we want to have certain rules and maintain some semantics about the use of the item . As such, we don't want to provide any setter or getter, so that the client may not break our rules. What are some ways we can still operate on this item ? The only way we can do this is to provide methods that accept a lambda expression, apply the lambda expression on the item, and return the new box with the new value. For instance, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Box < T > { private T item ; : public < U > Box < U > map ( Transformer <? super T , ? extends U > transformer ) { if ( ! isPresent ()) { return empty (); } return Box . ofNullable ( transformer . transform ( this . item )); } : public Box < T > filter ( BooleanCondition <? super T > condition ) { if ( ! isPresent () || ! ( condition . test ( this . item )) { return empty (); } return this ; } : } The method map takes in a lambda expression and allows us to arbitrarily apply a function to the item, while the method filter allows us to perform an arbitrary check on the property of the item. Methods such as these, which accept a function as a parameter, allows the client to manipulate the data behind the abstraction barrier without knowing the internals of the object. Here, we are treating lambda expressions as \"manipulators\" that we can pass in behind the abstraction barrier and modify the internals arbitrarily for us, while the container or the box tries to maintain the semantics for us.","title":"Lambda as a Cross-Barrier State Manipulator"},{"location":"28-box-maybe.html#maybe","text":"Let's now look at Box<T> in a slightly different light. Let's rename it to Maybe<T> . Maybe<T> is an option type , a common abstraction in programming languages ( java.util.Optional in Java, option in Scala, Maybe in Haskell, Nullable<T> in C#, etc) that is a wrapper around a value that is either there or is null . The Maybe<T> abstraction allows us to write code without mostly not worrying about the possibility that our value is missing. When we call map on a value that is missing, nothing happens. Recall that we wish to write a program that is as close to pure mathematical functions as possible, a mathematical function always has a well-defined domain and codomain. If we have a method that looks this like this: 1 Counter c = shop . findCounter (); Then findCounter is mapping from the domain on shops or counters. However, if we implement findCounter such that it returns null if no counter is available, then findCounter is not a function anymore. The return value null is not a counter, as we cannot do things that we can normally do on counters to it. So findCounter now maps to a value outside its codomain! This violation of the purity of function adds complications to our code, as we now have to specifically filter out null value, and is a common source of bugs. One way to fix this is to have a special counter (say, class NullCounter extends Counter ) that is returned whenever no counter is available. This way, our findCounter remains a pure function. But this is not a general solution. If we adopt this solution, everywhere we return null in place of a non-null instance we have to create a special subclass. Another way, that is more general, is to expand the codomain of the function to include null , and wrap both null and Counter under a type called Maybe<Counter> . We make findCounter returns a Maybe<Counter> instead 1 Maybe < Counter > c = shop . findCounter (); With this design, findCounter is now the domain Shop to codomain Maybe<Counter> , and it is pure. Another way to view the Maybe<T> class is that it internalizes all the checks for null on the client's behalf. Maybe<T> ensures that if null represents a missing value, then the semantics of this missing value is preserved throughout the chain of map and filter operations. Within its implementation, Maybe<T> do the right thing when the value is missing to prevent us from encountering NullPointerException . There is a check for null when needed, internally, within Maybe<T> . This internalization removes the burden of checking for null on the programmer and removes the possibility of run-time crashes due to missing null checks.","title":"Maybe"},{"location":"29-lazy.html","text":"Unit 29: Lazy Evaluation Learning Objectives After this lecture, students should understand: what is lazy evaluation and how lambda expression allows us to delay the execution of a computation how memoization and the Lazy<T> abstraction allows us to evaluate an expression exactly once. Lambda as Delayed Data When we write a lambda expression like this: 1 Transformer < Integer , Integer > f = x -> x + 1 ; we are just defining an expression. We are not invoking the function x + 1 . This is perhaps clear to most students since to invoke the function, we need an argument for x , and no argument is supplied when we define f . Consider the following functional interfaces instead: 1 2 3 4 5 6 7 8 9 @FunctionalInterface interface Producer < T > { T produce (); } @FunctionalInterface interface Task { void run (); } These functional interfaces have a method that does not take in a parameter. So, we would be using them like such: 1 2 3 i = 4 ; Task print = () -> System . out . println ( i ); Producer < String > toStr = () -> Integer . toString ( i ); Keep in mind that these are still lambda expressions and nothing is executed by simply declaring them. We are just saving them to be executed later. Lambda expression, therefore, allows us to delay the execution of code, saving them until we need it later. This enables another powerful mechanism called lazy evaluation . We can build up a sequence of complex computations, without actually executing them, until we need to. Expressions are evaluated on demand when needed. Consider the following class: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Version 0.1 (eager evaluation) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void log ( LogLevel level , String msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg ); } } } The log method checks the seriousness level of the message against the current log level, and only prints the message if the level of the message is the same or higher. For instance, if the current log level is WARNING , then 1 2 Logger.log(Logger.LogLevel.INFO, \"User \" + System.getProperty(\"user.name\") + \" has logged in\"); will not get printed. However, regardless of whether the log message will be printed, the method System.getProperty(\"user.name\") will be evaluated, which is wasteful. A better design for this case is to wrap the message msg within a lambda expression, so that it does not get evaluated eagerly when we pass it in as a parameter. We can wrap the message with a Producer<String> . The new lazyLog method would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Version 0.2 (with Producer) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void lazyLog ( LogLevel level , Producer < String > msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg . produce ()); } } } and is invoked like this: 1 2 Logger . lazyLog ( Logger . LogLevel . INFO , () -> \"User \" + System . getProperty ( \"user.name\" ) + \" has logged in\" ); The method System.getProperty(\"user.name\") is now lazily called, only if the message is going to be printed. Memoization We have so far seen one way of being lazy, i.e., procrastinating our computation until we really need the data. Another way of being lazy is not to repeat ourselves. If we have computed the value of a function before, we can cached (or memoize) the value, keep it somewhere, so that we don't need to compute it again. This is useful, of course, only if the function is pure -- regardless of how many times we invoke the function, it always returns the same value, and invoking it has no side effects on the execution of the program. Here, we see another important advantage of keeping our code pure and free of side effects -- so that we can be lazy! While other languages such as Scala as native support for lazy variables, Java does not. So let's build a simple one here. (You will build a more sophisticated one in Lab 6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Lazy < T > { T value ; boolean evaluated ; Producer < T > producer ; public Lazy ( Producer < T > producer ) { evaluated = false ; value = null ; this . producer = producer ; } public T get () { if ( ! evaluated ) { value = producer . produce (); evaluated = true ; } return value ; } } We can now rewrite our Logger as 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.3 (with Lazy) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void lazyLog ( LogLevel level , Lazy < String > msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg . get ()); } } } and call it with: 1 2 3 Lazy < String > loginMessage = new Lazy ( () -> \"User \" + System . getProperty ( \"user.name\" ) + \" has logged in\" ); Logger . lazyLog ( Logger . LogLevel . INFO , loginMessage ); If loginMessage is used in multiple places, memoization ensures that System.getProperty(\"user.name\") and the concatenation of the strings are done only once.","title":"29. Lazy Evaluation"},{"location":"29-lazy.html#unit-29-lazy-evaluation","text":"","title":"Unit 29: Lazy Evaluation"},{"location":"29-lazy.html#learning-objectives","text":"After this lecture, students should understand: what is lazy evaluation and how lambda expression allows us to delay the execution of a computation how memoization and the Lazy<T> abstraction allows us to evaluate an expression exactly once.","title":"Learning Objectives"},{"location":"29-lazy.html#lambda-as-delayed-data","text":"When we write a lambda expression like this: 1 Transformer < Integer , Integer > f = x -> x + 1 ; we are just defining an expression. We are not invoking the function x + 1 . This is perhaps clear to most students since to invoke the function, we need an argument for x , and no argument is supplied when we define f . Consider the following functional interfaces instead: 1 2 3 4 5 6 7 8 9 @FunctionalInterface interface Producer < T > { T produce (); } @FunctionalInterface interface Task { void run (); } These functional interfaces have a method that does not take in a parameter. So, we would be using them like such: 1 2 3 i = 4 ; Task print = () -> System . out . println ( i ); Producer < String > toStr = () -> Integer . toString ( i ); Keep in mind that these are still lambda expressions and nothing is executed by simply declaring them. We are just saving them to be executed later. Lambda expression, therefore, allows us to delay the execution of code, saving them until we need it later. This enables another powerful mechanism called lazy evaluation . We can build up a sequence of complex computations, without actually executing them, until we need to. Expressions are evaluated on demand when needed. Consider the following class: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Version 0.1 (eager evaluation) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void log ( LogLevel level , String msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg ); } } } The log method checks the seriousness level of the message against the current log level, and only prints the message if the level of the message is the same or higher. For instance, if the current log level is WARNING , then 1 2 Logger.log(Logger.LogLevel.INFO, \"User \" + System.getProperty(\"user.name\") + \" has logged in\"); will not get printed. However, regardless of whether the log message will be printed, the method System.getProperty(\"user.name\") will be evaluated, which is wasteful. A better design for this case is to wrap the message msg within a lambda expression, so that it does not get evaluated eagerly when we pass it in as a parameter. We can wrap the message with a Producer<String> . The new lazyLog method would look like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Version 0.2 (with Producer) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void lazyLog ( LogLevel level , Producer < String > msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg . produce ()); } } } and is invoked like this: 1 2 Logger . lazyLog ( Logger . LogLevel . INFO , () -> \"User \" + System . getProperty ( \"user.name\" ) + \" has logged in\" ); The method System.getProperty(\"user.name\") is now lazily called, only if the message is going to be printed.","title":"Lambda as Delayed Data"},{"location":"29-lazy.html#memoization","text":"We have so far seen one way of being lazy, i.e., procrastinating our computation until we really need the data. Another way of being lazy is not to repeat ourselves. If we have computed the value of a function before, we can cached (or memoize) the value, keep it somewhere, so that we don't need to compute it again. This is useful, of course, only if the function is pure -- regardless of how many times we invoke the function, it always returns the same value, and invoking it has no side effects on the execution of the program. Here, we see another important advantage of keeping our code pure and free of side effects -- so that we can be lazy! While other languages such as Scala as native support for lazy variables, Java does not. So let's build a simple one here. (You will build a more sophisticated one in Lab 6) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Lazy < T > { T value ; boolean evaluated ; Producer < T > producer ; public Lazy ( Producer < T > producer ) { evaluated = false ; value = null ; this . producer = producer ; } public T get () { if ( ! evaluated ) { value = producer . produce (); evaluated = true ; } return value ; } } We can now rewrite our Logger as 1 2 3 4 5 6 7 8 9 10 11 12 13 // version 0.3 (with Lazy) class Logger { enum LogLevel { INFO , WARNING , ERROR }; public static LogLevel currLogLevel = LogLevel . WARNING ; static void lazyLog ( LogLevel level , Lazy < String > msg ) { if ( level . compareTo ( Logger . currLogLevel ) >= 0 ) { System . out . println ( \" [\" + level + \"] \" + msg . get ()); } } } and call it with: 1 2 3 Lazy < String > loginMessage = new Lazy ( () -> \"User \" + System . getProperty ( \"user.name\" ) + \" has logged in\" ); Logger . lazyLog ( Logger . LogLevel . INFO , loginMessage ); If loginMessage is used in multiple places, memoization ensures that System.getProperty(\"user.name\") and the concatenation of the strings are done only once.","title":"Memoization"},{"location":"30-infinitelist.html","text":"Unit 30: Infinite list Preliminary: An Eagerly Evaluated List Let's consider first how we can represent an eagerly evaluated, finite list, recursively. A simple way is to treat the list as a recursive structure, containing a head and a tail , with the tail being a list itself. We have a special terminating list called EmptyList that we use to terminate the EagerList. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class EagerList < T > { private final T head ; private final EagerList < T > tail ; private static EagerList <?> EMPTY = new EmptyList (); public EagerList ( T head , EagerList < T > tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head ; } public EagerList < T > tail () { return this . tail ; } public static < T > EagerList < T > empty () { @SuppressWarnings ( \"unchecked\" ) EagerList < T > temp = ( EagerList < T > ) EMPTY ; return temp ; } private static class EmptyList extends EagerList < Object > { EmptyList () { super ( null , null ); } @Override public Object head () { throw new java . util . NoSuchElementException (); } @Override public EagerList < Object > tail () { throw new java . util . NoSuchElementException (); } } } Let's provide two factory methods called generate and iterate , that will populate our EagerList for us. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static < T > EagerList < T > generate ( T t , int size ) { if ( size == 0 ) { return empty (); } return new EagerList <> ( t , generate ( t , size - 1 )); } public static < T > EagerList < T > iterate ( T init , BooleanCondition <? super T > cond , Transformer <? super T , ? extends T > op ) { if ( ! cond . test ( init )) { return empty (); } return new EagerList <> ( init , iterate ( op . transform ( init ), cond , op )); } Let's now provide the standard operation map so that we can transform the items in the list. The map method takes a lambda expression as the parameter, applies it recursively to every element in the list, and returns the resulting new list. 1 2 3 public < R > EagerList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new EagerList <> ( mapper . transform ( this . head ()), this . tail (). map ( mapper )); } We can also provide the filter method, that takes in lambda expression as a parameter and tests if each element in the list passes the test. We return the list containing only the elements that pass the given test. 1 2 3 4 5 6 public EagerList < T > filter ( BooleanCondition <? super T > cond ) { if ( cond . test ( this . head ())) { return new EagerList <> ( this . head (), this . tail (). filter ( cond )); } return this . tail (). filter ( cond ); } We have the special EmptyList cases, 1 2 3 4 5 6 7 8 9 @Override public < R > EagerList < R > map ( Transformer <? super Object , ? extends R > mapper ) { return empty (); } @Override public EagerList < Object > filter ( BooleanCondition <? super Object > cond ) { return empty (); } The resulting list can be used this way: 1 2 3 4 5 6 EagerList < Integer > l = EagerList . iterate ( 1 , i -> i < 10 , i -> i + 1 ) // [1, ... 9] . filter ( i -> i % 3 == 0 ) // [3, 6, 9] . map ( i -> i * 2 ); // [6, 12, 18] l . head (); // 6 l . tail (). head (); // 12 l . tail (). tail (). head (); // 18 An Infinite List Lazy evaluation allows us to delay the computation that produces data until the data is needed. This powerful concept enables us to build computationally-efficient data structures. We will focus on building a list with a possibly infinite number of elements -- something that couldn't be done without lazy evaluation. Any eager-evaluation-based solution will just run in an infinite loop if the list is infinitely long. For instance, 1 EagerList . iterate ( 1 , i > 0 , i -> i + 1 ); // infinite loop Just as we saw in the previous unit, we can delay a computation by using the Producer functional interface (or anything equivalent). Instead of doing compute() which is immediately evaluated when executed, we replace it with a Producer () -> compute() , which \"stores\" the computation in an instance of Producer , and we only call it when we invoke the produce() method. Instead of storing the head and tail of the list, we can think of an infinite list as consisting of two functions, the first is a function that generates head, and the second is a function that generates the tail. Our InfiniteList looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class InfiniteList < T > { private Producer < T > head ; private Producer < InfiniteList < T >> tail ; public InfiniteList ( Producer < T > head , Producer < InfiniteList < T >> tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head . produce (); } public InfiniteList < T > tail () { return this . tail . produce (); } } Note that we don't need an EmptyList for now. We will need it if we have operations that truncate the list to a finite one, but let's not worry about it yet. We now change the generate method to be lazy, by passing in a producer instead. We no longer need to pass in the size, since the list can be infinitely long! 1 2 3 4 public static < T > InfiniteList < T > generate ( Producer < T > producer ) { return new InfiniteList < T > ( producer , () -> generate ( producer )); } We can change iterate as well to only iterate through and generate the next element when we need it. Note that we no longer need to provide the terminating condition cond . 1 2 3 4 public static < T > InfiniteList < T > iterate ( T init , Transformer < T , T > next ) { return new InfiniteList < T > (() -> init , () -> iterate ( next . transform ( init ), next )); } Here are some examples of how to use the two methods above: 1 2 3 4 5 InfiniteList < Integer > ones = InfiniteList . generate (() -> 1 ); // 1, 1, 1, 1, .... InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... evens . head (); // -> 0 evens = evens . tail (); evens . head (); // -> 2 Both the lists ones and evens are infinitely long, but due to lazy evaluation, we do not generate all the elements in advance, but only when an element is needed. Map Let's now write the lazy version of map as well: 1 2 3 4 5 public < R > InfiniteList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new InfiniteList <> ( () -> mapper . transform ( this . head ()), () -> this . tail (). map ( mapper )); } The map method is lazy. All it does is create a new list initialized with a new lambda expression that applies the given lambda expression mapper to the head and the tail. When we run: 1 2 evens . map ( x -> x + 1 ); evens . map ( x -> x + 1 ). map ( x -> x * 2 ); We get an infinite list with elements 1, 3, 5, 7, etc, but the values in the list are not realized until they are needed, just like before. Only when we call head() will we evaluate the lambda expressions and obtain the results: 1 evens . map ( x -> x + 1 ). map ( x -> x * 2 ). head (); // 2 Under The Hood It is worthwhile to trace through the code and understand how head() works. For simplicity, let's put all our code together for easy reference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class InfiniteList < T > { private Producer < T > head ; private Producer < InfiniteList < T >> tail ; public static < T > InfiniteList < T > generate ( Producer < T > producer ) { return new InfiniteList < T > ( producer , () -> InfiniteList . generate ( producer )); } public static < T > InfiniteList < T > iterate ( T init , Transformer < T , T > next ) { return new InfiniteList < T > (() -> init , () -> InfiniteList . iterate ( next . transform ( init ), next )); } public InfiniteList ( Producer < T > head , Producer < InfiniteList < T >> tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head . produce (); } public InfiniteList < T > tail () { return this . tail . produce (); } public < R > InfiniteList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new InfiniteList <> ( () -> mapper . transform ( this . head ()), () -> this . tail (). map ( mapper )); } } Let's rewrite the statement 1 evens . map ( x -> x + 1 ). map ( x -> x * 2 ). head (); // 2 into something uglier and more verbose, but with intermediate variables to help us explain what happens when the statement above is invoked. 1 2 3 4 InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... InfiniteList < Integer > odds = evens . map ( x -> x + 1 ); // 1, 3, 5, ... InfiniteList < Integer > altEvens = odds . map ( x -> x * 2 ); // 2, 6, 10, .. altEvens . head (); Let's look at what gets created on the heap when we run 1 InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... The figure above shows the objects created. evens is an instance of InfiniteList , with two fields, head and tail , each pointing to an instance of Producer<T> . The two instances of Producer<T> capture the variable init . The tail additionally captures the variable next , which itself is an instance of Transformer<T,T> . Next, let's look at what gets created on the heap when we run 1 InfiniteList < Integer > odds = evens . map ( x -> x + 1 ); // 1, 3, 5, ... The figure above shows the objects added. odds is an instance of InfiniteList , with two fields, head and tail , each pointing to an instance of Producer<T> . The two instances of Producer<T> capture the local variable this and mapper of the method map . mapper refers to an instance of Transformer<T, T> . Since the method map of evens is called, the this reference refers to the object evens . After calling 1 InfiniteList < Integer > altEvens = odds . map ( x -> x * 2 ); // 2, 6, 10, .. We have the following objects set up. Let's now trace through what happens when we call altEvens.head() . This method leads to the call this.head().produce() , where this refers to altEvens . The call to produce invoked mapper.transform(this.head.produce()) of the producer labelled 1 in the figure below. This leads to this.head.produce() of this producer being called. Within this producer, this refers to odds , and so this.head.produce() invoked mapper.transform(this.head.produce()) of the producer labelled 2. Now, this refers to evens , and this.head.produce() causes the producer () -> 1 (labelled 3) to produce 1. The execution now returns to the invocation of mapper.transform(this.head.produce()) and call mapper.transform(1) (labelled 4). This returns the value 2, which we pass into the mapper.transform(2) (labelled 5). The mapper is x -> x * 2 so we have the result 4, which we return from altEvens.head() . This process shows a very different order of execution than EagerList . If we run, 1 2 3 4 EagerList . iterate ( 0 , x -> x < 10 , x -> x + 2 ) . map ( x -> x + 1 ) . map ( x -> x * 2 ) . head (); The method iterate generates all the elements first, then all the elements gets map -ed with x -> x + 1 , then with x -> x + 2 , and then the first element is retrieved. When we run, 1 2 3 4 InfiniteList . iterate ( 0 , x -> x < 10 , x -> x + 2 ) . map ( x -> x + 1 ) . map ( x -> x * 2 ) . head (); The method calls iterate and map only set up the producers that call other producers. The call to head() is the trigger that causes the chain of producers to produce a value. Filtering A Lazy List Now, let's consider how we would filter an InfiniteList . This is a bit trickier. The following naive version does not work. 1 2 3 4 5 6 7 // wrong public InfiniteList < T > filter ( BooleanCondition <? super T > cond ) { if ( cond . test ( this . head ())) { return new InfiniteList <> ( this . head , () -> this . tail (). filter ( cond )); } return this . tail (). filter ( cond ); } There are two things wrong with this. First, Line 3 cond.test(this.head()) is actually eager. It computes the head to test if it passes the given condition. Second, Line 6 is eager, it produces the tail to recursively filter it. To make filter lazy, we have to perform the test in the producer that produces the head. But if the test fails, we have to mark the head as filtered. 1 2 3 4 public InfiniteList < T > filter ( BooleanCondition <? super T > cond ) { Producer < T > newHead = () -> cond . test ( this . head ()) ? this . head () : null ; return new InfiniteList <> ( newHead , () -> this . tail (). filter ( cond )); } In the code above, we use null to indicate that the head is filtered for simplicity. It is not a good practice, however since null could be a valid value in an infinite list. Putting the abuse of null aside, the possibility that the head produces a value that is filtered affects other methods. The methods head and tail have to be changed to: 1 2 3 4 5 6 7 8 9 public T head () { T h = this . head . produce (); return h == null ? this . tail . produce (). head () : h ; } public InfiniteList < T > tail () { T h = this . head . produce (); return h == null ? this . tail . produce (). tail () : this . tail . produce (); } Further Improvements We have seen Maybe<T> as an abstraction that encapsulates a value that is either there or is missing. Instead of using null to present a value that is not there, it is better to use Maybe<T> to encapsulate the value of the head. Further, our implementation of InfiniteList<T> so far does not make use of memoization. The same value keeps getting produced repeatedly. We have built the class Lazy<T> that encapsulates a value that is produced on-demand with memoization to guarantee that it is produced at most once. It is better to use Lazy<T> to encapsulate the value of the head as well. We leave the construction of an InfiniteList<T> that uses Lazy<Maybe<T>> for its head as an exercise.","title":"30. Infinite List"},{"location":"30-infinitelist.html#unit-30-infinite-list","text":"","title":"Unit 30: Infinite list"},{"location":"30-infinitelist.html#preliminary-an-eagerly-evaluated-list","text":"Let's consider first how we can represent an eagerly evaluated, finite list, recursively. A simple way is to treat the list as a recursive structure, containing a head and a tail , with the tail being a list itself. We have a special terminating list called EmptyList that we use to terminate the EagerList. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class EagerList < T > { private final T head ; private final EagerList < T > tail ; private static EagerList <?> EMPTY = new EmptyList (); public EagerList ( T head , EagerList < T > tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head ; } public EagerList < T > tail () { return this . tail ; } public static < T > EagerList < T > empty () { @SuppressWarnings ( \"unchecked\" ) EagerList < T > temp = ( EagerList < T > ) EMPTY ; return temp ; } private static class EmptyList extends EagerList < Object > { EmptyList () { super ( null , null ); } @Override public Object head () { throw new java . util . NoSuchElementException (); } @Override public EagerList < Object > tail () { throw new java . util . NoSuchElementException (); } } } Let's provide two factory methods called generate and iterate , that will populate our EagerList for us. 1 2 3 4 5 6 7 8 9 10 11 12 13 public static < T > EagerList < T > generate ( T t , int size ) { if ( size == 0 ) { return empty (); } return new EagerList <> ( t , generate ( t , size - 1 )); } public static < T > EagerList < T > iterate ( T init , BooleanCondition <? super T > cond , Transformer <? super T , ? extends T > op ) { if ( ! cond . test ( init )) { return empty (); } return new EagerList <> ( init , iterate ( op . transform ( init ), cond , op )); } Let's now provide the standard operation map so that we can transform the items in the list. The map method takes a lambda expression as the parameter, applies it recursively to every element in the list, and returns the resulting new list. 1 2 3 public < R > EagerList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new EagerList <> ( mapper . transform ( this . head ()), this . tail (). map ( mapper )); } We can also provide the filter method, that takes in lambda expression as a parameter and tests if each element in the list passes the test. We return the list containing only the elements that pass the given test. 1 2 3 4 5 6 public EagerList < T > filter ( BooleanCondition <? super T > cond ) { if ( cond . test ( this . head ())) { return new EagerList <> ( this . head (), this . tail (). filter ( cond )); } return this . tail (). filter ( cond ); } We have the special EmptyList cases, 1 2 3 4 5 6 7 8 9 @Override public < R > EagerList < R > map ( Transformer <? super Object , ? extends R > mapper ) { return empty (); } @Override public EagerList < Object > filter ( BooleanCondition <? super Object > cond ) { return empty (); } The resulting list can be used this way: 1 2 3 4 5 6 EagerList < Integer > l = EagerList . iterate ( 1 , i -> i < 10 , i -> i + 1 ) // [1, ... 9] . filter ( i -> i % 3 == 0 ) // [3, 6, 9] . map ( i -> i * 2 ); // [6, 12, 18] l . head (); // 6 l . tail (). head (); // 12 l . tail (). tail (). head (); // 18","title":"Preliminary: An Eagerly Evaluated List"},{"location":"30-infinitelist.html#an-infinite-list","text":"Lazy evaluation allows us to delay the computation that produces data until the data is needed. This powerful concept enables us to build computationally-efficient data structures. We will focus on building a list with a possibly infinite number of elements -- something that couldn't be done without lazy evaluation. Any eager-evaluation-based solution will just run in an infinite loop if the list is infinitely long. For instance, 1 EagerList . iterate ( 1 , i > 0 , i -> i + 1 ); // infinite loop Just as we saw in the previous unit, we can delay a computation by using the Producer functional interface (or anything equivalent). Instead of doing compute() which is immediately evaluated when executed, we replace it with a Producer () -> compute() , which \"stores\" the computation in an instance of Producer , and we only call it when we invoke the produce() method. Instead of storing the head and tail of the list, we can think of an infinite list as consisting of two functions, the first is a function that generates head, and the second is a function that generates the tail. Our InfiniteList looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class InfiniteList < T > { private Producer < T > head ; private Producer < InfiniteList < T >> tail ; public InfiniteList ( Producer < T > head , Producer < InfiniteList < T >> tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head . produce (); } public InfiniteList < T > tail () { return this . tail . produce (); } } Note that we don't need an EmptyList for now. We will need it if we have operations that truncate the list to a finite one, but let's not worry about it yet. We now change the generate method to be lazy, by passing in a producer instead. We no longer need to pass in the size, since the list can be infinitely long! 1 2 3 4 public static < T > InfiniteList < T > generate ( Producer < T > producer ) { return new InfiniteList < T > ( producer , () -> generate ( producer )); } We can change iterate as well to only iterate through and generate the next element when we need it. Note that we no longer need to provide the terminating condition cond . 1 2 3 4 public static < T > InfiniteList < T > iterate ( T init , Transformer < T , T > next ) { return new InfiniteList < T > (() -> init , () -> iterate ( next . transform ( init ), next )); } Here are some examples of how to use the two methods above: 1 2 3 4 5 InfiniteList < Integer > ones = InfiniteList . generate (() -> 1 ); // 1, 1, 1, 1, .... InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... evens . head (); // -> 0 evens = evens . tail (); evens . head (); // -> 2 Both the lists ones and evens are infinitely long, but due to lazy evaluation, we do not generate all the elements in advance, but only when an element is needed.","title":"An Infinite List"},{"location":"30-infinitelist.html#map","text":"Let's now write the lazy version of map as well: 1 2 3 4 5 public < R > InfiniteList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new InfiniteList <> ( () -> mapper . transform ( this . head ()), () -> this . tail (). map ( mapper )); } The map method is lazy. All it does is create a new list initialized with a new lambda expression that applies the given lambda expression mapper to the head and the tail. When we run: 1 2 evens . map ( x -> x + 1 ); evens . map ( x -> x + 1 ). map ( x -> x * 2 ); We get an infinite list with elements 1, 3, 5, 7, etc, but the values in the list are not realized until they are needed, just like before. Only when we call head() will we evaluate the lambda expressions and obtain the results: 1 evens . map ( x -> x + 1 ). map ( x -> x * 2 ). head (); // 2","title":"Map"},{"location":"30-infinitelist.html#under-the-hood","text":"It is worthwhile to trace through the code and understand how head() works. For simplicity, let's put all our code together for easy reference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class InfiniteList < T > { private Producer < T > head ; private Producer < InfiniteList < T >> tail ; public static < T > InfiniteList < T > generate ( Producer < T > producer ) { return new InfiniteList < T > ( producer , () -> InfiniteList . generate ( producer )); } public static < T > InfiniteList < T > iterate ( T init , Transformer < T , T > next ) { return new InfiniteList < T > (() -> init , () -> InfiniteList . iterate ( next . transform ( init ), next )); } public InfiniteList ( Producer < T > head , Producer < InfiniteList < T >> tail ) { this . head = head ; this . tail = tail ; } public T head () { return this . head . produce (); } public InfiniteList < T > tail () { return this . tail . produce (); } public < R > InfiniteList < R > map ( Transformer <? super T , ? extends R > mapper ) { return new InfiniteList <> ( () -> mapper . transform ( this . head ()), () -> this . tail (). map ( mapper )); } } Let's rewrite the statement 1 evens . map ( x -> x + 1 ). map ( x -> x * 2 ). head (); // 2 into something uglier and more verbose, but with intermediate variables to help us explain what happens when the statement above is invoked. 1 2 3 4 InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... InfiniteList < Integer > odds = evens . map ( x -> x + 1 ); // 1, 3, 5, ... InfiniteList < Integer > altEvens = odds . map ( x -> x * 2 ); // 2, 6, 10, .. altEvens . head (); Let's look at what gets created on the heap when we run 1 InfiniteList < Integer > evens = InfiniteList . iterate ( 0 , x -> x + 2 ); // 0, 2, 4, 6, ... The figure above shows the objects created. evens is an instance of InfiniteList , with two fields, head and tail , each pointing to an instance of Producer<T> . The two instances of Producer<T> capture the variable init . The tail additionally captures the variable next , which itself is an instance of Transformer<T,T> . Next, let's look at what gets created on the heap when we run 1 InfiniteList < Integer > odds = evens . map ( x -> x + 1 ); // 1, 3, 5, ... The figure above shows the objects added. odds is an instance of InfiniteList , with two fields, head and tail , each pointing to an instance of Producer<T> . The two instances of Producer<T> capture the local variable this and mapper of the method map . mapper refers to an instance of Transformer<T, T> . Since the method map of evens is called, the this reference refers to the object evens . After calling 1 InfiniteList < Integer > altEvens = odds . map ( x -> x * 2 ); // 2, 6, 10, .. We have the following objects set up. Let's now trace through what happens when we call altEvens.head() . This method leads to the call this.head().produce() , where this refers to altEvens . The call to produce invoked mapper.transform(this.head.produce()) of the producer labelled 1 in the figure below. This leads to this.head.produce() of this producer being called. Within this producer, this refers to odds , and so this.head.produce() invoked mapper.transform(this.head.produce()) of the producer labelled 2. Now, this refers to evens , and this.head.produce() causes the producer () -> 1 (labelled 3) to produce 1. The execution now returns to the invocation of mapper.transform(this.head.produce()) and call mapper.transform(1) (labelled 4). This returns the value 2, which we pass into the mapper.transform(2) (labelled 5). The mapper is x -> x * 2 so we have the result 4, which we return from altEvens.head() . This process shows a very different order of execution than EagerList . If we run, 1 2 3 4 EagerList . iterate ( 0 , x -> x < 10 , x -> x + 2 ) . map ( x -> x + 1 ) . map ( x -> x * 2 ) . head (); The method iterate generates all the elements first, then all the elements gets map -ed with x -> x + 1 , then with x -> x + 2 , and then the first element is retrieved. When we run, 1 2 3 4 InfiniteList . iterate ( 0 , x -> x < 10 , x -> x + 2 ) . map ( x -> x + 1 ) . map ( x -> x * 2 ) . head (); The method calls iterate and map only set up the producers that call other producers. The call to head() is the trigger that causes the chain of producers to produce a value.","title":"Under The Hood"},{"location":"30-infinitelist.html#filtering-a-lazy-list","text":"Now, let's consider how we would filter an InfiniteList . This is a bit trickier. The following naive version does not work. 1 2 3 4 5 6 7 // wrong public InfiniteList < T > filter ( BooleanCondition <? super T > cond ) { if ( cond . test ( this . head ())) { return new InfiniteList <> ( this . head , () -> this . tail (). filter ( cond )); } return this . tail (). filter ( cond ); } There are two things wrong with this. First, Line 3 cond.test(this.head()) is actually eager. It computes the head to test if it passes the given condition. Second, Line 6 is eager, it produces the tail to recursively filter it. To make filter lazy, we have to perform the test in the producer that produces the head. But if the test fails, we have to mark the head as filtered. 1 2 3 4 public InfiniteList < T > filter ( BooleanCondition <? super T > cond ) { Producer < T > newHead = () -> cond . test ( this . head ()) ? this . head () : null ; return new InfiniteList <> ( newHead , () -> this . tail (). filter ( cond )); } In the code above, we use null to indicate that the head is filtered for simplicity. It is not a good practice, however since null could be a valid value in an infinite list. Putting the abuse of null aside, the possibility that the head produces a value that is filtered affects other methods. The methods head and tail have to be changed to: 1 2 3 4 5 6 7 8 9 public T head () { T h = this . head . produce (); return h == null ? this . tail . produce (). head () : h ; } public InfiniteList < T > tail () { T h = this . head . produce (); return h == null ? this . tail . produce (). tail () : this . tail . produce (); }","title":"Filtering A Lazy List"},{"location":"30-infinitelist.html#further-improvements","text":"We have seen Maybe<T> as an abstraction that encapsulates a value that is either there or is missing. Instead of using null to present a value that is not there, it is better to use Maybe<T> to encapsulate the value of the head. Further, our implementation of InfiniteList<T> so far does not make use of memoization. The same value keeps getting produced repeatedly. We have built the class Lazy<T> that encapsulates a value that is produced on-demand with memoization to guarantee that it is produced at most once. It is better to use Lazy<T> to encapsulate the value of the head as well. We leave the construction of an InfiniteList<T> that uses Lazy<Maybe<T>> for its head as an exercise.","title":"Further Improvements"},{"location":"31-stream.html","text":"Unit 31: Streams in Java We have been building and using our own functional interfaces and abstractions. Java provides its own version of functional interfaces that are comparable to ours, in the java.util.function package. The table below shows some commonly used ones: CS2030S java.util.function BooleanCondition<T>::test Predicate<T>::test Producer<T>::produce Supplier<T>::get Transformer<T,R>::transform Function<T,R>::apply Transformer<T,T>::transform UnaryOp<T>::apply Combiner<S,T,R>::combine BiFunction<S,T,R>::apply Besides, some of the abstractions we have built have similar counterparts in Java as well: CS2030S Java version Maybe<T> java.util.Optional<T> Lazy<T> N/A InfiniteList<T> java.util.stream.Stream<T> There is a subtle and important difference between our Maybe<T> and Optional<T> , which we will explore in an upcoming unit. We will focus this unit on Stream since the Java implementation of `stream is an infinite list with much more functionalities, some of which (such as parallel streams) are beyond what we can build ourselves in CS2030S. Building a Stream To start, let's see how we can build a stream object: We can use the static factory method of (e.g., Stream.of(1, 2, 3) ) We can use the generate and iterate methods (similar to our InfiniteList ) We can convert an array into a Stream using Arrays::stream We can convert a List instance (or any Collection instance) into a Stream using List::stream Many other APIs in Java return a Stream instance (e.g., Files::lines ) Terminal Operations A Stream is lazy, just like InfiniteList . A terminal operation is an operation on the stream that triggers the evaluation of the stream. A typical way of writing code that operates on streams is to chain a series of intermediate operations together, ending with a terminal operation. The forEach method is a terminal operation that takes in a stream and applies a lambda expression to each element. The lambda expression to apply does not return any value. Java provides the Consumer<T> functional interface for this. Typical use is 1 2 Stream . of ( 1 , 2 , 3 ). forEach ( System . out :: println ); Stream . generate (() -> 1 ). forEach ( System . out :: println ); // infinite loop Intermediate Stream Operations An intermediate operation on stream returns another Stream . Java provides map , filter , flatMap , and other intermediate operations. Intermediate operations are lazy and do not cause the stream to be evaluated. FlatMapping a Stream You have seen flatMap for Box<T> , Maybe<T> and Lazy<T> . The method flatMap in Stream behaves similarly -- it takes a lambda expression that transforms every element in the stream into another stream. The resulting stream of streams is then flattened and concatenated together. For instance, 1 2 Stream . of ( \"hello\\nworld\" , \"ciao\\nmondo\" , \"Bonjour\\nle monde\" , \"Hai\\ndunia\" ) . map ( x -> x . lines ()) // returns a stream of streams 1 2 Stream . of ( \"hello\\nworld\" , \"ciao\\nmondo\" , \"Bonjour\\nle monde\" , \"Hai\\ndunia\" ) . flatMap ( x -> x . lines ()) // return a stream of strings Stateful and Bounded Operations Some intermediate operations are stateful -- they need to keep track of some states to operate. Two examples are sorted and distinct . sorted returns a stream with the elements in the stream sorted. Without argument, it sorts according to the natural order as defined by implementing the Comparable interface. You can also pass in a Comparator to tell sorted how to sort. distinct returns a stream with only distinct elements in the stream. distinct and sorted are also known as bounded operations, since they should only be called on a finite stream -- calling them on an infinite stream is a bad idea! Truncating an Infinite List There are several intermediate operations that convert from infinite stream to finite stream: limit takes in an int \\(n\\) and returns a stream containing the first \\(n\\) elements of the stream; takeWhile takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false. The resulting stream might still be infinite if the predicate never becomes false. For instance, 1 Stream . iterate ( 0 , x -> x + 1 ). takeWhile ( x < 5 ); create a (lazy) finite stream of elements 0 to 4. Peeking with a Consumer A particularly useful intermediate operation of Stream is peek . peek takes in a Consumer , allowing us to apply a lambda on a \"fork\" of the stream. For instance, 1 Stream . iterate ( 0 , x -> x + 1 ). peek ( System . out :: println ). takeWhile ( x < 5 ). forEach ( x -> {}); Reducing a Stream One of the more powerful terminal operations in Stream is reduce , also known as fold or accumulate elsewhere, the reduce operation applies a lambda repeatedly on the elements of the stream to reduce it into a single value. For instance, 1 Stream . of ( 1 , 2 , 3 ). reduce ( 0 , ( x , y ) -> x + y ); returns the sum of all elements in the stream. The method reduce takes in an identity value ( 0 in the example above) and an accumulation function ( (x, y) -> x + y above) and returns the reduced value. The process of reduction is equivalent to the following pseudocode: 1 2 3 4 result = identity for each element in the stream result = accumulator.apply(result, element) return result Note that there are constraints on the identity and accumulation function, which are placed due to the potential parallelization of reduce . We will revisit this operation later. Java also overloaded reduce with two other versions -- a simpler one (with null identity) and a more complex one, which supports a different returned type than the type of the elements in the stream. You can read the java API for details. Element Matching Stream also provides terminal operations for testing if the elements pass a given predicate: noneMatch returns true if none of the elements pass the given predicate. allMatch returns true if every element passes the given predicate. anyMatch returns true if at least one element passes the given predicate. Consumed Once One of the greatest limitations of Stream , which does not apply to our InfiniteList , is that a stream can only be operated on once. We cannot iterate through a stream multiple times. Doing so would lead to an IllegalStateException being thrown. We have to recreate the stream if we want to operate on the stream more than once. Example, 1 2 3 Stream < Integer > s = Stream . of ( 1 , 2 , 3 ); s . count (); s . count (); // <- error Example: Is this a prime? Consider the method below, which checks if a given int is a prime: 1 2 3 4 5 6 7 8 boolean isPrime ( int x ) { for ( int i = 2 ; i <= x - 1 ; i ++ ) { if ( x % i == 0 ) { return false ; } } return true ; } Let's see how we can rewrite this with Stream . Due to the overhead of wrapper classes, Java provides specialized streams on primitives: IntStream , LongStream , and DoubleStream , with similar set of methods provided. Since we are dealing with int here, we will use IntStream . The code above can be rewritten as: 1 2 3 4 boolean isPrime ( int x ) { return IntStream . range ( 2 , x ) . noneMatch ( i -> x % i == 0 ); } The IntStream::range(x,y) method generates a stream of int from x to y-1 . Example: First 500 primes What if we want to print out the first 500 prime numbers, starting from 2? Normally, we would do the following: 1 2 3 4 5 6 7 8 9 10 11 void fiveHundredPrime () { int count = 0 ; int i = 2 ; while ( count < 500 ) { if ( isPrime ( i )) { System . out . println ( i ); count ++ ; } i ++ ; } } The code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter or put the increment in the wrong place). If you look at the code, there are a couple of components: Lines 3 and 9 deal with iterating through different numbers for primality testing Line 5 is the test of whether a number is prime Lines 2, 4, and 7, deal with limiting the output to 500 primes Line 6 is the action to perform on the prime With streams, we can write it like the following: 1 2 3 4 IntStream . iterate ( 2 , x -> x + 1 ) . filter ( x -> isPrime ( x )) . limit ( 500 ) . forEach ( System . out :: println ); Notice how each of the four components matches neatly with one operation on stream! With a stream, we no longer have to write loops, we have moved the iterations to within each operation in the stream. We no longer need to maintain states and counters, they are done within each operation as needed as well. This has another powerful implication: our code becomes more declarative , we only need to concern about what we want at each step, much less about how to do it. Doing so makes our code more succinct and less bug-prone. Caution: Avoid Overusing Streams We will end this unit with a note of caution. Using stream in place of loops should make our code simpler, more elegant, and less bug-prone. One should note that not all loops can be translated into stream elegantly. A double-nested loop, for instance, stretches the elegance of streams. A triple-nested loop should perhaps be best written as a loop with appropriate inner components written with lambdas and streams. As you go through exercises in using streams, you will find more examples of the limitations of streams.","title":"31. Stream"},{"location":"31-stream.html#unit-31-streams-in-java","text":"We have been building and using our own functional interfaces and abstractions. Java provides its own version of functional interfaces that are comparable to ours, in the java.util.function package. The table below shows some commonly used ones: CS2030S java.util.function BooleanCondition<T>::test Predicate<T>::test Producer<T>::produce Supplier<T>::get Transformer<T,R>::transform Function<T,R>::apply Transformer<T,T>::transform UnaryOp<T>::apply Combiner<S,T,R>::combine BiFunction<S,T,R>::apply Besides, some of the abstractions we have built have similar counterparts in Java as well: CS2030S Java version Maybe<T> java.util.Optional<T> Lazy<T> N/A InfiniteList<T> java.util.stream.Stream<T> There is a subtle and important difference between our Maybe<T> and Optional<T> , which we will explore in an upcoming unit. We will focus this unit on Stream since the Java implementation of `stream is an infinite list with much more functionalities, some of which (such as parallel streams) are beyond what we can build ourselves in CS2030S.","title":"Unit 31: Streams in Java"},{"location":"31-stream.html#building-a-stream","text":"To start, let's see how we can build a stream object: We can use the static factory method of (e.g., Stream.of(1, 2, 3) ) We can use the generate and iterate methods (similar to our InfiniteList ) We can convert an array into a Stream using Arrays::stream We can convert a List instance (or any Collection instance) into a Stream using List::stream Many other APIs in Java return a Stream instance (e.g., Files::lines )","title":"Building a Stream"},{"location":"31-stream.html#terminal-operations","text":"A Stream is lazy, just like InfiniteList . A terminal operation is an operation on the stream that triggers the evaluation of the stream. A typical way of writing code that operates on streams is to chain a series of intermediate operations together, ending with a terminal operation. The forEach method is a terminal operation that takes in a stream and applies a lambda expression to each element. The lambda expression to apply does not return any value. Java provides the Consumer<T> functional interface for this. Typical use is 1 2 Stream . of ( 1 , 2 , 3 ). forEach ( System . out :: println ); Stream . generate (() -> 1 ). forEach ( System . out :: println ); // infinite loop","title":"Terminal Operations"},{"location":"31-stream.html#intermediate-stream-operations","text":"An intermediate operation on stream returns another Stream . Java provides map , filter , flatMap , and other intermediate operations. Intermediate operations are lazy and do not cause the stream to be evaluated.","title":"Intermediate Stream Operations"},{"location":"31-stream.html#flatmapping-a-stream","text":"You have seen flatMap for Box<T> , Maybe<T> and Lazy<T> . The method flatMap in Stream behaves similarly -- it takes a lambda expression that transforms every element in the stream into another stream. The resulting stream of streams is then flattened and concatenated together. For instance, 1 2 Stream . of ( \"hello\\nworld\" , \"ciao\\nmondo\" , \"Bonjour\\nle monde\" , \"Hai\\ndunia\" ) . map ( x -> x . lines ()) // returns a stream of streams 1 2 Stream . of ( \"hello\\nworld\" , \"ciao\\nmondo\" , \"Bonjour\\nle monde\" , \"Hai\\ndunia\" ) . flatMap ( x -> x . lines ()) // return a stream of strings","title":"FlatMapping a Stream"},{"location":"31-stream.html#stateful-and-bounded-operations","text":"Some intermediate operations are stateful -- they need to keep track of some states to operate. Two examples are sorted and distinct . sorted returns a stream with the elements in the stream sorted. Without argument, it sorts according to the natural order as defined by implementing the Comparable interface. You can also pass in a Comparator to tell sorted how to sort. distinct returns a stream with only distinct elements in the stream. distinct and sorted are also known as bounded operations, since they should only be called on a finite stream -- calling them on an infinite stream is a bad idea!","title":"Stateful and Bounded Operations"},{"location":"31-stream.html#truncating-an-infinite-list","text":"There are several intermediate operations that convert from infinite stream to finite stream: limit takes in an int \\(n\\) and returns a stream containing the first \\(n\\) elements of the stream; takeWhile takes in a predicate and returns a stream containing the elements of the stream, until the predicate becomes false. The resulting stream might still be infinite if the predicate never becomes false. For instance, 1 Stream . iterate ( 0 , x -> x + 1 ). takeWhile ( x < 5 ); create a (lazy) finite stream of elements 0 to 4.","title":"Truncating an Infinite List"},{"location":"31-stream.html#peeking-with-a-consumer","text":"A particularly useful intermediate operation of Stream is peek . peek takes in a Consumer , allowing us to apply a lambda on a \"fork\" of the stream. For instance, 1 Stream . iterate ( 0 , x -> x + 1 ). peek ( System . out :: println ). takeWhile ( x < 5 ). forEach ( x -> {});","title":"Peeking with a Consumer"},{"location":"31-stream.html#reducing-a-stream","text":"One of the more powerful terminal operations in Stream is reduce , also known as fold or accumulate elsewhere, the reduce operation applies a lambda repeatedly on the elements of the stream to reduce it into a single value. For instance, 1 Stream . of ( 1 , 2 , 3 ). reduce ( 0 , ( x , y ) -> x + y ); returns the sum of all elements in the stream. The method reduce takes in an identity value ( 0 in the example above) and an accumulation function ( (x, y) -> x + y above) and returns the reduced value. The process of reduction is equivalent to the following pseudocode: 1 2 3 4 result = identity for each element in the stream result = accumulator.apply(result, element) return result Note that there are constraints on the identity and accumulation function, which are placed due to the potential parallelization of reduce . We will revisit this operation later. Java also overloaded reduce with two other versions -- a simpler one (with null identity) and a more complex one, which supports a different returned type than the type of the elements in the stream. You can read the java API for details.","title":"Reducing a Stream"},{"location":"31-stream.html#element-matching","text":"Stream also provides terminal operations for testing if the elements pass a given predicate: noneMatch returns true if none of the elements pass the given predicate. allMatch returns true if every element passes the given predicate. anyMatch returns true if at least one element passes the given predicate.","title":"Element Matching"},{"location":"31-stream.html#consumed-once","text":"One of the greatest limitations of Stream , which does not apply to our InfiniteList , is that a stream can only be operated on once. We cannot iterate through a stream multiple times. Doing so would lead to an IllegalStateException being thrown. We have to recreate the stream if we want to operate on the stream more than once. Example, 1 2 3 Stream < Integer > s = Stream . of ( 1 , 2 , 3 ); s . count (); s . count (); // <- error","title":"Consumed Once"},{"location":"31-stream.html#example-is-this-a-prime","text":"Consider the method below, which checks if a given int is a prime: 1 2 3 4 5 6 7 8 boolean isPrime ( int x ) { for ( int i = 2 ; i <= x - 1 ; i ++ ) { if ( x % i == 0 ) { return false ; } } return true ; } Let's see how we can rewrite this with Stream . Due to the overhead of wrapper classes, Java provides specialized streams on primitives: IntStream , LongStream , and DoubleStream , with similar set of methods provided. Since we are dealing with int here, we will use IntStream . The code above can be rewritten as: 1 2 3 4 boolean isPrime ( int x ) { return IntStream . range ( 2 , x ) . noneMatch ( i -> x % i == 0 ); } The IntStream::range(x,y) method generates a stream of int from x to y-1 .","title":"Example: Is this a prime?"},{"location":"31-stream.html#example-first-500-primes","text":"What if we want to print out the first 500 prime numbers, starting from 2? Normally, we would do the following: 1 2 3 4 5 6 7 8 9 10 11 void fiveHundredPrime () { int count = 0 ; int i = 2 ; while ( count < 500 ) { if ( isPrime ( i )) { System . out . println ( i ); count ++ ; } i ++ ; } } The code is still considered simple, and understandable for many, but I am sure some of us will encounter a bug the first time we write this (either forgot to increment the counter or put the increment in the wrong place). If you look at the code, there are a couple of components: Lines 3 and 9 deal with iterating through different numbers for primality testing Line 5 is the test of whether a number is prime Lines 2, 4, and 7, deal with limiting the output to 500 primes Line 6 is the action to perform on the prime With streams, we can write it like the following: 1 2 3 4 IntStream . iterate ( 2 , x -> x + 1 ) . filter ( x -> isPrime ( x )) . limit ( 500 ) . forEach ( System . out :: println ); Notice how each of the four components matches neatly with one operation on stream! With a stream, we no longer have to write loops, we have moved the iterations to within each operation in the stream. We no longer need to maintain states and counters, they are done within each operation as needed as well. This has another powerful implication: our code becomes more declarative , we only need to concern about what we want at each step, much less about how to do it. Doing so makes our code more succinct and less bug-prone.","title":"Example: First 500 primes"},{"location":"31-stream.html#caution-avoid-overusing-streams","text":"We will end this unit with a note of caution. Using stream in place of loops should make our code simpler, more elegant, and less bug-prone. One should note that not all loops can be translated into stream elegantly. A double-nested loop, for instance, stretches the elegance of streams. A triple-nested loop should perhaps be best written as a loop with appropriate inner components written with lambdas and streams. As you go through exercises in using streams, you will find more examples of the limitations of streams.","title":"Caution: Avoid Overusing Streams"},{"location":"32-logger.html","text":"Unit 32: Loggable So far in the class, we have seen very general abstractions that support the flatMap operation. But, it is not clear where this operation comes from, why is it fundamental, nor why is it useful 1 In this unit, we are going to build a general abstraction step-by-step, get stuck at some point, and see how flatMap comes to our rescue, and hopefully, through this exercise, you will get some appreciation of flatMap . Let's start with some methods that we wish to operate over int . Let's use some trivial functions so that we don't get distracted by its details. 1 2 3 4 5 6 7 int incr ( int x ) { return x + 1 ; } int abs ( int x ) { return x > 0 ? x : - x ; } These methods are pure functions without side effects, they take in one argument and produce a result. Just like mathematical functions, we can compose them together in arbitrary order to form more complex operations. 1 2 incr ( abs ( - 4 )); abs ( incr ( incr ( 5 ))); But, suppose now we want to return not only an int , but some additional information related to the operation on int . For instance, let's suppose we want to return a string describing the operation (for logging). Java does not support returning multiple values, so let's return a Pair . 1 2 3 4 5 6 7 Pair < Integer , String > incrWithLog ( int x ) { return Pair . of ( incr ( x ), \"incr \" + x ); } Pair < Integer , String > absWithLog ( int x ) { return Pair . of ( abs ( x ), \"abs \" + x ); } Now, we can't compose the methods as cleanly as before. 1 incrWithLog ( absWithLog ( - 4 )); // error We will need to change our methods to take in Pair<Integer,String> as the argument. 1 2 3 4 5 6 7 Pair < Integer , String > incrWithLog ( Pair < Integer , String > p ) { return Pair . of ( incr ( p . first ), p . second + \" incr \" + p . first ); } Pair < Integer , String > absWithLog ( Pair < Integer , String > p ) { return Pair . of ( abs ( p . first ), p . second + \" abs \" + p . first ); } We can now compose the methods. 1 incrWithLog ( absWithLog ( Pair . of ( - 4 , \"\" ))); Let's do it in a more OO-way, by writing a class to replace Pair . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // version 0.1 class Loggable { private final int value ; private final String log ; private Loggable ( int value , String log ) { this . value = value ; this . log = log ; } public static Loggable of ( int value ) { return new Loggable ( value , \"\" ); } Loggable incrWithLog () { return new Loggable ( incr ( this . value ), this . log + \"incr \" + this . value + \"; \" ); } Loggable absWithLog () { return new Loggable ( abs ( this . value ), this . log + \"abs \" + this . value + \"; \" ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } We can use the class above as: 1 2 Loggable x = Loggable . of ( 4 ); Loggable z = x . incrWithLog (). absWithLog (); Note that we can now chain the methods together to compose them. Additionally, the log messages get passed from one call to another and get \"composed\" as well. Making Loggable general There are many possible operations on int , and we do not want to add a method fooWithLog for every function foo . One way to make Loggable general is to abstract out the int operation and provide that as a lambda expression to Loggable . This is what the map method does. 1 2 3 Loggable map ( Transformer < Integer , Integer > transformer ) { return new Loggable ( transformer . transform ( this . value ), this . log ); } We can use it like: 1 Loggable . of ( 4 ). map ( x -> incr ( x )). map ( x -> abs ( x )) We can still chain the methods together to compose them. But, map allows us to only apply the function to the value. What should we do to the log messages? Since the given lambda returns an int, it is not sufficient to tell us what message we want to add to the log. To fix this, we will need to pass in a lambda expression that takes in an integer, but return us a pair of integer and a string, in other words, return us a Loggable . We call our new method flatMap . 1 2 3 4 Loggable flatMap ( Transformer < Integer , Loggable > transformer ) { Loggable l = transformer . transform ( this . value ); return new Loggable ( l . value , l . log + this . log ); } By making flatMap takes in a lambda that returns a pair of integer and string, Loggable can rely on these lambda to tell it how to update the log messages. Now, if we have methods like this: 1 2 3 4 5 6 7 Loggable incrWithLog ( int x ) { return new Loggable ( incr ( x ), \"incr \" + x + \"; \" ); } Loggable absWithLog ( int x ) { return new Loggable ( abs ( x ), \"abs \" + x + \"; \" ); } We can write: 1 2 3 Loggable . of ( 4 ) . flatMap ( x -> incrWithLog ( x )) . flatMap ( x -> absWithLog ( x )) to now compose the methods incr and abs together, along with the log messages! Making Loggable More General We started with an operation on int , but our Loggable class is fairly general and should be able to add a log message to any operation of any type. We can make it so by making Loggable a generic class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.2 class Loggable < T > { private final T value ; private final String log ; private Loggable ( T value , String log ) { this . value = value ; this . log = log ; } public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"\" ); } public < R > Loggable < R > flatMap ( Transformer <? super T , ? extends Loggable <? extends R >> transformer ) { Loggable <? extends R > l = transformer . transform ( this . value ); return new Loggable <> ( l . value , l . log + this . log ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } This note is inspired by The Best Introduction to Monad . \u21a9","title":"32. Loggable"},{"location":"32-logger.html#unit-32-loggable","text":"So far in the class, we have seen very general abstractions that support the flatMap operation. But, it is not clear where this operation comes from, why is it fundamental, nor why is it useful 1 In this unit, we are going to build a general abstraction step-by-step, get stuck at some point, and see how flatMap comes to our rescue, and hopefully, through this exercise, you will get some appreciation of flatMap . Let's start with some methods that we wish to operate over int . Let's use some trivial functions so that we don't get distracted by its details. 1 2 3 4 5 6 7 int incr ( int x ) { return x + 1 ; } int abs ( int x ) { return x > 0 ? x : - x ; } These methods are pure functions without side effects, they take in one argument and produce a result. Just like mathematical functions, we can compose them together in arbitrary order to form more complex operations. 1 2 incr ( abs ( - 4 )); abs ( incr ( incr ( 5 ))); But, suppose now we want to return not only an int , but some additional information related to the operation on int . For instance, let's suppose we want to return a string describing the operation (for logging). Java does not support returning multiple values, so let's return a Pair . 1 2 3 4 5 6 7 Pair < Integer , String > incrWithLog ( int x ) { return Pair . of ( incr ( x ), \"incr \" + x ); } Pair < Integer , String > absWithLog ( int x ) { return Pair . of ( abs ( x ), \"abs \" + x ); } Now, we can't compose the methods as cleanly as before. 1 incrWithLog ( absWithLog ( - 4 )); // error We will need to change our methods to take in Pair<Integer,String> as the argument. 1 2 3 4 5 6 7 Pair < Integer , String > incrWithLog ( Pair < Integer , String > p ) { return Pair . of ( incr ( p . first ), p . second + \" incr \" + p . first ); } Pair < Integer , String > absWithLog ( Pair < Integer , String > p ) { return Pair . of ( abs ( p . first ), p . second + \" abs \" + p . first ); } We can now compose the methods. 1 incrWithLog ( absWithLog ( Pair . of ( - 4 , \"\" ))); Let's do it in a more OO-way, by writing a class to replace Pair . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // version 0.1 class Loggable { private final int value ; private final String log ; private Loggable ( int value , String log ) { this . value = value ; this . log = log ; } public static Loggable of ( int value ) { return new Loggable ( value , \"\" ); } Loggable incrWithLog () { return new Loggable ( incr ( this . value ), this . log + \"incr \" + this . value + \"; \" ); } Loggable absWithLog () { return new Loggable ( abs ( this . value ), this . log + \"abs \" + this . value + \"; \" ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } We can use the class above as: 1 2 Loggable x = Loggable . of ( 4 ); Loggable z = x . incrWithLog (). absWithLog (); Note that we can now chain the methods together to compose them. Additionally, the log messages get passed from one call to another and get \"composed\" as well.","title":"Unit 32: Loggable"},{"location":"32-logger.html#making-loggable-general","text":"There are many possible operations on int , and we do not want to add a method fooWithLog for every function foo . One way to make Loggable general is to abstract out the int operation and provide that as a lambda expression to Loggable . This is what the map method does. 1 2 3 Loggable map ( Transformer < Integer , Integer > transformer ) { return new Loggable ( transformer . transform ( this . value ), this . log ); } We can use it like: 1 Loggable . of ( 4 ). map ( x -> incr ( x )). map ( x -> abs ( x )) We can still chain the methods together to compose them. But, map allows us to only apply the function to the value. What should we do to the log messages? Since the given lambda returns an int, it is not sufficient to tell us what message we want to add to the log. To fix this, we will need to pass in a lambda expression that takes in an integer, but return us a pair of integer and a string, in other words, return us a Loggable . We call our new method flatMap . 1 2 3 4 Loggable flatMap ( Transformer < Integer , Loggable > transformer ) { Loggable l = transformer . transform ( this . value ); return new Loggable ( l . value , l . log + this . log ); } By making flatMap takes in a lambda that returns a pair of integer and string, Loggable can rely on these lambda to tell it how to update the log messages. Now, if we have methods like this: 1 2 3 4 5 6 7 Loggable incrWithLog ( int x ) { return new Loggable ( incr ( x ), \"incr \" + x + \"; \" ); } Loggable absWithLog ( int x ) { return new Loggable ( abs ( x ), \"abs \" + x + \"; \" ); } We can write: 1 2 3 Loggable . of ( 4 ) . flatMap ( x -> incrWithLog ( x )) . flatMap ( x -> absWithLog ( x )) to now compose the methods incr and abs together, along with the log messages!","title":"Making Loggable general"},{"location":"32-logger.html#making-loggable-more-general","text":"We started with an operation on int , but our Loggable class is fairly general and should be able to add a log message to any operation of any type. We can make it so by making Loggable a generic class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.2 class Loggable < T > { private final T value ; private final String log ; private Loggable ( T value , String log ) { this . value = value ; this . log = log ; } public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"\" ); } public < R > Loggable < R > flatMap ( Transformer <? super T , ? extends Loggable <? extends R >> transformer ) { Loggable <? extends R > l = transformer . transform ( this . value ); return new Loggable <> ( l . value , l . log + this . log ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } This note is inspired by The Best Introduction to Monad . \u21a9","title":"Making Loggable More General"},{"location":"33-monad.html","text":"Unit 33: Monad Learning Objectives After this lecture, students should: Understand what are functors and monads Understand the laws that a functor and monad must obey and be able to verify them Generalizing Loggable<T> We have just created a class Loggable<T> with a flatMap method that allows us to operate on the value encapsulated inside, along with some \"side information\". Loggable<T> follows a pattern that we have seen many times before. We have seen this in Maybe<T> and Lazy<T> , and InfiniteList<T> . Each of these classes has: an of method to initialize the value and side information. have a flatMap method to update the value and side information. Different classes above have different side information that is initialized, stored, and updated when we use the of and flatMap operations. Maybe<T> stores the side information of whether the value is there or not there. Lazy<T> stores the side information of whether the value has been evaluated or not. InfiniteList<T> stores the side information that the values in the list may or may not be evaluated. Loggable<T> stores the side information of a log describing the operations done on the value. These classes that we wrote follow certain patterns that make them well behaved when we create them with of and chain them with flatMap . Such classes that are \"well behaved\" are examples of a programming construct called monads . A monad must follow three laws, to behave well. Let's examine the laws below. Identity Laws Before we list down the first and second laws formally, let's try to get some intuition over the desired behavior first. The of method in a monad should behave like an identity. It creates a new monad by initializing our monad with a value and its side information. For instance, in our Loggable<T> , 1 2 3 public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"\" ); } The logger is initialized with empty side information (e.g., empty string as a log message). Now, let's consider the lambda that we wish to pass into flatMap -- such a lambda takes in a value, compute it, and wrap it in a \"new\" monad, together with the correponding side information. For instance, 1 2 3 Loggable < Integer > incrWithLog ( int x ) { return new Loggable <> ( incr ( x ), \"incr \" + x + \"; \" ); } What should we expect when we take a fresh new monad Loggable.of(4) and call flatMap with a function incrWithLog ? Since Loggable.of(4) is new with no operation performed on it yet, calling 1 Loggable . of ( 4 ). flatMap ( x -> incrWithLog ( x )) should just result in the same value exactly as calling incrWithLog(4) . So, we expect that, after calling the above, we have a Loggable with a value 5 and a log message of \"incr 4\" . Our of method should not do anything extra to the value and side information -- it should simply wrap the value 4 into the Loggable . Our flatMap method should not do anything extra to the value and the side information, it should simply apply the given lambda expression to the value. Now, suppose we take an instance of Loggable , called logger , that has already been operated on one or more times with flatMap , and contain some side information. What should we expect when we call: 1 logger . flatMap ( x -> Loggable . of ( x )) Since of should behave like an identity, it should not change the value or add extra side information. The flatMap above should do nothing and the expression above should be the same as logger . What we have just described above is called the left identity law and the right identity law of monads. To be more general, let Monad be a type that is a monad and monad be an instance of it. The left identity law says: Monad.of(x).flatMap(x -> f(x)) must be the same as f(x) The right identity law says: monad.flatMap(x -> Monad.of(x)) must be the same as monad Associative Law Let's now go back to the original incr and abs functions for a moment. To compose the functions, we can write abs(incr(x)) , explicitly one function after another. Or we can compose them as another function: 1 2 3 int absIncr ( int x ) { return abs ( incr ( x )); } and call it absIncr(x) . The effects should be exactly the same. It does not matter if we group the functions together into another function before applying it to a value x. Recall that after we build our Loggable class, we were able to compose the functions incr and abs by chaining the flatMap : 1 2 3 Loggable . of ( 4 ) . flatMap ( x -> incrWithLog ( x )) . flatMap ( x -> absWithLog ( x )) We should get the resulting value as abs(incr(4)) , along with the appropriate log messages. Another way to call incr and then abs is to write something like this: 1 2 3 Loggable < Integer > absIncrWithLog ( int x ) { return incrWithLog ( x ). flatMap ( y -> absWithLog ( y )); } We have composed the methods incrWithLog and absWithLog and grouped them under another method. Now, if we call: 1 2 Loggable . of ( 4 ) . flatMap ( x -> absIncrWithLog ( x )) The two expressions must have exactly the same effect on the value and its log message. This example leads us to the third law of monads: regardless of how we group that calls to flatMap , their behaviour must be the same. This law is called the associative law . More formally, it says: monad.flatMap(x -> f(x)).flatMap(x -> g(x)) must be the same as monad.flatMap(x -> f(x).flatMap(y -> g(y))) A Counter Example If our monads follow the laws above, we can safely write methods that receive a monad from others, operate on it, and return it to others. We can also safely create a monad and pass it to the clients to operate on. Our clients can then call our methods in any order and operate on the monads that we create, and the effect on its value and side information is as expected. Let's try to make our Loggable misbehave a little. Suppose we change our Loggable<T> to be as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.3 (NOT a monad) class Loggable < T > { private final T value ; private final String log ; private Loggable ( T value , String log ) { this . value = value ; this . log = log ; } public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"Logging starts: \" ); } public < R > Loggable < R > flatMap ( Transformer <? super T , ? extends Loggable <? extends R >> transformer ) { Loggable <? extends R > logger = transformer . transform ( this . value ); return new Loggable ( logger . value , logger . log + this . log + \"\\n\" ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } Our of adds a little initialization message. Our flatMap adds a little new line before appending with the given log message. Now, our Loggable<T> is not that well behaved anymore. Suppose we have two methods foo and bar , both take in an x and perform a series of operations on x . Both returns us a Loggable instance on the final value and its log. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Loggable < Integer > foo ( int x ) { return Loggable . of ( x ) . flatMap (...) . flatMap (...) : ; } Loggable < Integer > bar ( int x ) { return Loggable . of ( x ) . flatMap (...) . flatMap (...) : ; } Now, we want to perform the sequence of operations done in foo , followed by the sequence of operations done in bar . So we called: 1 foo ( 4 ). flatMap ( x -> bar ( x )) We will find that the string \"Logging starts\" appears twice in our logs and there is now an extra blank line in the log file! Functors We will end this unit with a brief discussion on functors , another common abstraction in functional-style programming. A functor is a simpler construction than a monad in that it only ensures lambdas can be applied sequentially to the value, without worrying about side information. Recall that when we build our Loggable<T> abstraction, we add a map that only updates the value but changes nothing to the side information. One can think of a functor as an abstraction that supports map . A functor needs to adhere to two laws: preserving identity: functor.map(x -> x) is the same as functor preserving composition: functor.map(x -> f(x)).map(x -> g(x)) is the same as functor.map(x -> g(f(x)) . Our classes from cs2030s.fp , Lazy<T> , Maybe<T> , and InfiniteList<T> are functors as well. Monads and Functors in Other Languages Such abstractions are common in other languages. In Scala, for instance, the collections (list, set, map, etc.) are monads. In pure functional languages like Haskell, monads are one of the fundamental building blocks.","title":"33. Monad"},{"location":"33-monad.html#unit-33-monad","text":"","title":"Unit 33: Monad"},{"location":"33-monad.html#learning-objectives","text":"After this lecture, students should: Understand what are functors and monads Understand the laws that a functor and monad must obey and be able to verify them","title":"Learning Objectives"},{"location":"33-monad.html#generalizing-loggablet","text":"We have just created a class Loggable<T> with a flatMap method that allows us to operate on the value encapsulated inside, along with some \"side information\". Loggable<T> follows a pattern that we have seen many times before. We have seen this in Maybe<T> and Lazy<T> , and InfiniteList<T> . Each of these classes has: an of method to initialize the value and side information. have a flatMap method to update the value and side information. Different classes above have different side information that is initialized, stored, and updated when we use the of and flatMap operations. Maybe<T> stores the side information of whether the value is there or not there. Lazy<T> stores the side information of whether the value has been evaluated or not. InfiniteList<T> stores the side information that the values in the list may or may not be evaluated. Loggable<T> stores the side information of a log describing the operations done on the value. These classes that we wrote follow certain patterns that make them well behaved when we create them with of and chain them with flatMap . Such classes that are \"well behaved\" are examples of a programming construct called monads . A monad must follow three laws, to behave well. Let's examine the laws below.","title":"Generalizing Loggable&lt;T&gt;"},{"location":"33-monad.html#identity-laws","text":"Before we list down the first and second laws formally, let's try to get some intuition over the desired behavior first. The of method in a monad should behave like an identity. It creates a new monad by initializing our monad with a value and its side information. For instance, in our Loggable<T> , 1 2 3 public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"\" ); } The logger is initialized with empty side information (e.g., empty string as a log message). Now, let's consider the lambda that we wish to pass into flatMap -- such a lambda takes in a value, compute it, and wrap it in a \"new\" monad, together with the correponding side information. For instance, 1 2 3 Loggable < Integer > incrWithLog ( int x ) { return new Loggable <> ( incr ( x ), \"incr \" + x + \"; \" ); } What should we expect when we take a fresh new monad Loggable.of(4) and call flatMap with a function incrWithLog ? Since Loggable.of(4) is new with no operation performed on it yet, calling 1 Loggable . of ( 4 ). flatMap ( x -> incrWithLog ( x )) should just result in the same value exactly as calling incrWithLog(4) . So, we expect that, after calling the above, we have a Loggable with a value 5 and a log message of \"incr 4\" . Our of method should not do anything extra to the value and side information -- it should simply wrap the value 4 into the Loggable . Our flatMap method should not do anything extra to the value and the side information, it should simply apply the given lambda expression to the value. Now, suppose we take an instance of Loggable , called logger , that has already been operated on one or more times with flatMap , and contain some side information. What should we expect when we call: 1 logger . flatMap ( x -> Loggable . of ( x )) Since of should behave like an identity, it should not change the value or add extra side information. The flatMap above should do nothing and the expression above should be the same as logger . What we have just described above is called the left identity law and the right identity law of monads. To be more general, let Monad be a type that is a monad and monad be an instance of it. The left identity law says: Monad.of(x).flatMap(x -> f(x)) must be the same as f(x) The right identity law says: monad.flatMap(x -> Monad.of(x)) must be the same as monad","title":"Identity Laws"},{"location":"33-monad.html#associative-law","text":"Let's now go back to the original incr and abs functions for a moment. To compose the functions, we can write abs(incr(x)) , explicitly one function after another. Or we can compose them as another function: 1 2 3 int absIncr ( int x ) { return abs ( incr ( x )); } and call it absIncr(x) . The effects should be exactly the same. It does not matter if we group the functions together into another function before applying it to a value x. Recall that after we build our Loggable class, we were able to compose the functions incr and abs by chaining the flatMap : 1 2 3 Loggable . of ( 4 ) . flatMap ( x -> incrWithLog ( x )) . flatMap ( x -> absWithLog ( x )) We should get the resulting value as abs(incr(4)) , along with the appropriate log messages. Another way to call incr and then abs is to write something like this: 1 2 3 Loggable < Integer > absIncrWithLog ( int x ) { return incrWithLog ( x ). flatMap ( y -> absWithLog ( y )); } We have composed the methods incrWithLog and absWithLog and grouped them under another method. Now, if we call: 1 2 Loggable . of ( 4 ) . flatMap ( x -> absIncrWithLog ( x )) The two expressions must have exactly the same effect on the value and its log message. This example leads us to the third law of monads: regardless of how we group that calls to flatMap , their behaviour must be the same. This law is called the associative law . More formally, it says: monad.flatMap(x -> f(x)).flatMap(x -> g(x)) must be the same as monad.flatMap(x -> f(x).flatMap(y -> g(y)))","title":"Associative Law"},{"location":"33-monad.html#a-counter-example","text":"If our monads follow the laws above, we can safely write methods that receive a monad from others, operate on it, and return it to others. We can also safely create a monad and pass it to the clients to operate on. Our clients can then call our methods in any order and operate on the monads that we create, and the effect on its value and side information is as expected. Let's try to make our Loggable misbehave a little. Suppose we change our Loggable<T> to be as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // version 0.3 (NOT a monad) class Loggable < T > { private final T value ; private final String log ; private Loggable ( T value , String log ) { this . value = value ; this . log = log ; } public static < T > Loggable < T > of ( T value ) { return new Loggable <> ( value , \"Logging starts: \" ); } public < R > Loggable < R > flatMap ( Transformer <? super T , ? extends Loggable <? extends R >> transformer ) { Loggable <? extends R > logger = transformer . transform ( this . value ); return new Loggable ( logger . value , logger . log + this . log + \"\\n\" ); } public String toString () { return \"value: \" + this . value + \", log: \" + this . log ; } } Our of adds a little initialization message. Our flatMap adds a little new line before appending with the given log message. Now, our Loggable<T> is not that well behaved anymore. Suppose we have two methods foo and bar , both take in an x and perform a series of operations on x . Both returns us a Loggable instance on the final value and its log. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Loggable < Integer > foo ( int x ) { return Loggable . of ( x ) . flatMap (...) . flatMap (...) : ; } Loggable < Integer > bar ( int x ) { return Loggable . of ( x ) . flatMap (...) . flatMap (...) : ; } Now, we want to perform the sequence of operations done in foo , followed by the sequence of operations done in bar . So we called: 1 foo ( 4 ). flatMap ( x -> bar ( x )) We will find that the string \"Logging starts\" appears twice in our logs and there is now an extra blank line in the log file!","title":"A Counter Example"},{"location":"33-monad.html#functors","text":"We will end this unit with a brief discussion on functors , another common abstraction in functional-style programming. A functor is a simpler construction than a monad in that it only ensures lambdas can be applied sequentially to the value, without worrying about side information. Recall that when we build our Loggable<T> abstraction, we add a map that only updates the value but changes nothing to the side information. One can think of a functor as an abstraction that supports map . A functor needs to adhere to two laws: preserving identity: functor.map(x -> x) is the same as functor preserving composition: functor.map(x -> f(x)).map(x -> g(x)) is the same as functor.map(x -> g(f(x)) . Our classes from cs2030s.fp , Lazy<T> , Maybe<T> , and InfiniteList<T> are functors as well.","title":"Functors"},{"location":"33-monad.html#monads-and-functors-in-other-languages","text":"Such abstractions are common in other languages. In Scala, for instance, the collections (list, set, map, etc.) are monads. In pure functional languages like Haskell, monads are one of the fundamental building blocks.","title":"Monads and Functors in Other Languages"},{"location":"34-parallel.html","text":"Unit 34: Parallel Streams Learning Objectives After attending this lecture, students should: be aware that a program can be broken into subtasks to run parallelly and/or concurrently be aware of the issues caused by running subtasks parallelly and concurrently. be aware that there exist tradeoffs in the number of subtasks and the processing overhead. be familiar with how to process a stream parallelly and correctly. Parallel and Concurrent Programming So far, the programs that we have written in CS2030S run sequentially . What this means is that at any one time, there is only one instruction of the program running on a processor. What is concurrency? A single-core processor can only execute one instruction at one time -- this means that only one process (or less precisely speaking, one application) can run at any one time. Yet, when we use the computer, it feels as if we are running multiple processes at the same time. The operating system, behind the scenes, is switching between the different processes, to give the user the illusion that they are running at the same time. We can write a program so that it runs concurrently -- by dividing the computation into subtasks called threads . Such multi-thread programs are useful in two ways: (i) it allows us, the programmers, to separate unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor. For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI. What is parallelism? While concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time -- either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores/processors and dispatch the instructions to the cores/processors so that they are executed at the same time. All parallel programs are concurrent, but not all concurrent programs are parallel. Modern computers have more than one core/processor 1 . As such, the line between parallelism and concurrency is blurred. Parallel computing Parallel computing is one of the major topics in computer science. One can teach a whole module (or a focus area) on this topic alone. The goal of this lecture is not to cover it in-depth but is to expose students in CS2030S to the concept of parallel computing in relation to the Stream abstraction in Java. Parallel Stream We have seen that the Java Stream class is a powerful and useful class for processing data in a declarative style. But, we have not fully unleashed the power of Stream . The neatest thing about Stream is that it allows parallel operations on the elements of the stream in one single line of code. Let's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000. 1 2 3 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . forEach ( System . out :: println ); We can parallelize the code by adding the call parallel() into the stream. 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . forEach ( System . out :: println ); You may observe that the output has been reordered, although the same set of numbers are still being produced. This is because Stream has broken down the numbers into subsequences, and run filter and forEach for each subsequence in parallel. Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered. If you want to produce the output in the order of input, use forEachOrdered instead of forEach , we will lose some benefits of parallelization because of this. Suppose now that we want to compute the number of primes between 2,030,000 and 2,040,000. We can run: 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); The code above produces the same output regardless if it is being parallelized or not. Note that the task above is stateless and does not produce any side effects. Furthermore, each element is processed individually without depending on other elements. Such computation is sometimes known as embarrassingly parallel . The only communication needed for each of the parallel subtasks is to combine the result of count() from the subtasks into the final count (which has been implemented in Stream for us). How to parallelize a stream You have seen that adding parallel() to the chain of calls in a stream enables parallel processing of the stream. Note that parallel() is a lazy operation -- it merely marks the stream to be processed in parallel. As such, you can insert the call to parallel() anywhere in the chain. sequential() There is a method sequential() which marks the stream to be process sequentially. If you call both parallel() and sequential() in a stream, the last call \"wins\". The example below processes the stream sequentially: 1 s.parallel().filter(x -> x < 0).sequential().forEach(..); Another way to create a parallel stream is to call the method parallelStream() instead of stream() of the Collector class. Doing so would create a stream that will be processed in parallel from the collection. What can be parallelized? To ensure that the output of the parallel execution is correct, the stream operations must not interfere with the stream data, and most of the time must be stateless . Side-effects should be kept to a minimum. Interference Interference means that one of the stream operations modifies the source of the stream during the execution of the terminal operation. For instance: 1 2 3 4 5 6 7 8 List < String > list = new ArrayList <> ( List . of ( \"Luke\" , \"Leia\" , \"Han\" )); list . stream () . peek ( name -> { if ( name . equals ( \"Han\" )) { list . add ( \"Chewie\" ); // they belong together } }) . forEach ( i -> {}); would cause ConcurrentModificationException to be thrown. Note that this non-interference rule applies even if we are using stream() instead of parallelStream() . Stateful vs. Stateless A stateful lambda is one where the result depends on any state that might change during the execution of the stream. For instance, the generate and map operations below are stateful, since they depend on the state of the standard input. Parallelizing this may lead to incorrect output. To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks. 1 2 3 Stream . generate ( scanner :: nextInt ) . map ( i -> i + scanner . nextInt ()) . forEach ( System . out :: println ) Side Effects Side-effects can lead to incorrect results in parallel execution. Consider the following code: 1 2 3 4 5 6 List < Integer > list = new ArrayList <> ( Arrays . asList ( 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 )); List < Integer > result = new ArrayList <> (); list . parallelStream () . filter ( x -> isPrime ( x )) . forEach ( x -> result . add ( x )); The forEach lambda generates a side effect -- it modifies result . ArrayList is what we call a non-thread-safe data structure. If two threads manipulate it at the same time, an incorrect result may result. There are two ways to resolve this. One, we can use the .collect method 1 2 3 list . parallelStream () . filter ( x -> isPrime ( x )) . collect ( Collectors . toList ()) Second, we can use a thread-safe data structure. Java provides several in java.util.concurrent package, including CopyOnWriteArrayList . 1 2 3 4 List < Integer > result = new CopyOnWriteArrayList <> (); list . parallelStream () . filter ( x -> isPrime ( x )) . forEach ( x -> result . add ( x )); Associativity The reduce operation is inherently parallelizable, as we can easily reduce each sub-stream and then use the combiner to combine the results. Consider this example: 1 Stream . of ( 1 , 2 , 3 , 4 ). reduce ( 1 , ( x , y ) -> x * y , ( x , y ) -> x * y ); To allow us to run reduce in parallel, however, there are several rules that the identity , the accumulator , and the combiner must follow: combiner.apply(identity, i) must be equal to i . The combiner and the accumulator must be associative -- the order of applying must not matter. The combiner and the accumulator must be compatible -- combiner.apply(u, accumulator.apply(identity, t)) must equal to accumulator.apply(u, t) The multiplication example above meetings the three rules: i * 1 equals i (x * y) * z equals x * (y * z) u * (1 * t) equals u * t Performance of Parallel Stream Let's go back to: 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); How much time can we save by parallelizing the code above? Let's use the Instant and Duration class from Java to help us: 1 2 3 4 5 6 7 Instant start = Instant . now (); long howMany = IntStream . range ( 2_000_000 , 3_000_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); Instant stop = Instant . now (); System . out . println ( howMany + \" \" + Duration . between ( start , stop ). toMillis () + \" ms\" ); The code above measures roughly the time it takes to count the number of primes between 2 million and 3 million. On my iMac, it takes slightly more than 1 second. If I remove parallel() , it takes about 450-550 ms. So we gain about 50% performance. Can we parallelize some more? Remember how we implement isPrime 2 1 2 3 4 boolean isPrime ( int n ) { return IntStream . range ( 2 , ( int ) Math . sqrt ( n ) + 1 ) . noneMatch ( x -> n % x == 0 ); } Let's parallelize this to make this even faster! 1 2 3 4 5 boolean isPrime ( int n ) { return IntStream . range ( 2 , ( int ) Math . sqrt ( n ) + 1 ) . parallel () . noneMatch ( x -> n % x == 0 ); } If you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower! Parallelizing a stream does not always improve the performance . Creating a thread to run a task incurs some overhead, and the overhead of creating too many threads might outweigh the benefits of parallelization. Ordered vs. Unordered Source Whether or not the stream elements are ordered or unordered also plays a role in the performance of parallel stream operations. A stream may define an encounter order . Streams created from iterate , ordered collections (e.g., List or arrays), from of , are ordered. Stream created from generate or unordered collections (e.g., Set ) are unordered. Some stream operations respect the encounter order. For instance, both distinct and sorted preserve the original order of elements (if ordering is preserved, we say that an operation is stable ). The parallel version of findFirst , limit , and skip can be expensive on an ordered stream, since it needs to coordinate between the streams to maintain the order. If we have an ordered stream and respecting the original order is not important, we can call unordered() as part of the chain command to make the parallel operations much more efficient. The following, for example, takes about 700 ms on my iMac: 1 2 3 4 5 Stream . iterate ( 0 , i -> i + 7 ) . parallel () . limit ( 10_000_000 ) . filter ( i -> i % 64 == 0 ) . forEachOrdered ( i -> { }); But, with unordered() inserted, it takes about 350ms, a 2x speedup! 1 2 3 4 5 6 Stream . iterate ( 0 , i -> i + 7 ) . parallel () . unordered () . limit ( 10_000_000 ) . filter ( i -> i % 64 == 0 ) . forEachOrdered ( i -> { }); iPhone 12 comes with an A14 Bionic chip with six cores. The fastest supercomputer in the world as of this writing, the Fugaku , has 158,976 processors, each has 48 cores. \u21a9 This is a more efficient version of the code you have seen since it stops testing after the square root of the \\(n\\) . \u21a9","title":"34. Parallel Streams"},{"location":"34-parallel.html#unit-34-parallel-streams","text":"","title":"Unit 34: Parallel Streams"},{"location":"34-parallel.html#learning-objectives","text":"After attending this lecture, students should: be aware that a program can be broken into subtasks to run parallelly and/or concurrently be aware of the issues caused by running subtasks parallelly and concurrently. be aware that there exist tradeoffs in the number of subtasks and the processing overhead. be familiar with how to process a stream parallelly and correctly.","title":"Learning Objectives"},{"location":"34-parallel.html#parallel-and-concurrent-programming","text":"So far, the programs that we have written in CS2030S run sequentially . What this means is that at any one time, there is only one instruction of the program running on a processor.","title":"Parallel and Concurrent Programming"},{"location":"34-parallel.html#what-is-concurrency","text":"A single-core processor can only execute one instruction at one time -- this means that only one process (or less precisely speaking, one application) can run at any one time. Yet, when we use the computer, it feels as if we are running multiple processes at the same time. The operating system, behind the scenes, is switching between the different processes, to give the user the illusion that they are running at the same time. We can write a program so that it runs concurrently -- by dividing the computation into subtasks called threads . Such multi-thread programs are useful in two ways: (i) it allows us, the programmers, to separate unrelated tasks into threads, and write each thread separately; (ii) it improves the utilization of the processor. For instance, if I/O is in one thread, and UI rendering is in another, then when the processor is waiting for I/O to complete, it can switch to the rendering thread to make sure that the slow I/O does not affect the responsiveness of UI.","title":"What is concurrency?"},{"location":"34-parallel.html#what-is-parallelism","text":"While concurrency gives the illusion of subtasks running at the same time, parallel computing refers to the scenario where multiple subtasks are truly running at the same time -- either we have a processor that is capable of running multiple instructions at the same time, or we have multiple cores/processors and dispatch the instructions to the cores/processors so that they are executed at the same time. All parallel programs are concurrent, but not all concurrent programs are parallel. Modern computers have more than one core/processor 1 . As such, the line between parallelism and concurrency is blurred.","title":"What is parallelism?"},{"location":"34-parallel.html#parallel-computing","text":"Parallel computing is one of the major topics in computer science. One can teach a whole module (or a focus area) on this topic alone. The goal of this lecture is not to cover it in-depth but is to expose students in CS2030S to the concept of parallel computing in relation to the Stream abstraction in Java.","title":"Parallel computing"},{"location":"34-parallel.html#parallel-stream","text":"We have seen that the Java Stream class is a powerful and useful class for processing data in a declarative style. But, we have not fully unleashed the power of Stream . The neatest thing about Stream is that it allows parallel operations on the elements of the stream in one single line of code. Let's consider the following program that prints out all the prime numbers between 2,030,000 and 2,040,000. 1 2 3 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . forEach ( System . out :: println ); We can parallelize the code by adding the call parallel() into the stream. 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . forEach ( System . out :: println ); You may observe that the output has been reordered, although the same set of numbers are still being produced. This is because Stream has broken down the numbers into subsequences, and run filter and forEach for each subsequence in parallel. Since there is no coordination among the parallel tasks on the order of the printing, whichever parallel tasks that complete first will output the result to screen first, causing the sequence of numbers to be reordered. If you want to produce the output in the order of input, use forEachOrdered instead of forEach , we will lose some benefits of parallelization because of this. Suppose now that we want to compute the number of primes between 2,030,000 and 2,040,000. We can run: 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); The code above produces the same output regardless if it is being parallelized or not. Note that the task above is stateless and does not produce any side effects. Furthermore, each element is processed individually without depending on other elements. Such computation is sometimes known as embarrassingly parallel . The only communication needed for each of the parallel subtasks is to combine the result of count() from the subtasks into the final count (which has been implemented in Stream for us).","title":"Parallel Stream"},{"location":"34-parallel.html#how-to-parallelize-a-stream","text":"You have seen that adding parallel() to the chain of calls in a stream enables parallel processing of the stream. Note that parallel() is a lazy operation -- it merely marks the stream to be processed in parallel. As such, you can insert the call to parallel() anywhere in the chain. sequential() There is a method sequential() which marks the stream to be process sequentially. If you call both parallel() and sequential() in a stream, the last call \"wins\". The example below processes the stream sequentially: 1 s.parallel().filter(x -> x < 0).sequential().forEach(..); Another way to create a parallel stream is to call the method parallelStream() instead of stream() of the Collector class. Doing so would create a stream that will be processed in parallel from the collection.","title":"How to parallelize a stream"},{"location":"34-parallel.html#what-can-be-parallelized","text":"To ensure that the output of the parallel execution is correct, the stream operations must not interfere with the stream data, and most of the time must be stateless . Side-effects should be kept to a minimum.","title":"What can be parallelized?"},{"location":"34-parallel.html#interference","text":"Interference means that one of the stream operations modifies the source of the stream during the execution of the terminal operation. For instance: 1 2 3 4 5 6 7 8 List < String > list = new ArrayList <> ( List . of ( \"Luke\" , \"Leia\" , \"Han\" )); list . stream () . peek ( name -> { if ( name . equals ( \"Han\" )) { list . add ( \"Chewie\" ); // they belong together } }) . forEach ( i -> {}); would cause ConcurrentModificationException to be thrown. Note that this non-interference rule applies even if we are using stream() instead of parallelStream() .","title":"Interference"},{"location":"34-parallel.html#stateful-vs-stateless","text":"A stateful lambda is one where the result depends on any state that might change during the execution of the stream. For instance, the generate and map operations below are stateful, since they depend on the state of the standard input. Parallelizing this may lead to incorrect output. To ensure that the output is correct, additional work needs to be done to ensure that state updates are visible to all parallel subtasks. 1 2 3 Stream . generate ( scanner :: nextInt ) . map ( i -> i + scanner . nextInt ()) . forEach ( System . out :: println )","title":"Stateful vs. Stateless"},{"location":"34-parallel.html#side-effects","text":"Side-effects can lead to incorrect results in parallel execution. Consider the following code: 1 2 3 4 5 6 List < Integer > list = new ArrayList <> ( Arrays . asList ( 1 , 3 , 5 , 7 , 9 , 11 , 13 , 15 , 17 , 19 )); List < Integer > result = new ArrayList <> (); list . parallelStream () . filter ( x -> isPrime ( x )) . forEach ( x -> result . add ( x )); The forEach lambda generates a side effect -- it modifies result . ArrayList is what we call a non-thread-safe data structure. If two threads manipulate it at the same time, an incorrect result may result. There are two ways to resolve this. One, we can use the .collect method 1 2 3 list . parallelStream () . filter ( x -> isPrime ( x )) . collect ( Collectors . toList ()) Second, we can use a thread-safe data structure. Java provides several in java.util.concurrent package, including CopyOnWriteArrayList . 1 2 3 4 List < Integer > result = new CopyOnWriteArrayList <> (); list . parallelStream () . filter ( x -> isPrime ( x )) . forEach ( x -> result . add ( x ));","title":"Side Effects"},{"location":"34-parallel.html#associativity","text":"The reduce operation is inherently parallelizable, as we can easily reduce each sub-stream and then use the combiner to combine the results. Consider this example: 1 Stream . of ( 1 , 2 , 3 , 4 ). reduce ( 1 , ( x , y ) -> x * y , ( x , y ) -> x * y ); To allow us to run reduce in parallel, however, there are several rules that the identity , the accumulator , and the combiner must follow: combiner.apply(identity, i) must be equal to i . The combiner and the accumulator must be associative -- the order of applying must not matter. The combiner and the accumulator must be compatible -- combiner.apply(u, accumulator.apply(identity, t)) must equal to accumulator.apply(u, t) The multiplication example above meetings the three rules: i * 1 equals i (x * y) * z equals x * (y * z) u * (1 * t) equals u * t","title":"Associativity"},{"location":"34-parallel.html#performance-of-parallel-stream","text":"Let's go back to: 1 2 3 4 IntStream . range ( 2_030_000 , 2_040_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); How much time can we save by parallelizing the code above? Let's use the Instant and Duration class from Java to help us: 1 2 3 4 5 6 7 Instant start = Instant . now (); long howMany = IntStream . range ( 2_000_000 , 3_000_000 ) . filter ( x -> isPrime ( x )) . parallel () . count (); Instant stop = Instant . now (); System . out . println ( howMany + \" \" + Duration . between ( start , stop ). toMillis () + \" ms\" ); The code above measures roughly the time it takes to count the number of primes between 2 million and 3 million. On my iMac, it takes slightly more than 1 second. If I remove parallel() , it takes about 450-550 ms. So we gain about 50% performance. Can we parallelize some more? Remember how we implement isPrime 2 1 2 3 4 boolean isPrime ( int n ) { return IntStream . range ( 2 , ( int ) Math . sqrt ( n ) + 1 ) . noneMatch ( x -> n % x == 0 ); } Let's parallelize this to make this even faster! 1 2 3 4 5 boolean isPrime ( int n ) { return IntStream . range ( 2 , ( int ) Math . sqrt ( n ) + 1 ) . parallel () . noneMatch ( x -> n % x == 0 ); } If you run the code above, however, you will find that the code is not as fast as we expect. On my iMac, it takes about 18s, about 18 times slower! Parallelizing a stream does not always improve the performance . Creating a thread to run a task incurs some overhead, and the overhead of creating too many threads might outweigh the benefits of parallelization.","title":"Performance of Parallel Stream"},{"location":"34-parallel.html#ordered-vs-unordered-source","text":"Whether or not the stream elements are ordered or unordered also plays a role in the performance of parallel stream operations. A stream may define an encounter order . Streams created from iterate , ordered collections (e.g., List or arrays), from of , are ordered. Stream created from generate or unordered collections (e.g., Set ) are unordered. Some stream operations respect the encounter order. For instance, both distinct and sorted preserve the original order of elements (if ordering is preserved, we say that an operation is stable ). The parallel version of findFirst , limit , and skip can be expensive on an ordered stream, since it needs to coordinate between the streams to maintain the order. If we have an ordered stream and respecting the original order is not important, we can call unordered() as part of the chain command to make the parallel operations much more efficient. The following, for example, takes about 700 ms on my iMac: 1 2 3 4 5 Stream . iterate ( 0 , i -> i + 7 ) . parallel () . limit ( 10_000_000 ) . filter ( i -> i % 64 == 0 ) . forEachOrdered ( i -> { }); But, with unordered() inserted, it takes about 350ms, a 2x speedup! 1 2 3 4 5 6 Stream . iterate ( 0 , i -> i + 7 ) . parallel () . unordered () . limit ( 10_000_000 ) . filter ( i -> i % 64 == 0 ) . forEachOrdered ( i -> { }); iPhone 12 comes with an A14 Bionic chip with six cores. The fastest supercomputer in the world as of this writing, the Fugaku , has 158,976 processors, each has 48 cores. \u21a9 This is a more efficient version of the code you have seen since it stops testing after the square root of the \\(n\\) . \u21a9","title":"Ordered vs. Unordered Source"},{"location":"35-thread.html","text":"Unit 35: Threads Synchronous Programming So far, when we invoke a method in Java, we expect the method to return us a value when it is done. If the method is not done, the execution of our program stalls, waiting for the method to complete its execution. Only after the method returns can the execution of our program continue. We say that the method blocks until it returns. Such a programming model is known as synchronous programming . Synchronous programming is not very efficient, especially when there are frequent method calls that block for a long period (such as methods that involve expensive computations or reading from a remote server over the Internet). What if we want our program to do something while we wait for the method to return? For instance, refreshing the UI, or do other computations? Threads One way to achieve this is to use threads . A thread is a single flow of execution in a program. Since the beginning of this module, we have been writing single-thread programs, except for parallel streams in Unit 34. Java provides a class called java.lang.Thread that we can use to encapsulate a function to run in a separate thread. The following example how we can create and run two threads: 1 2 3 4 5 6 7 8 9 10 11 new Thread (() -> { for ( int i = 1 ; i < 100 ; i += 1 ) { System . out . print ( \"_\" ); } }). start (); new Thread (() -> { for ( int i = 2 ; i < 100 ; i += 1 ) { System . out . print ( \"*\" ); } }). start (); The new Thread(..) is our usual constructor to create a Thread instance. The constructor takes a Runnable instance as an argument. A Runnable is a functional interface with a method run() that takes in no parameter and returns void . With each Thread instance, we run start() , which causes the given lambda expression to run. Note that start() returns immediately. It does not return only after the given lambda expression completes its execution. This property differs from what we are used to, where a method blocks until the task given completes. This is known as asynchronous execution. The two threads above now run in two separate sequences of execution. The operating system has a scheduler that decides which threads to run when, and on which core (or which processor). You might see different interleaving of executions every time you run the same program. Java provides more than one way to create a thread. The Thread class also contains methods that we can use to query and control, in a finer grain manner, how the thread could be executed. Names Every thread in Java has a name, printing out its name is useful for peeking under the hood to see what is happening. We can use the instance method getName() to find out the name of a thread, and the class method Thread.currentThread() to get the reference of the current running thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 System . out . println ( Thread . currentThread (). getName ()); new Thread (() -> { System . out . print ( Thread . currentThread (). getName ()); for ( int i = 1 ; i < 100 ; i += 1 ) { System . out . print ( \"_\" ); } }). start (); new Thread (() -> { System . out . print ( Thread . currentThread (). getName ()); for ( int i = 2 ; i < 100 ; i += 1 ) { System . out . print ( \"*\" ); } }). start (); Note that the above will also print the name of the thread called main , which is a thread created automatically for us every time our program runs and the class method main() is invoked. With this method, you can now \"visualize\" how many parallel threads are created when you invoke a parallel stream. Try 1 2 3 4 5 6 Stream . of ( 1 , 2 , 3 , 4 ) . parallel () . reduce ( 0 , ( x , y ) -> { System . out . println ( Thread . currentThread (). getName ()); return x + y ; }); and you will see something like this: 1 2 3 4 5 6 7 main ForkJoinPool.commonPool-worker-5 ForkJoinPool.commonPool-worker-5 ForkJoinPool.commonPool-worker-9 ForkJoinPool.commonPool-worker-3 ForkJoinPool.commonPool-worker-3 ForkJoinPool.commonPool-worker-3 being printed. This shows four concurrent threads running to reduce the stream of 1, 2, 3, 4 (including main ). If you remove the parallel() call, then only main is printed, showing the reduction being done sequentially in a single thread. 1 2 3 4 5 Stream . of ( 1 , 2 , 3 , 4 ) . reduce ( 0 , ( x , y ) -> { System . out . println ( Thread . currentThread (). getName ()); return x + y ; }); Sleep Another useful method in the Thread class is sleep . You can cause the current execution thread to pause execution immediately for a given period (in milliseconds). After the sleep timer is over, the thread is ready to be chosen by the scheduler to run again. The following code prints a \".\" on-screen every second while another expensive computation is running. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Thread findPrime = new Thread (() -> { System . out . println ( Stream . iterate ( 2 , i -> i + 1 ) . filter ( i -> isPrime ( i )) . limit ( 1_000_000L ) . reduce (( x , y ) -> y ) . orElse ( null )); }); findPrime . start (); while ( findPrime . isAlive ()) { try { Thread . sleep ( 1000 ); System . out . print ( \".\" ); } catch ( InterruptedException e ) { System . out . print ( \"interrupted\" ); } } In our examples, we often use Thread.sleep() in our methods to pretend that we are working hard on expensive computation to keep our examples simple. Two more things to note: - The example above shows how we use isAlive() to periodically check if another thread is still running. - The program exits only after all the threads created run to their completion.","title":"35. Threads"},{"location":"35-thread.html#unit-35-threads","text":"","title":"Unit 35: Threads"},{"location":"35-thread.html#synchronous-programming","text":"So far, when we invoke a method in Java, we expect the method to return us a value when it is done. If the method is not done, the execution of our program stalls, waiting for the method to complete its execution. Only after the method returns can the execution of our program continue. We say that the method blocks until it returns. Such a programming model is known as synchronous programming . Synchronous programming is not very efficient, especially when there are frequent method calls that block for a long period (such as methods that involve expensive computations or reading from a remote server over the Internet). What if we want our program to do something while we wait for the method to return? For instance, refreshing the UI, or do other computations?","title":"Synchronous Programming"},{"location":"35-thread.html#threads","text":"One way to achieve this is to use threads . A thread is a single flow of execution in a program. Since the beginning of this module, we have been writing single-thread programs, except for parallel streams in Unit 34. Java provides a class called java.lang.Thread that we can use to encapsulate a function to run in a separate thread. The following example how we can create and run two threads: 1 2 3 4 5 6 7 8 9 10 11 new Thread (() -> { for ( int i = 1 ; i < 100 ; i += 1 ) { System . out . print ( \"_\" ); } }). start (); new Thread (() -> { for ( int i = 2 ; i < 100 ; i += 1 ) { System . out . print ( \"*\" ); } }). start (); The new Thread(..) is our usual constructor to create a Thread instance. The constructor takes a Runnable instance as an argument. A Runnable is a functional interface with a method run() that takes in no parameter and returns void . With each Thread instance, we run start() , which causes the given lambda expression to run. Note that start() returns immediately. It does not return only after the given lambda expression completes its execution. This property differs from what we are used to, where a method blocks until the task given completes. This is known as asynchronous execution. The two threads above now run in two separate sequences of execution. The operating system has a scheduler that decides which threads to run when, and on which core (or which processor). You might see different interleaving of executions every time you run the same program. Java provides more than one way to create a thread. The Thread class also contains methods that we can use to query and control, in a finer grain manner, how the thread could be executed.","title":"Threads"},{"location":"35-thread.html#names","text":"Every thread in Java has a name, printing out its name is useful for peeking under the hood to see what is happening. We can use the instance method getName() to find out the name of a thread, and the class method Thread.currentThread() to get the reference of the current running thread. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 System . out . println ( Thread . currentThread (). getName ()); new Thread (() -> { System . out . print ( Thread . currentThread (). getName ()); for ( int i = 1 ; i < 100 ; i += 1 ) { System . out . print ( \"_\" ); } }). start (); new Thread (() -> { System . out . print ( Thread . currentThread (). getName ()); for ( int i = 2 ; i < 100 ; i += 1 ) { System . out . print ( \"*\" ); } }). start (); Note that the above will also print the name of the thread called main , which is a thread created automatically for us every time our program runs and the class method main() is invoked. With this method, you can now \"visualize\" how many parallel threads are created when you invoke a parallel stream. Try 1 2 3 4 5 6 Stream . of ( 1 , 2 , 3 , 4 ) . parallel () . reduce ( 0 , ( x , y ) -> { System . out . println ( Thread . currentThread (). getName ()); return x + y ; }); and you will see something like this: 1 2 3 4 5 6 7 main ForkJoinPool.commonPool-worker-5 ForkJoinPool.commonPool-worker-5 ForkJoinPool.commonPool-worker-9 ForkJoinPool.commonPool-worker-3 ForkJoinPool.commonPool-worker-3 ForkJoinPool.commonPool-worker-3 being printed. This shows four concurrent threads running to reduce the stream of 1, 2, 3, 4 (including main ). If you remove the parallel() call, then only main is printed, showing the reduction being done sequentially in a single thread. 1 2 3 4 5 Stream . of ( 1 , 2 , 3 , 4 ) . reduce ( 0 , ( x , y ) -> { System . out . println ( Thread . currentThread (). getName ()); return x + y ; });","title":"Names"},{"location":"35-thread.html#sleep","text":"Another useful method in the Thread class is sleep . You can cause the current execution thread to pause execution immediately for a given period (in milliseconds). After the sleep timer is over, the thread is ready to be chosen by the scheduler to run again. The following code prints a \".\" on-screen every second while another expensive computation is running. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Thread findPrime = new Thread (() -> { System . out . println ( Stream . iterate ( 2 , i -> i + 1 ) . filter ( i -> isPrime ( i )) . limit ( 1_000_000L ) . reduce (( x , y ) -> y ) . orElse ( null )); }); findPrime . start (); while ( findPrime . isAlive ()) { try { Thread . sleep ( 1000 ); System . out . print ( \".\" ); } catch ( InterruptedException e ) { System . out . print ( \"interrupted\" ); } } In our examples, we often use Thread.sleep() in our methods to pretend that we are working hard on expensive computation to keep our examples simple. Two more things to note: - The example above shows how we use isAlive() to periodically check if another thread is still running. - The program exits only after all the threads created run to their completion.","title":"Sleep"},{"location":"36-async.html","text":"Unit 36: Asynchronous Programming Limitations of Thread Writing code directly with the Thread class gives us control on how many threads to create, what they do, how they communicate with each other, and some level of control on which thread gets executed when. While Java's Thread is already a higher-level abstraction compared to, say, the pthread library in C and C++, it still takes a fair amount of effort to write complex multi-threaded programs in Java. Consider the situation where we have a series of tasks that we wish to execute concurrently and we want to organize them such that: - Task A must start first - When Task A is done, we take the result from Task A, and pass it to Tasks B, C, and D. - We want Task B and C to complete before we pass their results to Task E. We also want to handle exceptions gracefully -- if one of the tasks encounters an exception, the other tasks not dependent on it should still be completed. Implementing the above using Thread requires careful coordination. Firstly, there are no methods in Thread that return a value. We need the threads to communicate through shared variables. Secondly, there is no mechanism to specify the execution order and dependencies among them -- which thread to start after another thread completes. Finally, we have to consider the possibility of exceptions in each of our tasks. Another drawback of using Thread is its overhead -- the creation of Thread instances takes up some resources in Java. As much as possible, we should reuse our Thread instances to run multiple tasks. For instance, the same Thread instance could have run Tasks A, B, and E in the example above. Managing the Thread instances itself and deciding which Thread instance should run which Thread is a gigantic undertaking. A Higher-Level Abstraction What we need is a higher-level abstraction that allows programmers to focus on specifying the tasks and their dependencies, without worrying about the details. Suppose we want to run the tasks in a single thread, we could do the following: 1 2 3 4 5 6 7 8 int foo ( int x ) { int a = taskA ( x ); int b = taskB ( a ); int c = taskC ( a ); int d = taskD ( a ); int e = taskE ( b , c ) return e ; } We could also use monads to chain up the computations. Let's say that one of the tasks might not produce a value, then we can use the Maybe<T> monad: 1 2 3 4 5 6 7 8 Maybe < Integer > foo ( int x ) { Maybe < Integer > a = Maybe . of ( x ); Maybe < Integer > b = a . flatMap ( i -> taskB ( i )); Maybe < Integer > c = a . flatMap ( i -> taskC ( i )); Maybe < Integer > d = a . flatMap ( i -> taskD ( i )); Maybe < Integer > e = b . combine ( c , ( i , j ) -> taskE ( i , j )); return e ; } If we want to perform the tasks lazily, then we can use the Lazy<T> monad: 1 2 3 4 5 6 7 8 Lazy < Integer > foo ( int x ) { Lazy < Integer > a = Lazy . of ( x ); Lazy < Integer > b = a . flatMap ( i -> taskB ( i )); Lazy < Integer > c = a . flatMap ( i -> taskC ( i )); Lazy < Integer > d = a . flatMap ( i -> taskD ( i )); Lazy < Integer > e = b . combine ( c , ( i , j ) -> taskE ( i , j )); return e ; } Wouldn't it be nice if there is a monad that allows us to perform the tasks concurrently? java.util.concurrent.CompletableFuture does just that! Here is an example of how to use it: 1 2 3 4 5 6 7 8 CompletableFuture < Integer > foo ( int x ) { CompletableFuture < Integer > a = CompletableFuture . completedFuture ( x ); CompletableFuture < Integer > b = a . thenComposeAsync ( i -> taskB ( i )); CompletableFuture < Integer > c = a . thenComposeAsync ( i -> taskC ( i )); CompletableFuture < Integer > d = a . thenComposeAsync ( i -> taskD ( i )); CompletableFuture < Integer > e = b . thenCombineAsync ( c , ( i , j ) -> taskE ( i , j )); return e ; } We can then run foo(x).get() to wait for all the concurrent tasks to complete and return us the value. CompletableFuture<T> is a monad that encapsulates a value that is either there or not there yet . Such an abstraction is also known as a promise in other languages (e.g., Promise in JavaScript and std::promise in C++) -- it encapsulates the promise to produce a value. The CompletableFuture Monad Let's now examine the CompletableFuture monad in more detail. A key property of CompletableFuture is whether the value it promises is ready -- i.e., the tasks that it encapsulates has completed or not. Creating a CompletableFuture There are several ways we can create a CompletableFuture<T> instance: Use the completedFuture method. This method is equivalent to creating a task that is already completed and return us a value. Use the runAsync method that takes in a Runnable lambda expression. runAsync has the return type of CompletableFuture<Void> . The returned CompletableFuture instance completes when the given lambda expression finishes. Use the supplyAsync method that takes in a Supplier<T> lambda expression. supplyAsync has the return type of CompletableFuture<T> . The returned CompletableFuture instance completes when the given lambda expression finishes. We can also create a CompletableFuture that relies on other CompletableFuture instances. We can use allOf or anyOf methods for this. Both of these methods take in a variable number of other CompletableFuture instances. A new CompletableFuture created with allOf is completed only when all the given CompletableFuture completes. On the other hand, a new CompletableFuture created with anyOf is completed when any one of the given CompletableFuture completes. Chaining CompletableFuture The usefulness of CompletableFuture comes from the ability to chain them up and specify a sequence of computations to be run. We have the following methods: thenApply , which is analogous to map thenCompose , which is analogous to flatMap thenCombine , which is analogous to combine The methods above run the given lambda expression in the same thread as the caller. There is also an asynchronous version ( thenApplyAsync , thenComposeAsync , thenCombineAsync ), which may cause the given lambda expression to run in a different thread (thus more concurrency). Getting The Result After we have set up all the tasks to run asynchronously, we have to wait for them to complete. We can call get() to get the result. Since get() is a synchronous call, i.e., it blocks until the CompletableFuture completes, to maximize concurrency, we should only call get() as the final step in our code. The method CompletableFuture::get throws a couple of checked exceptions: InterruptedException and ExecutionException , which we need to catch and handle. The former refers to the exception that the thread has been interrupted, while the latter refers to errors/exceptions during execution. An alternative to get() is join() . join() behaves just like get() except that no checked exception is thrown. Example Let's look at some examples. Let's reuse our method that computes the i-th prime number. 1 2 3 4 5 6 7 8 int findIthPrime ( int i ) { return Stream . iterate ( 2 , x -> x + 1 ) . filter ( x -> isPrime ( x )) . limit ( i ) . reduce (( x , y ) -> y ) . orElse ( 0 ); } Given two numbers i and j, we want to find the difference between the i-th prime number and the j-th prime number. We can first do the following: 1 2 CompletableFuture < Integer > ith = CompletableFuture . supplyAsync (() -> findIthPrime ( i )); CompletableFuture < Integer > jth = CompletableFuture . supplyAsync (() -> findIthPrime ( j )); These calls would launch two concurrent threads to compute the i-th and the j-th primes. The method calls supplyAsync returns immediately without waiting for findIthPrime to complete. Next, we can say, that, when ith and jth complete, take the value computed by them, and take the difference. We can use the thenCombine method: 1 CompletableFuture < Integer > diff = ith . thenCombine ( jth , ( x , y ) -> x - y ); This statement creates another CompletableFuture which runs asynchronously that will compute the difference between the two prime numbers. At this point, we can move on to run other tasks, or if we just want to wait until the result is ready, we call 1 diff . join (); to get the difference between the two primes 1 . Handling Exceptions One of the advantages of using CompletableFuture<T> instead of Thread to handle concurrency is its ability to handle exceptions. CompletableFuture<T> has three methods that deal with exceptions: exceptionally , whenComplete , and handle . We will focus on handle since it is the most general. Suppose we have a computation inside a CompletableFuture<T> that might throw an exception. Since the computation is asynchronous and could run in a different thread, the question of which thread should catch and handle the exception arises. CompletableFuture<T> keeps things simpler by storing the exception and passing it down the chain of calls, until join() is called. join() might throw CompletionException and whoever calls join() will be responsible for handling this exception. The CompletionException contains information on the original exception. For instance, the code below would throw a CompletionException with a NullPointerException contains within it. 1 2 3 CompletableFuture . < Integer > supplyAsync (() -> null ) . thenApply ( x -> x + 1 ) . join (); Suppose we want to continue chaining our tasks despite exceptions. We can use the handle method, to handle the exception. The handle method takes in a BiFunction (similar to cs2030s.fp.Combiner ). The first parameter to the BiFunction is the value, the second is the exception, the third is the return value. Only one of the first two parameters is not null . If the value is null , this means that an exception has been thrown. Otherwise, the exception is null 2 . Here is a simple example where we use handle to replace a default value. 1 2 3 cf . thenApply ( x -> x + 1 ) . handle (( t , e ) -> ( e == null ) ? t : 0 ) . join (); There is repeated computation in primality checks between the two calls to findIthPrime here, which one could optimize. We don't do that here to keep the example simple. \u21a9 This is another instance where Java uses null to indicates a missing value. We can't use null as a legit value due to this flawed design. \u21a9","title":"36. Async"},{"location":"36-async.html#unit-36-asynchronous-programming","text":"","title":"Unit 36: Asynchronous Programming"},{"location":"36-async.html#limitations-of-thread","text":"Writing code directly with the Thread class gives us control on how many threads to create, what they do, how they communicate with each other, and some level of control on which thread gets executed when. While Java's Thread is already a higher-level abstraction compared to, say, the pthread library in C and C++, it still takes a fair amount of effort to write complex multi-threaded programs in Java. Consider the situation where we have a series of tasks that we wish to execute concurrently and we want to organize them such that: - Task A must start first - When Task A is done, we take the result from Task A, and pass it to Tasks B, C, and D. - We want Task B and C to complete before we pass their results to Task E. We also want to handle exceptions gracefully -- if one of the tasks encounters an exception, the other tasks not dependent on it should still be completed. Implementing the above using Thread requires careful coordination. Firstly, there are no methods in Thread that return a value. We need the threads to communicate through shared variables. Secondly, there is no mechanism to specify the execution order and dependencies among them -- which thread to start after another thread completes. Finally, we have to consider the possibility of exceptions in each of our tasks. Another drawback of using Thread is its overhead -- the creation of Thread instances takes up some resources in Java. As much as possible, we should reuse our Thread instances to run multiple tasks. For instance, the same Thread instance could have run Tasks A, B, and E in the example above. Managing the Thread instances itself and deciding which Thread instance should run which Thread is a gigantic undertaking.","title":"Limitations of Thread"},{"location":"36-async.html#a-higher-level-abstraction","text":"What we need is a higher-level abstraction that allows programmers to focus on specifying the tasks and their dependencies, without worrying about the details. Suppose we want to run the tasks in a single thread, we could do the following: 1 2 3 4 5 6 7 8 int foo ( int x ) { int a = taskA ( x ); int b = taskB ( a ); int c = taskC ( a ); int d = taskD ( a ); int e = taskE ( b , c ) return e ; } We could also use monads to chain up the computations. Let's say that one of the tasks might not produce a value, then we can use the Maybe<T> monad: 1 2 3 4 5 6 7 8 Maybe < Integer > foo ( int x ) { Maybe < Integer > a = Maybe . of ( x ); Maybe < Integer > b = a . flatMap ( i -> taskB ( i )); Maybe < Integer > c = a . flatMap ( i -> taskC ( i )); Maybe < Integer > d = a . flatMap ( i -> taskD ( i )); Maybe < Integer > e = b . combine ( c , ( i , j ) -> taskE ( i , j )); return e ; } If we want to perform the tasks lazily, then we can use the Lazy<T> monad: 1 2 3 4 5 6 7 8 Lazy < Integer > foo ( int x ) { Lazy < Integer > a = Lazy . of ( x ); Lazy < Integer > b = a . flatMap ( i -> taskB ( i )); Lazy < Integer > c = a . flatMap ( i -> taskC ( i )); Lazy < Integer > d = a . flatMap ( i -> taskD ( i )); Lazy < Integer > e = b . combine ( c , ( i , j ) -> taskE ( i , j )); return e ; } Wouldn't it be nice if there is a monad that allows us to perform the tasks concurrently? java.util.concurrent.CompletableFuture does just that! Here is an example of how to use it: 1 2 3 4 5 6 7 8 CompletableFuture < Integer > foo ( int x ) { CompletableFuture < Integer > a = CompletableFuture . completedFuture ( x ); CompletableFuture < Integer > b = a . thenComposeAsync ( i -> taskB ( i )); CompletableFuture < Integer > c = a . thenComposeAsync ( i -> taskC ( i )); CompletableFuture < Integer > d = a . thenComposeAsync ( i -> taskD ( i )); CompletableFuture < Integer > e = b . thenCombineAsync ( c , ( i , j ) -> taskE ( i , j )); return e ; } We can then run foo(x).get() to wait for all the concurrent tasks to complete and return us the value. CompletableFuture<T> is a monad that encapsulates a value that is either there or not there yet . Such an abstraction is also known as a promise in other languages (e.g., Promise in JavaScript and std::promise in C++) -- it encapsulates the promise to produce a value.","title":"A Higher-Level Abstraction"},{"location":"36-async.html#the-completablefuture-monad","text":"Let's now examine the CompletableFuture monad in more detail. A key property of CompletableFuture is whether the value it promises is ready -- i.e., the tasks that it encapsulates has completed or not.","title":"The CompletableFuture Monad"},{"location":"36-async.html#creating-a-completablefuture","text":"There are several ways we can create a CompletableFuture<T> instance: Use the completedFuture method. This method is equivalent to creating a task that is already completed and return us a value. Use the runAsync method that takes in a Runnable lambda expression. runAsync has the return type of CompletableFuture<Void> . The returned CompletableFuture instance completes when the given lambda expression finishes. Use the supplyAsync method that takes in a Supplier<T> lambda expression. supplyAsync has the return type of CompletableFuture<T> . The returned CompletableFuture instance completes when the given lambda expression finishes. We can also create a CompletableFuture that relies on other CompletableFuture instances. We can use allOf or anyOf methods for this. Both of these methods take in a variable number of other CompletableFuture instances. A new CompletableFuture created with allOf is completed only when all the given CompletableFuture completes. On the other hand, a new CompletableFuture created with anyOf is completed when any one of the given CompletableFuture completes.","title":"Creating a CompletableFuture"},{"location":"36-async.html#chaining-completablefuture","text":"The usefulness of CompletableFuture comes from the ability to chain them up and specify a sequence of computations to be run. We have the following methods: thenApply , which is analogous to map thenCompose , which is analogous to flatMap thenCombine , which is analogous to combine The methods above run the given lambda expression in the same thread as the caller. There is also an asynchronous version ( thenApplyAsync , thenComposeAsync , thenCombineAsync ), which may cause the given lambda expression to run in a different thread (thus more concurrency).","title":"Chaining CompletableFuture"},{"location":"36-async.html#getting-the-result","text":"After we have set up all the tasks to run asynchronously, we have to wait for them to complete. We can call get() to get the result. Since get() is a synchronous call, i.e., it blocks until the CompletableFuture completes, to maximize concurrency, we should only call get() as the final step in our code. The method CompletableFuture::get throws a couple of checked exceptions: InterruptedException and ExecutionException , which we need to catch and handle. The former refers to the exception that the thread has been interrupted, while the latter refers to errors/exceptions during execution. An alternative to get() is join() . join() behaves just like get() except that no checked exception is thrown.","title":"Getting The Result"},{"location":"36-async.html#example","text":"Let's look at some examples. Let's reuse our method that computes the i-th prime number. 1 2 3 4 5 6 7 8 int findIthPrime ( int i ) { return Stream . iterate ( 2 , x -> x + 1 ) . filter ( x -> isPrime ( x )) . limit ( i ) . reduce (( x , y ) -> y ) . orElse ( 0 ); } Given two numbers i and j, we want to find the difference between the i-th prime number and the j-th prime number. We can first do the following: 1 2 CompletableFuture < Integer > ith = CompletableFuture . supplyAsync (() -> findIthPrime ( i )); CompletableFuture < Integer > jth = CompletableFuture . supplyAsync (() -> findIthPrime ( j )); These calls would launch two concurrent threads to compute the i-th and the j-th primes. The method calls supplyAsync returns immediately without waiting for findIthPrime to complete. Next, we can say, that, when ith and jth complete, take the value computed by them, and take the difference. We can use the thenCombine method: 1 CompletableFuture < Integer > diff = ith . thenCombine ( jth , ( x , y ) -> x - y ); This statement creates another CompletableFuture which runs asynchronously that will compute the difference between the two prime numbers. At this point, we can move on to run other tasks, or if we just want to wait until the result is ready, we call 1 diff . join (); to get the difference between the two primes 1 .","title":"Example"},{"location":"36-async.html#handling-exceptions","text":"One of the advantages of using CompletableFuture<T> instead of Thread to handle concurrency is its ability to handle exceptions. CompletableFuture<T> has three methods that deal with exceptions: exceptionally , whenComplete , and handle . We will focus on handle since it is the most general. Suppose we have a computation inside a CompletableFuture<T> that might throw an exception. Since the computation is asynchronous and could run in a different thread, the question of which thread should catch and handle the exception arises. CompletableFuture<T> keeps things simpler by storing the exception and passing it down the chain of calls, until join() is called. join() might throw CompletionException and whoever calls join() will be responsible for handling this exception. The CompletionException contains information on the original exception. For instance, the code below would throw a CompletionException with a NullPointerException contains within it. 1 2 3 CompletableFuture . < Integer > supplyAsync (() -> null ) . thenApply ( x -> x + 1 ) . join (); Suppose we want to continue chaining our tasks despite exceptions. We can use the handle method, to handle the exception. The handle method takes in a BiFunction (similar to cs2030s.fp.Combiner ). The first parameter to the BiFunction is the value, the second is the exception, the third is the return value. Only one of the first two parameters is not null . If the value is null , this means that an exception has been thrown. Otherwise, the exception is null 2 . Here is a simple example where we use handle to replace a default value. 1 2 3 cf . thenApply ( x -> x + 1 ) . handle (( t , e ) -> ( e == null ) ? t : 0 ) . join (); There is repeated computation in primality checks between the two calls to findIthPrime here, which one could optimize. We don't do that here to keep the example simple. \u21a9 This is another instance where Java uses null to indicates a missing value. We can't use null as a legit value due to this flawed design. \u21a9","title":"Handling Exceptions"},{"location":"37-forkjoin.html","text":"Unit 37: Fork and Join Thread Pool We now look under the hood of parallel Stream and CompletableFuture<T> to explore how Java manages its threads. Recall that creating and destroying threads is not cheap, and as much as possible we should reuse existing threads to perform different tasks. This goal can be achieved by using a thread pool . A thread pool consists of (i) a collection of threads, each waiting for a task to execute, (ii) a collection of tasks to be executed. Typically the tasks are put in a queue, and an idle thread picks up a task from the queue to execute. To illustrate this concept, here is a trivial thread pool with a single thread: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Queue < Runnable > queue ; new Thread (() -> { while ( true ) { if ( ! queue . isEmpty ()) { Runnable r = queue . dequeue (); r . run (); } } }). start (); for ( int i = 0 ; i < 100 ; i ++ ) { int count = i ; queue . add (() -> System . out . println ( count )); } We assume that Queue<T> can be safely modified concurrently (i.e., it is thread-safe) in the sample code above. Otherwise, just like the example you have seen in parallel streams with List , items might be lost. Fork and Join Java implements a thread pool called ForkJoinPool that is fine-tuned for the fork-join model of recursive parallel execution. The Fork-join model is essentially a parallel divide-and-conquer model of computation. The general idea for the fork-join model is to solve a problem by breaking up the problem into identical problems but with smaller size ( fork ), then solve the smaller version of the problem recursively, then combine the results ( join ). This repeats recursively until the problem size is small enough -- we have reached the base case and so we just solve the problem sequentially without further parallelization. In Java, we can create a task that we can fork and join as an instance of abstract class RecursiveTask<T> . RecursiveTask<T> supports the methods fork() , which submits a smaller version of the task for execution, and join() (which waits for the smaller tasks to complete and return). RecursiveTask<T> has an abstract method compute() , which we, as the client, have to define to specify what computation we want to compute. Here is a simple RecursiveTask<T> that recursively sums up the content of an array: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Summer extends RecursiveTask < Integer > { private static final int FORK_THRESHOLD = 2 ; private int low ; private int high ; private int [] array ; public Summer ( int low , int high , int [] array ) { this . low = low ; this . high = high ; this . array = array ; } @Override protected Integer compute () { // stop splitting into subtask if array is already small. if ( high - low < FORK_THRESHOLD ) { int sum = 0 ; for ( int i = low ; i < high ; i ++ ) { sum += array [ i ] ; } return sum ; } int middle = ( low + high ) / 2 ; Summer left = new Summer ( low , middle , array ); Summer right = new Summer ( middle , high , array ); left . fork (); return right . compute () + left . join (); } } To run this task, we run: 1 2 Summer task = new Summer ( 0 , array . length , array ); int sum = task . compute (); The line task.compute() above is just like another method invocation. It causes the method compute() to be invoked, and if the array is big enough, two new Summer instances, left and right , to be created. left . We then call left.fork() , which adds the tasks to a thread pool so that one of the threads can call its compute() method. We subsequently call right.compute() (which is a normal method call). Finally, we call left.join() , which blocks until the computation of the recursive sum is completed and returned. We add the result from left and right together and return the sum. There are other ways we can combine and order the execution of fork() , compute() , and join() . Some are better than others. We will explore more in the exercises. ForkJoinPool Let's now explore the idea behind how Java manages the thread pool with fork-join tasks. The details are beyond the scope of this module, but it would be interesting to note a few key points, as follows: Each thread has a queue of tasks. When a thread is idle, it checks its queue of tasks. If the queue is not empty, it picks up a task at the head of the queue to execute (e.g., invoke its compute() method). Otherwise, if the queue is empty, it picks up a task from the tail of the queue of another thread to run. The latter is a mechanism called work stealing . When fork() is called, the caller adds itself to the head of the queue of the executing thread. This is done so that the most recently forked task gets executed next, similar to how normal recursive calls. When join() is called, several cases might happen. If the subtask to be joined hasn't been executed, its compute() method is called and the subtask is executed. If the subtask to be joined has been completed (some other thread has stolen this and completed it), then the result is read, and join() returns. If the subtask to be joined has been stolen and is being executed by another thread, then the current thread finds some other tasks to work on either in its local queue or steal another task from another queue. The beauty of the mechanism here is that the threads always look for something to do and they cooperate to get as much work done as possible. The mechanism here is similar to that implemented in .NET and Rust. Order of fork() and join() One implication of how ForkJoinPool adds and removes tasks from the queue is the order in which we call fork() and join() . Since the most recently forked task is likely to be executed next, we should join() the most recent fork() task first. In other words, the order of forking should be the reverse of the order of joining. In the class Summer above, 1 2 3 left.fork(); right.fork(); return right.join() + left.join(); is more efficient than 1 2 3 left.fork(); right.fork(); return left.join() + right.join();","title":"37. Fork and Join"},{"location":"37-forkjoin.html#unit-37-fork-and-join","text":"","title":"Unit 37: Fork and Join"},{"location":"37-forkjoin.html#thread-pool","text":"We now look under the hood of parallel Stream and CompletableFuture<T> to explore how Java manages its threads. Recall that creating and destroying threads is not cheap, and as much as possible we should reuse existing threads to perform different tasks. This goal can be achieved by using a thread pool . A thread pool consists of (i) a collection of threads, each waiting for a task to execute, (ii) a collection of tasks to be executed. Typically the tasks are put in a queue, and an idle thread picks up a task from the queue to execute. To illustrate this concept, here is a trivial thread pool with a single thread: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Queue < Runnable > queue ; new Thread (() -> { while ( true ) { if ( ! queue . isEmpty ()) { Runnable r = queue . dequeue (); r . run (); } } }). start (); for ( int i = 0 ; i < 100 ; i ++ ) { int count = i ; queue . add (() -> System . out . println ( count )); } We assume that Queue<T> can be safely modified concurrently (i.e., it is thread-safe) in the sample code above. Otherwise, just like the example you have seen in parallel streams with List , items might be lost.","title":"Thread Pool"},{"location":"37-forkjoin.html#fork-and-join","text":"Java implements a thread pool called ForkJoinPool that is fine-tuned for the fork-join model of recursive parallel execution. The Fork-join model is essentially a parallel divide-and-conquer model of computation. The general idea for the fork-join model is to solve a problem by breaking up the problem into identical problems but with smaller size ( fork ), then solve the smaller version of the problem recursively, then combine the results ( join ). This repeats recursively until the problem size is small enough -- we have reached the base case and so we just solve the problem sequentially without further parallelization. In Java, we can create a task that we can fork and join as an instance of abstract class RecursiveTask<T> . RecursiveTask<T> supports the methods fork() , which submits a smaller version of the task for execution, and join() (which waits for the smaller tasks to complete and return). RecursiveTask<T> has an abstract method compute() , which we, as the client, have to define to specify what computation we want to compute. Here is a simple RecursiveTask<T> that recursively sums up the content of an array: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Summer extends RecursiveTask < Integer > { private static final int FORK_THRESHOLD = 2 ; private int low ; private int high ; private int [] array ; public Summer ( int low , int high , int [] array ) { this . low = low ; this . high = high ; this . array = array ; } @Override protected Integer compute () { // stop splitting into subtask if array is already small. if ( high - low < FORK_THRESHOLD ) { int sum = 0 ; for ( int i = low ; i < high ; i ++ ) { sum += array [ i ] ; } return sum ; } int middle = ( low + high ) / 2 ; Summer left = new Summer ( low , middle , array ); Summer right = new Summer ( middle , high , array ); left . fork (); return right . compute () + left . join (); } } To run this task, we run: 1 2 Summer task = new Summer ( 0 , array . length , array ); int sum = task . compute (); The line task.compute() above is just like another method invocation. It causes the method compute() to be invoked, and if the array is big enough, two new Summer instances, left and right , to be created. left . We then call left.fork() , which adds the tasks to a thread pool so that one of the threads can call its compute() method. We subsequently call right.compute() (which is a normal method call). Finally, we call left.join() , which blocks until the computation of the recursive sum is completed and returned. We add the result from left and right together and return the sum. There are other ways we can combine and order the execution of fork() , compute() , and join() . Some are better than others. We will explore more in the exercises.","title":"Fork and Join"},{"location":"37-forkjoin.html#forkjoinpool","text":"Let's now explore the idea behind how Java manages the thread pool with fork-join tasks. The details are beyond the scope of this module, but it would be interesting to note a few key points, as follows: Each thread has a queue of tasks. When a thread is idle, it checks its queue of tasks. If the queue is not empty, it picks up a task at the head of the queue to execute (e.g., invoke its compute() method). Otherwise, if the queue is empty, it picks up a task from the tail of the queue of another thread to run. The latter is a mechanism called work stealing . When fork() is called, the caller adds itself to the head of the queue of the executing thread. This is done so that the most recently forked task gets executed next, similar to how normal recursive calls. When join() is called, several cases might happen. If the subtask to be joined hasn't been executed, its compute() method is called and the subtask is executed. If the subtask to be joined has been completed (some other thread has stolen this and completed it), then the result is read, and join() returns. If the subtask to be joined has been stolen and is being executed by another thread, then the current thread finds some other tasks to work on either in its local queue or steal another task from another queue. The beauty of the mechanism here is that the threads always look for something to do and they cooperate to get as much work done as possible. The mechanism here is similar to that implemented in .NET and Rust.","title":"ForkJoinPool"},{"location":"37-forkjoin.html#order-of-fork-and-join","text":"One implication of how ForkJoinPool adds and removes tasks from the queue is the order in which we call fork() and join() . Since the most recently forked task is likely to be executed next, we should join() the most recent fork() task first. In other words, the order of forking should be the reverse of the order of joining. In the class Summer above, 1 2 3 left.fork(); right.fork(); return right.join() + left.join(); is more efficient than 1 2 3 left.fork(); right.fork(); return left.join() + right.join();","title":"Order of fork() and join()"},{"location":"environments.html","text":"The CS2030S Programming Environment Java version Java is a language that continues to evolve. A new version is released every six months, and by the time we are done with CS2030S this semester, we will have Java 16. For CS2030S, we will only use Java 11, the most recent version with long-term support. Programming Servers The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. For this semester, the two servers pe115 and pe116 are not available. You can choose which of the eight hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of sunfire ). If you notice that one host is crowded, you can use another host to spread out the load. While you can complete the programming assignments on your computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim or emacs ( vim is recommended and supported). Basic Requirements You need to have an SoC Unix account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need a command-line ssh client. Windows 10, macOS, and Linux users should already have it installed by default. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command line instructions below do not apply. Basic Command to SSH Run: 1 ssh <username>@<hostname> Replace <hostname> with the host you want to log into and <username> with your SoC Unix username. Note that both are case sensitive. For instance, I would do: 1 ssh ooiwt@sunfire.comp.nus.edu.sg to log into sunfire . After the command above, following the instructions on the screen. The first time you ever connect to a host, you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your password for that host. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. To complete the lab at home and to complete the two practical assessments from home, you need to access the PE hosts from outside the SoC networks. There are several ways to do this, the simplest way is to tunnel through sunfire , and this is the recommended method, as no extra software is required. Option 1: Tunneling through Sunfire (Recommended for those in Singapore) SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco (See more details here ). Since sunfire is within the SoC network, you can log into sunfire first, then from sunfire , log into one of the PE nodes from sunfire . These two steps can be done with one command: 1 ssh -t <username1>@sunfire.comp.nus.edu.sg ssh <username2>@pe1xx.comp.nus.edu.sg Note that in non-exam scenarios, username1 and username2 are both your SoC Unix username. You will be prompted for password twice. The first prompt will be for your password to sunfire , and the second, to pe1xx . For practical exams, you will be issued a special exam account to log into the PE hosts. In this case, username1 will be your SoC Unix username and username2 will be your special exam account. Students not in Singapore will need to access sunfire via SoC VPN. In which case, Option 2 would be better. Option 2: Using SoC VPN (Recommended only for not in Singapore) To set up the SOC Virtual Private Network (VPN), see instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to sunfire as expected. Therefore, Windows 10 users should download and install FortiClient VPN directly from FortiClient's website . Once you are connected to SoC VPN, you can run 1 ssh <username>@pe1xx.comp.nus.edu.sg Setting up SSH Keys Once you are comfortable with Unix, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on the remote host you want to log into. On this remote host, run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on the remote host are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote host are set to 600 . Once set up, you need not enter your password every time you run ssh or scp . Troubleshooting If you get the following error: ssh: Could not resolve hostname pe1xx.comp.nus.edu.sg ssh cannot recognize the name pe1xx , likely, you are not tunneling connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC Unix account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi ssh: connect to host sunfire.comp.nus.edu.sg port 22: Operation timed out It means that you failed to connect to sunfire via ssh . There could be two reasons for this: (i) sunfire or its ssh service is down; (ii) you are connecting via a network where sunfire is not accessible (such as outside Singapore). The likelihood of (i) is small. The more likely scenario is (ii), in which case, you should be able to solve it by connecting to SoC VPN. Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Programming Environments"},{"location":"environments.html#the-cs2030s-programming-environment","text":"","title":"The CS2030S Programming Environment"},{"location":"environments.html#java-version","text":"Java is a language that continues to evolve. A new version is released every six months, and by the time we are done with CS2030S this semester, we will have Java 16. For CS2030S, we will only use Java 11, the most recent version with long-term support.","title":"Java version"},{"location":"environments.html#programming-servers","text":"The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. For this semester, the two servers pe115 and pe116 are not available. You can choose which of the eight hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of sunfire ). If you notice that one host is crowded, you can use another host to spread out the load. While you can complete the programming assignments on your computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim or emacs ( vim is recommended and supported).","title":"Programming Servers"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC Unix account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need a command-line ssh client. Windows 10, macOS, and Linux users should already have it installed by default. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command line instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#basic-command-to-ssh","text":"Run: 1 ssh <username>@<hostname> Replace <hostname> with the host you want to log into and <username> with your SoC Unix username. Note that both are case sensitive. For instance, I would do: 1 ssh ooiwt@sunfire.comp.nus.edu.sg to log into sunfire . After the command above, following the instructions on the screen. The first time you ever connect to a host, you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your password for that host.","title":"Basic Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. To complete the lab at home and to complete the two practical assessments from home, you need to access the PE hosts from outside the SoC networks. There are several ways to do this, the simplest way is to tunnel through sunfire , and this is the recommended method, as no extra software is required.","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#option-1-tunneling-through-sunfire-recommended-for-those-in-singapore","text":"SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco (See more details here ). Since sunfire is within the SoC network, you can log into sunfire first, then from sunfire , log into one of the PE nodes from sunfire . These two steps can be done with one command: 1 ssh -t <username1>@sunfire.comp.nus.edu.sg ssh <username2>@pe1xx.comp.nus.edu.sg Note that in non-exam scenarios, username1 and username2 are both your SoC Unix username. You will be prompted for password twice. The first prompt will be for your password to sunfire , and the second, to pe1xx . For practical exams, you will be issued a special exam account to log into the PE hosts. In this case, username1 will be your SoC Unix username and username2 will be your special exam account. Students not in Singapore will need to access sunfire via SoC VPN. In which case, Option 2 would be better.","title":"Option 1: Tunneling through Sunfire (Recommended for those in Singapore)"},{"location":"environments.html#option-2-using-soc-vpn-recommended-only-for-not-in-singapore","text":"To set up the SOC Virtual Private Network (VPN), see instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to sunfire as expected. Therefore, Windows 10 users should download and install FortiClient VPN directly from FortiClient's website . Once you are connected to SoC VPN, you can run 1 ssh <username>@pe1xx.comp.nus.edu.sg","title":"Option 2: Using SoC VPN (Recommended only for not in Singapore)"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with Unix, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on the remote host you want to log into. On this remote host, run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on the remote host are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote host are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"environments.html#troubleshooting","text":"If you get the following error: ssh: Could not resolve hostname pe1xx.comp.nus.edu.sg ssh cannot recognize the name pe1xx , likely, you are not tunneling connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC Unix account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi ssh: connect to host sunfire.comp.nus.edu.sg port 22: Operation timed out It means that you failed to connect to sunfire via ssh . There could be two reasons for this: (i) sunfire or its ssh service is down; (ii) you are connecting via a network where sunfire is not accessible (such as outside Singapore). The likelihood of (i) is small. The more likely scenario is (ii), in which case, you should be able to solve it by connecting to SoC VPN. Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connected to the PE hosts, but you have no access to your home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Troubleshooting"},{"location":"javadoc.html","text":"Javadoc Why is documentation important One of the goals of CS2030S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S labs) and you are writing code that no one else will read except you. CS2030S prepares you to work in software engineering teams in many ways, and one of the ways is to get you to document your code. javadoc is a tool used to document Java code. It automatically generates HTML documentation from the comments in your code. The Java API that you have seen are generated from javadoc . How to comment for javadoc javadoc distinguishes between normal comments and comments meant for javadoc by how we \"fence\" the comments. A javadoc comment always starts with /** (note the double asterisks) and ends with */ and is always placed immediately before a class, an interface, a constructor, a method, or field declaration. Example: 1 2 3 4 5 /** * Encapsulates a circle on a 2D plane. The `Circle` class supports operators * supported includes (i) checking if a point is contained in the circle, * and (ii) moving the circle around to a new position. */ The first sentence is the summary sentence. We should follow some style guidelines when writing the summary sentence (see below). javadoc comments supports HTML tags. If you are not familiar with HTML, that is fine. We will tell you what you need to know below. Tags javadoc supports tags. Here are some tags that we would like you to use: @param <name> <description> : describe the parameter @param <<name>> <description> : describe the type parameter @return <description> describe the return value @throws <class name> <description> describe what the exception being thrown and what are the possible reasons Style If you want to break your comments into paragraphs, insert one blank line between paragraphs. Start a new paragraph with HTML tag <p> with no space after, and end your paragraph with HTML tag </p> . You should use the tags @param @return and @throws in that order, and they should never appear without a description. The summary should be short and succinct. It may not be a complete sentence, but it should still be capitalized and ends with a period. E.g., /** Encapsulates a circle on 2D plane. .. */ You don't need to write javadoc for self-explanatory, simple, obvious, methods. e.g., getX() , unless you want to explain what x means. How to generate javadoc In its simplest form, you can generate javadoc like this: 1 javadoc *.java This will generate the HTML files in your current directory. To avoid clutters, I recommend that you specify the output directory, e.g., 1 javadoc *.java -d docs This will generate the documentation and put it under the docs subdirectory. javadoc by default generates documents only for public classes, fields, and methods. To generate documentation for everything, run 1 javadoc *.java -d docs -private If you generate the documentation on your computer, you can view it by opening up the file index.html in your browser. See Also Oracle's javadoc guide","title":"JavaDoc Guide"},{"location":"javadoc.html#javadoc","text":"","title":"Javadoc"},{"location":"javadoc.html#why-is-documentation-important","text":"One of the goals of CS2030S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S labs) and you are writing code that no one else will read except you. CS2030S prepares you to work in software engineering teams in many ways, and one of the ways is to get you to document your code. javadoc is a tool used to document Java code. It automatically generates HTML documentation from the comments in your code. The Java API that you have seen are generated from javadoc .","title":"Why is documentation important"},{"location":"javadoc.html#how-to-comment-for-javadoc","text":"javadoc distinguishes between normal comments and comments meant for javadoc by how we \"fence\" the comments. A javadoc comment always starts with /** (note the double asterisks) and ends with */ and is always placed immediately before a class, an interface, a constructor, a method, or field declaration. Example: 1 2 3 4 5 /** * Encapsulates a circle on a 2D plane. The `Circle` class supports operators * supported includes (i) checking if a point is contained in the circle, * and (ii) moving the circle around to a new position. */ The first sentence is the summary sentence. We should follow some style guidelines when writing the summary sentence (see below). javadoc comments supports HTML tags. If you are not familiar with HTML, that is fine. We will tell you what you need to know below.","title":"How to comment for javadoc"},{"location":"javadoc.html#tags","text":"javadoc supports tags. Here are some tags that we would like you to use: @param <name> <description> : describe the parameter @param <<name>> <description> : describe the type parameter @return <description> describe the return value @throws <class name> <description> describe what the exception being thrown and what are the possible reasons","title":"Tags"},{"location":"javadoc.html#style","text":"If you want to break your comments into paragraphs, insert one blank line between paragraphs. Start a new paragraph with HTML tag <p> with no space after, and end your paragraph with HTML tag </p> . You should use the tags @param @return and @throws in that order, and they should never appear without a description. The summary should be short and succinct. It may not be a complete sentence, but it should still be capitalized and ends with a period. E.g., /** Encapsulates a circle on 2D plane. .. */ You don't need to write javadoc for self-explanatory, simple, obvious, methods. e.g., getX() , unless you want to explain what x means.","title":"Style"},{"location":"javadoc.html#how-to-generate-javadoc","text":"In its simplest form, you can generate javadoc like this: 1 javadoc *.java This will generate the HTML files in your current directory. To avoid clutters, I recommend that you specify the output directory, e.g., 1 javadoc *.java -d docs This will generate the documentation and put it under the docs subdirectory. javadoc by default generates documents only for public classes, fields, and methods. To generate documentation for everything, run 1 javadoc *.java -d docs -private If you generate the documentation on your computer, you can view it by opening up the file index.html in your browser.","title":"How to generate javadoc"},{"location":"javadoc.html#see-also","text":"Oracle's javadoc guide","title":"See Also"},{"location":"lab.html","text":"CS2030S Lab Guide GitHub Classroom We will use GitHub Classroom for our lab release and submission for CS2030S. Here are what you need to do for every lab assignment: 1. Accept the Lab Assignment Make sure that you have logged into GitHub. If you have multiple GitHub accounts, make sure you use the one with the same GitHub username you have submitted to us . Click on the given URL to accept the lab. A repo will be created automatically for you. WARNING Do not interact with the lab repo directory using GitHub or other git commands. 2. Get a Copy on PE Hosts For your first-ever lab, you will need to create a configuration file (see the \"One-Time Setup\" section below). After that, proceed as per normal below. Run the command ~cs2030s/get-labXX (where X is the lab number) to clone a copy of the lab on your home directory. You will see a new lab directory named something like labX-username created, with the skeleton files and questions inside. You can edit the code, compile, test, etc, on the PE hosts. WARNING Do not edit your code directly on GitHub. 3. Submit a Copy When you are ready to submit, run ~cs2030s/submit-labX (where X is the lab number). This will submit a copy to GitHub. You can submit multiple times, but only the last copy will be graded. WARNING Do not use git push or other git commands to submit your code to GitHub. 4. Receiving Feedback The tutors will grade and comment on your submission on Github after the deadline. You can reply to their comment, etc, on GitHub as well. Communicate with your grader via Piazza (or directly if they preferred) if you think the grading is unfair.r WARNING Do not change your code on GitHub after the deadline (by either re-running submit-labX or using git commands directly). If you wish to improve upon your code after feedback from the tutors, replicate it in your own personal repo. 5. Receiving Final Grades A file named feedback.md summarizing your marks will be placed into your GitHub repo. Your marks will be posted on Luminus Gradebook. One-Time Setup The first time you use PE hosts to accept your lab, you need to do a one-time setup of your account on PE. You need to create a file called .gitconfig in your home directory with the following content: 1 2 3 4 5 [user] name = Your Name email = Your Email [github] user = Your GitHub Username Your email should be whatever you used to sign up Github. For example, a sample .gitconfig looks like this: 1 2 3 4 5 [user] name = Olaf email = olaf@arendelle.gov [github] user = OlafTheSnowman After saving this file, run: 1 git config --get github.user It should return your GitHub username. It should print your GitHub username as already set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above. Warning If it is not clear to you by now, let us repeat: You should only interact with your lab submissions on GitHub using the provided scripts get-labX and submit-labX . Failure to do so will break our workflow and will not be appreciated. If you accidentally break your repo by running git commands on it or edit it directly on GitHub, you should save a copy of your code elsewhere, then reset your lab directory, by (i) deleting requesting your tutor to delete the repo on GitHub, (ii) deleting the corrupted lab directory on PE nodes, (iii) go through Steps 1 and 2 again, then copy back your edited code into the lab directory. Grace Period You have until Lab 2 to get familiarize with the procedure above. From Lab 3 onwards, we will not entertain requests or appeals for students who failed to follow the procedure (e.g., forgot to run the submit command, submitted the wrong lab, wrong password). Authenticating to GitHub with SSH By default, GitHub uses password for authentication. So, upon running get-labX or submit-labX , you will be prompted for your GitHub password. An alternative is to use SSH to connect to GitHub. You can refer to this GitHub help page for setup instructions. If your GitHub account has 2FA enabled, SSH is the recommended method for authenticating yourself to GitHub. Lab Timeline The lab assignment is released before every Thursday at 8 am, with a deadline (usually one week five days after released) given. You must submit each lab assignment before the deadline. General Advice You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding, and (iii) test your programs thoroughly. Remember to spend some time thinking about the design and approach to solving each question. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire. Late Submission All lab assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty). Identifying Yourself In every Java file that you submit, you need to identify yourself by writing your name and lab group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group B09A) Method of Submission Please follow the instructions above to submit your homework. Programs submitted through other means, such as emails, will NOT be accepted. Use of Piazza If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site). Disallowed Syntax Some lab assignments may explicitly disallow the use of certain syntax. If the objective of the assignment is undermined due to the use of forbidden syntax, the penalty will be heavy. If in doubt, please ask for clarification on Piazza. Plagiarism You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See the module policy posted on Luminus for details. We also want to highlight that NUS is applying a heavier than usual penalty this semester -- you get an F straightaway for the module, instead of the usual 0 for the plagiarized lab. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the PE hosts so that it is accessible by others.","title":"Lab Guide"},{"location":"lab.html#cs2030s-lab-guide","text":"","title":"CS2030S Lab Guide"},{"location":"lab.html#github-classroom","text":"We will use GitHub Classroom for our lab release and submission for CS2030S. Here are what you need to do for every lab assignment:","title":"GitHub Classroom"},{"location":"lab.html#1-accept-the-lab-assignment","text":"Make sure that you have logged into GitHub. If you have multiple GitHub accounts, make sure you use the one with the same GitHub username you have submitted to us . Click on the given URL to accept the lab. A repo will be created automatically for you. WARNING Do not interact with the lab repo directory using GitHub or other git commands.","title":"1. Accept the Lab Assignment"},{"location":"lab.html#2-get-a-copy-on-pe-hosts","text":"For your first-ever lab, you will need to create a configuration file (see the \"One-Time Setup\" section below). After that, proceed as per normal below. Run the command ~cs2030s/get-labXX (where X is the lab number) to clone a copy of the lab on your home directory. You will see a new lab directory named something like labX-username created, with the skeleton files and questions inside. You can edit the code, compile, test, etc, on the PE hosts. WARNING Do not edit your code directly on GitHub.","title":"2. Get a Copy on PE Hosts"},{"location":"lab.html#3-submit-a-copy","text":"When you are ready to submit, run ~cs2030s/submit-labX (where X is the lab number). This will submit a copy to GitHub. You can submit multiple times, but only the last copy will be graded. WARNING Do not use git push or other git commands to submit your code to GitHub.","title":"3. Submit a Copy"},{"location":"lab.html#4-receiving-feedback","text":"The tutors will grade and comment on your submission on Github after the deadline. You can reply to their comment, etc, on GitHub as well. Communicate with your grader via Piazza (or directly if they preferred) if you think the grading is unfair.r WARNING Do not change your code on GitHub after the deadline (by either re-running submit-labX or using git commands directly). If you wish to improve upon your code after feedback from the tutors, replicate it in your own personal repo.","title":"4. Receiving Feedback"},{"location":"lab.html#5-receiving-final-grades","text":"A file named feedback.md summarizing your marks will be placed into your GitHub repo. Your marks will be posted on Luminus Gradebook.","title":"5. Receiving Final Grades"},{"location":"lab.html#one-time-setup","text":"The first time you use PE hosts to accept your lab, you need to do a one-time setup of your account on PE. You need to create a file called .gitconfig in your home directory with the following content: 1 2 3 4 5 [user] name = Your Name email = Your Email [github] user = Your GitHub Username Your email should be whatever you used to sign up Github. For example, a sample .gitconfig looks like this: 1 2 3 4 5 [user] name = Olaf email = olaf@arendelle.gov [github] user = OlafTheSnowman After saving this file, run: 1 git config --get github.user It should return your GitHub username. It should print your GitHub username as already set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above.","title":"One-Time Setup"},{"location":"lab.html#warning","text":"If it is not clear to you by now, let us repeat: You should only interact with your lab submissions on GitHub using the provided scripts get-labX and submit-labX . Failure to do so will break our workflow and will not be appreciated. If you accidentally break your repo by running git commands on it or edit it directly on GitHub, you should save a copy of your code elsewhere, then reset your lab directory, by (i) deleting requesting your tutor to delete the repo on GitHub, (ii) deleting the corrupted lab directory on PE nodes, (iii) go through Steps 1 and 2 again, then copy back your edited code into the lab directory.","title":"Warning"},{"location":"lab.html#grace-period","text":"You have until Lab 2 to get familiarize with the procedure above. From Lab 3 onwards, we will not entertain requests or appeals for students who failed to follow the procedure (e.g., forgot to run the submit command, submitted the wrong lab, wrong password).","title":"Grace Period"},{"location":"lab.html#authenticating-to-github-with-ssh","text":"By default, GitHub uses password for authentication. So, upon running get-labX or submit-labX , you will be prompted for your GitHub password. An alternative is to use SSH to connect to GitHub. You can refer to this GitHub help page for setup instructions. If your GitHub account has 2FA enabled, SSH is the recommended method for authenticating yourself to GitHub.","title":"Authenticating to GitHub with SSH"},{"location":"lab.html#lab-timeline","text":"The lab assignment is released before every Thursday at 8 am, with a deadline (usually one week five days after released) given. You must submit each lab assignment before the deadline.","title":"Lab Timeline"},{"location":"lab.html#general-advice","text":"You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding, and (iii) test your programs thoroughly. Remember to spend some time thinking about the design and approach to solving each question. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.","title":"General Advice"},{"location":"lab.html#late-submission","text":"All lab assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).","title":"Late Submission"},{"location":"lab.html#identifying-yourself","text":"In every Java file that you submit, you need to identify yourself by writing your name and lab group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group B09A)","title":"Identifying Yourself"},{"location":"lab.html#method-of-submission","text":"Please follow the instructions above to submit your homework. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Method of Submission"},{"location":"lab.html#use-of-piazza","text":"If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).","title":"Use of Piazza"},{"location":"lab.html#disallowed-syntax","text":"Some lab assignments may explicitly disallow the use of certain syntax. If the objective of the assignment is undermined due to the use of forbidden syntax, the penalty will be heavy. If in doubt, please ask for clarification on Piazza.","title":"Disallowed Syntax"},{"location":"lab.html#plagiarism","text":"You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See the module policy posted on Luminus for details. We also want to highlight that NUS is applying a heavier than usual penalty this semester -- you get an F straightaway for the module, instead of the usual 0 for the plagiarized lab. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the PE hosts so that it is accessible by others.","title":"Plagiarism"},{"location":"plugins.html","text":"Vim Plugins/Extensions on PE Hosts We allow the following plugins on the PE nodes during the practical exams. Note that for your labs, you are free to install any plugins you find useful. Background vim plugins are installed under ~/.vim/pack/plugins/start . We will auto-create this directory for you in the exam environment. vim colorschemes are installed under ~/.vim/colors . You put <scheme>.vim under ~/.vim/colors directly. Color Schemes We have installed the Sweeter-than-Fiction colorscheme bundle under ~cs2030s/.vim/colors . To use this, run 1 ln -s ~cs2030s/.vim/vim-colorschemes/colors ~/.vim/colors After that, your can change your vim color scheme as usual. 1 :color gruvbox The bundle includes some of the popularly requested color schemes, such as monokai , solarized , and gruvbox Approved Plugins DelimitMate DelimitMate is a plugin that automatically inserts a closing } , ) , > , etc when you type the opening symbol. To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/delimitMate ~/.vim/pack/plugins/start Vim-Rainbow vim-rainbow is a plugin that matches opening and closing brackets and colors the matching pairs with matching colors. To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/vim-rainbow ~/.vim/pack/plugins/start The following line will be added on your ~/.vimrc in the environment: 1 let g:rainbow_active = 1 NERDTree NERDTree provides a file browsing pane on the left (activated with :NERDTree ). To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/nerdtree ~/.vim/pack/plugins/start Lightline Lightline provides a more useful status line for vim . To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/lightline ~/.vim/pack/plugins/start Unavailable Plugins The following plugins are not allowed as they provide too much help for writing Java programs. coc syntastic youcompleteme","title":"Vim Plugins on PE"},{"location":"plugins.html#vim-pluginsextensions-on-pe-hosts","text":"We allow the following plugins on the PE nodes during the practical exams. Note that for your labs, you are free to install any plugins you find useful.","title":"Vim Plugins/Extensions on PE Hosts"},{"location":"plugins.html#background","text":"vim plugins are installed under ~/.vim/pack/plugins/start . We will auto-create this directory for you in the exam environment. vim colorschemes are installed under ~/.vim/colors . You put <scheme>.vim under ~/.vim/colors directly.","title":"Background"},{"location":"plugins.html#color-schemes","text":"We have installed the Sweeter-than-Fiction colorscheme bundle under ~cs2030s/.vim/colors . To use this, run 1 ln -s ~cs2030s/.vim/vim-colorschemes/colors ~/.vim/colors After that, your can change your vim color scheme as usual. 1 :color gruvbox The bundle includes some of the popularly requested color schemes, such as monokai , solarized , and gruvbox","title":"Color Schemes"},{"location":"plugins.html#approved-plugins","text":"","title":"Approved Plugins"},{"location":"plugins.html#delimitmate","text":"DelimitMate is a plugin that automatically inserts a closing } , ) , > , etc when you type the opening symbol. To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/delimitMate ~/.vim/pack/plugins/start","title":"DelimitMate"},{"location":"plugins.html#vim-rainbow","text":"vim-rainbow is a plugin that matches opening and closing brackets and colors the matching pairs with matching colors. To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/vim-rainbow ~/.vim/pack/plugins/start The following line will be added on your ~/.vimrc in the environment: 1 let g:rainbow_active = 1","title":"Vim-Rainbow"},{"location":"plugins.html#nerdtree","text":"NERDTree provides a file browsing pane on the left (activated with :NERDTree ). To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/nerdtree ~/.vim/pack/plugins/start","title":"NERDTree"},{"location":"plugins.html#lightline","text":"Lightline provides a more useful status line for vim . To install this plugin in the exam environment, run 1 ln -s ~cs2030s/.vim/pack/plugins/start/lightline ~/.vim/pack/plugins/start","title":"Lightline"},{"location":"plugins.html#unavailable-plugins","text":"The following plugins are not allowed as they provide too much help for writing Java programs. coc syntastic youcompleteme","title":"Unavailable Plugins"},{"location":"references.html","text":"References In preparing this set of notes, I refer heavily to the following. Web Resources The Java Tutorial from Oracle The Java Language Specification Java Generics FAQs by Angelika Langer Books Java Generics and Collections, by Maurice Naftalin and Philip Wadler, ISBN 978-0596527754 Effective Java, 3rd Edition, by Joshua Bloch, ISBN 978-0134685991 Functional Programming in Java, 1st Edition, by Pierre-Yves Saumont, ISBN 978-1617292736","title":"References"},{"location":"references.html#references","text":"In preparing this set of notes, I refer heavily to the following.","title":"References"},{"location":"references.html#web-resources","text":"The Java Tutorial from Oracle The Java Language Specification Java Generics FAQs by Angelika Langer","title":"Web Resources"},{"location":"references.html#books","text":"Java Generics and Collections, by Maurice Naftalin and Philip Wadler, ISBN 978-0596527754 Effective Java, 3rd Edition, by Joshua Bloch, ISBN 978-0134685991 Functional Programming in Java, 1st Edition, by Pierre-Yves Saumont, ISBN 978-1617292736","title":"Books"},{"location":"style.html","text":"CS2030/S Java Style Guide Why Coding Style is Important One of the goals of CS2030/S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S missions) and you are writing code that noone else will read except you and your tutor. CS2030/S prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style. If everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the Apple goto fail bug ). Empirical studies support this: Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609. Many major companies enforce coding styles, and some have published them. For CS2030, we base our (simplified) coding style on Google's Java Coding Style . You should bookmark the link because you need to come back to it again and again. CS2030/S Coding Style No tab Use only whitespace. For vim users, you can add the following line in your ~/.vimrc file: 1 set expandtab So that when you press it is expanded to whitespace. Most other source code editors have similar configuration. Exactly one blank line after import statements and exactly one top-level (i.e., non-nested) class. Each top-level class resides in a source file of its own. When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between. Braces are always used (even if the body is empty or contains a single statement} Use \"Egyptian brackets\": Opening brace have no line break before; but has line break after Closing brace has a line break before; and has a line break after (except when there is else or comma following a closing brace. Example: 1 2 3 if ( x == 0 ) { x ++ ; } is good. 1 2 3 4 5 6 7 8 if ( x == 0 ) { x ++ ; } if ( x == 0 ) { x ++ ; } if ( x == 0 ) { x ++ ; } are not good. Block indentation is exactly two spaces. 1 2 3 4 5 6 if ( x == 0 ) { x ++ ; for ( i = 0 ; i < x ; i ++ ) { x += i ; } } For vim users, in ~/.vimrc , add the following: 1 2 3 4 set tabstop=2 set shiftwidth=2 set autoindent set smartindent To help you with indentation. Most other source code editors have similar configuration. Each statement is followed by a line break, no matter how short the statement is. 1 x ++ ; i ++ ; is bad. 1 2 x ++ ; i ++ ; is good. Each line is limited to 80 characters in length. You can break a long line into multiple lines to enhance readability, this is called line wrapping . When you do so, each continuation line is indented at least 4 spaces from the original line. 1 System . out . println ( \"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\" ); is bad. 1 2 3 4 5 System . out . println ( \"Daenerys of the House Targaryen, the First of\" + \" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\" + \" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\" + \"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\" + \"er of Chains and Mother of Dragon\" ); is also bad. 1 2 3 4 5 6 System . out . println ( \"Daenerys of the House Targaryen,\" + \"the First of Her Name, The Unburnt, Queen of the Andals,\" + \"the Rhoynar and the First Men, Queen of Meereen,\" + \"Khaleesi of the Great Grass Sea, Protector of the Realm,\" + \"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\" + \"Mother of Dragon\" ); is ok. 80 vs 100 While we prefer lines to be limited to 80, we are OK if the length is up to 100. Any longer, however, will be frowned upon. There should be a blank line between constructors, methods, nested classes and static initializers. Blank lines can be used between fields to create logical groupings. White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators ( + , - , / , etc) as well as : in enhanced for. Space should also appears before and after // comments 1 2 3 4 5 6 if ( x == 0 ){ x ++ ; //to make sure x is at least one. for ( i = 0 ; i < x ; i ++ ){ x += i ; } } is bad. 1 2 3 4 5 6 if ( x == 0 ) { x ++ ; // to make sure x is at least one. for ( i = 0 ; i < x ; i ++ ) { x += i ; } } is good. One variable per declaration. 1 int x , y ; bad. 1 2 int x ; int y ; good! No C-style array declaration 1 String args [] ; not good. 1 String [] args ; good! Switch statement always include a default case. One annotation per line. Always use @Override . 1 2 3 4 @Override public boolean equals ( Object o ) { : } Indent comments at the same level as the surrounding code. For multiple comments, align * with the previous line. 1 2 3 4 5 6 /* * Not a good style */ /* * Good style */ Class modifier appears in the following order: 1 public protected private abstract default static final transient volatile synchronized native strictfp Example: 1 static public void main ( String [] args ) is bad. 1 public static void main ( String [] args ) is good! Class names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE. Type parameters in single capital letter. Caught exceptions should not be ignored. Static fields and methods must be accessed with class name. Using checkstyle To automatically check for style violation, we use a tool call checkstyle . To run, 1 java -jar ~cs2030s/bin/checkstyle.jar -c ~cs2030s/bin/cs2030_checks.xml *.java Hint: put the command into a bash script so that you do not need to type such a long string all the time.","title":"Java Style Guide"},{"location":"style.html#cs2030s-java-style-guide","text":"","title":"CS2030/S Java Style Guide"},{"location":"style.html#why-coding-style-is-important","text":"One of the goals of CS2030/S is to move you away from the mindset that you are writing code that you will discard after it is done (e.g., in CS1101S missions) and you are writing code that noone else will read except you and your tutor. CS2030/S prepares you to work in a software engineering teams in many ways, and one of the ways is to enforce a consistent coding style. If everyone on the team follows the same style, the intend of the programmer can become clear (e.g., is this a class or a field?), the code is more readable and less bug prone (e.g., the Apple goto fail bug ). Empirical studies support this: Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609. Many major companies enforce coding styles, and some have published them. For CS2030, we base our (simplified) coding style on Google's Java Coding Style . You should bookmark the link because you need to come back to it again and again.","title":"Why Coding Style is Important"},{"location":"style.html#cs2030s-coding-style","text":"No tab Use only whitespace. For vim users, you can add the following line in your ~/.vimrc file: 1 set expandtab So that when you press it is expanded to whitespace. Most other source code editors have similar configuration. Exactly one blank line after import statements and exactly one top-level (i.e., non-nested) class. Each top-level class resides in a source file of its own. When a class has overladed methods (e.g., multiple constructors or methods of the same name), they appear sequentially with no other code in between. Braces are always used (even if the body is empty or contains a single statement} Use \"Egyptian brackets\": Opening brace have no line break before; but has line break after Closing brace has a line break before; and has a line break after (except when there is else or comma following a closing brace. Example: 1 2 3 if ( x == 0 ) { x ++ ; } is good. 1 2 3 4 5 6 7 8 if ( x == 0 ) { x ++ ; } if ( x == 0 ) { x ++ ; } if ( x == 0 ) { x ++ ; } are not good. Block indentation is exactly two spaces. 1 2 3 4 5 6 if ( x == 0 ) { x ++ ; for ( i = 0 ; i < x ; i ++ ) { x += i ; } } For vim users, in ~/.vimrc , add the following: 1 2 3 4 set tabstop=2 set shiftwidth=2 set autoindent set smartindent To help you with indentation. Most other source code editors have similar configuration. Each statement is followed by a line break, no matter how short the statement is. 1 x ++ ; i ++ ; is bad. 1 2 x ++ ; i ++ ; is good. Each line is limited to 80 characters in length. You can break a long line into multiple lines to enhance readability, this is called line wrapping . When you do so, each continuation line is indented at least 4 spaces from the original line. 1 System . out . println ( \"Daenerys of the House Targaryen, the First of Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, Protector of the Realm, Lady Regnant of the Seven Kingdoms, Breaker of Chains and Mother of Dragon\" ); is bad. 1 2 3 4 5 System . out . println ( \"Daenerys of the House Targaryen, the First of\" + \" Her Name, The Unburnt, Queen of the Andals, the Rhoynar and the\" + \" First Men, Queen of Meereen, Khaleesi of the Great Grass Sea, P\" + \"rotector of the Realm, Lady Regnant of the Seven Kingdoms, Break\" + \"er of Chains and Mother of Dragon\" ); is also bad. 1 2 3 4 5 6 System . out . println ( \"Daenerys of the House Targaryen,\" + \"the First of Her Name, The Unburnt, Queen of the Andals,\" + \"the Rhoynar and the First Men, Queen of Meereen,\" + \"Khaleesi of the Great Grass Sea, Protector of the Realm,\" + \"Lady Regnant of the Seven Kingdoms, Breaker of Chains and\" + \"Mother of Dragon\" ); is ok. 80 vs 100 While we prefer lines to be limited to 80, we are OK if the length is up to 100. Any longer, however, will be frowned upon. There should be a blank line between constructors, methods, nested classes and static initializers. Blank lines can be used between fields to create logical groupings. White space should separate Java keywords from parenthesis and braces, and be added on both sides of binary operators ( + , - , / , etc) as well as : in enhanced for. Space should also appears before and after // comments 1 2 3 4 5 6 if ( x == 0 ){ x ++ ; //to make sure x is at least one. for ( i = 0 ; i < x ; i ++ ){ x += i ; } } is bad. 1 2 3 4 5 6 if ( x == 0 ) { x ++ ; // to make sure x is at least one. for ( i = 0 ; i < x ; i ++ ) { x += i ; } } is good. One variable per declaration. 1 int x , y ; bad. 1 2 int x ; int y ; good! No C-style array declaration 1 String args [] ; not good. 1 String [] args ; good! Switch statement always include a default case. One annotation per line. Always use @Override . 1 2 3 4 @Override public boolean equals ( Object o ) { : } Indent comments at the same level as the surrounding code. For multiple comments, align * with the previous line. 1 2 3 4 5 6 /* * Not a good style */ /* * Good style */ Class modifier appears in the following order: 1 public protected private abstract default static final transient volatile synchronized native strictfp Example: 1 static public void main ( String [] args ) is bad. 1 public static void main ( String [] args ) is good! Class names are writte in UpperCamelCase, method names and field names in lowerCamelCase, constant names in ALL_CAPS_SNAKE_CASE. Type parameters in single capital letter. Caught exceptions should not be ignored. Static fields and methods must be accessed with class name.","title":"CS2030/S Coding Style"},{"location":"style.html#using-checkstyle","text":"To automatically check for style violation, we use a tool call checkstyle . To run, 1 java -jar ~cs2030s/bin/checkstyle.jar -c ~cs2030s/bin/cs2030_checks.xml *.java Hint: put the command into a bash script so that you do not need to type such a long string all the time.","title":"Using checkstyle"},{"location":"unix-advanced.html","text":"Unix CLI: Advanced This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the philosophy of Unix where small utitilies program can be composed together to perform a complex task using the pipe | operator be aware of basic Unix utilities: echo , sort , uniq , grep , head , and tail . be able to use basic pattern matching * ? [] and {} in bash know how to use Tab , Ctrl + P , and Ctrl + N to work more efficiently in bash know how to save time and effort by automating long complex commands using bash scripts Composing Programs with | Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, 1 2 $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as 1 $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: 1 2 $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: 1 2 $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting. Useful Utilities Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix. head and tail head and tail prints out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given). By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\) . 1 2 3 4 5 6 $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands. echo echo simply prints out the command-line argument to the standard output. 1 2 $ echo \"hello world!\" hello world! sort sort rearrange the input lines in alphabetical order. 1 2 3 4 5 6 7 8 9 $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order. uniq uniq remove any two consecutive lines that are the same. 1 2 3 4 5 6 7 8 9 10 $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.` grep grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run 1 $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done. Pipe Example To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) 1 2 3 4 5 6 7 8 9 A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: 1 2 $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: 1 2 $ cat ID | sort | uniq | grep CEG | wc -l 3 Pattern Matching in bash We now show you another productivity shortcut. In an example earlier, you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of 1 $ cat test.txt foo.txt bar.txt | wc We could just run 1 $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , . Example 1: 1 2 $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt . Example 2: 1 2 $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t . Example 3: 1 2 3 4 $ ls *.txt bar.txt foo.txt test.txt $ ls {fo,ba}??txt bar.txt foo.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt . Leveling Up Your Productivity with CLI Minimizing Hand Movements You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type. Minimizing Typing We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use Ctrl + P or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look at (this cheat sheet]( https://github.com/fliptheweb/bash-shortcuts-cheat-sheet ). You have also seen that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: 1 $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: 1 2 $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: 1 2 $ bash hello.sh hello! or 1 2 $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? 1 2 $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions section that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: 1 2 3 $ chmod u+x hello.sh $ ./hello.sh hello! The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Advanced"},{"location":"unix-advanced.html#unix-cli-advanced","text":"This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the philosophy of Unix where small utitilies program can be composed together to perform a complex task using the pipe | operator be aware of basic Unix utilities: echo , sort , uniq , grep , head , and tail . be able to use basic pattern matching * ? [] and {} in bash know how to use Tab , Ctrl + P , and Ctrl + N to work more efficiently in bash know how to save time and effort by automating long complex commands using bash scripts","title":"Unix CLI: Advanced"},{"location":"unix-advanced.html#composing-programs-with","text":"Another key innovation of Unix is that led to its success is the invention of the | operator. Before Unix, operating systems tend to provide complex, monolithic, programs. The philosophy of Unix, however, is to provide many small, simple, utility programs, that can be composed to complete a more complex task. These small programs each do one thing only (and do it well) and so are easier to write and less prone to bugs. The composition of these utility programs relies on two things. First, plain text is often used as input and output of the programs. These allow the programs to understand each other easily. Second, they use | to communicate with each other. The | operator takes the standard output from one program and redirects it as the standard input of another program. For instance, 1 2 $ cat test.txt | wc 1 11 64 compose cat and wc together. Recall that cat reads the content of the file and prints it to standard output. Here, we pipe the standard output from cat to wc . So now, these printed texts are redirected as the standard input to wc . But this is just the same as 1 $ wc < test.txt that we have seen before. What's the power in | ? Now, recall that we have made copies of test.txt earlier, into foo.txt and bar.txt . If you have not done so or have removed them, you can quickly reproduce the files with: 1 2 $ cp test.txt foo.txt $ cp test.txt bar.txt Let's suppose now I want to count the total number of words for all three files. Instead of calling wc on each file one by one, and sum them up myself. I can just run: 1 2 $ cat test.txt foo.txt bar.txt | wc 3 33 192 Here, cat read the three files, concatenate their content, and pass the output to wc for counting.","title":"Composing Programs with |"},{"location":"unix-advanced.html#useful-utilities","text":"Before we see more interesting examples of using | , let's move beyond cat and wc , and see what other simple tools are there in Unix.","title":"Useful Utilities"},{"location":"unix-advanced.html#head-and-tail","text":"head and tail prints out the first \\(k\\) lines and last \\(k\\) lines from a file (or standard input if the file name is not given). By default, \\(k\\) is 10, but you can pass in an argument to specify \\(k\\) . 1 2 3 4 5 6 $ cat test.txt foo.txt bar.txt This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. This is a test file for learning Unix file management commands. $ cat test.txt foo.txt bar.txt | tail -1 This is a test file for learning Unix file management commands.","title":"head and tail"},{"location":"unix-advanced.html#echo","text":"echo simply prints out the command-line argument to the standard output. 1 2 $ echo \"hello world!\" hello world!","title":"echo"},{"location":"unix-advanced.html#sort","text":"sort rearrange the input lines in alphabetical order. 1 2 3 4 5 6 7 8 9 $ sort john jane peter mary^D jane john mary peter In the example above, I entered john , jane , peter , mary followed by Ctrl + D to signify the end of input. sort prints out jane , john , mary , peter , in that order.","title":"sort"},{"location":"unix-advanced.html#uniq","text":"uniq remove any two consecutive lines that are the same. 1 2 3 4 5 6 7 8 9 10 $ uniq 1 2 2 2 1 1^D 1 2 1 For instance, in the above, there are three consecutive lines of 2 , so only one remained. There are also two consecutive lines of 1 , so only one remained.`","title":"uniq"},{"location":"unix-advanced.html#grep","text":"grep returns the lines of text from the given file (or the standard input) that matches the given string. For instance, run 1 $ grep abc and start typing in some lines of text, some containing abc , some do not. grep will spew out into the standard output all the lines that contain the text abc somewhere. As usual, hit Ctrl + D when you are done.","title":"grep"},{"location":"unix-advanced.html#pipe-example","text":"To give you an example of how useful | is, here is a real example. When processing the registration of the workshop, I have quite a few registrations that are duplicates -- students registered more than ones. I need a quick way to count how many unique registrants are there. So I keep the student id of all registrants in a file called ID . For instance, the file ID contains (not real data, of course) 1 2 3 4 5 6 7 8 9 A1234567X,CS A1234559A,CEG A1239999J,CEG A1234580K,CEG A1233210O,CS A1234567X,CS A1234581Q,ISC A1233216T,ISC A1239999J,CEG Now, to count how many unique registrants, I just need to run: 1 2 $ cat ID | sort | uniq | wc -l 7 To count how many uniq registrants are CEG students, I just change it to: 1 2 $ cat ID | sort | uniq | grep CEG | wc -l 3","title":"Pipe Example"},{"location":"unix-advanced.html#pattern-matching-in-bash","text":"We now show you another productivity shortcut. In an example earlier, you have seen how we passed in more than one file names into cat . Recall that we can use Tab to auto-complete the file names, so we can hit fewer keys on the keyboards. Now, we show you there is an even faster way. Instead of 1 $ cat test.txt foo.txt bar.txt | wc We could just run 1 $ cat *.txt | wc The * is a special character in bash that represents 0 or more characters. So, this command essentially says, cat any files that contain 0 or more characters, followed by .txt . The table below summarizes the useful patterns: Pattern Matches * 0 or more characters ? one character [..] one character, coming from the given set between [ and ] , - to indicate a range. {.., ..} Either one of the names, separated by , .","title":"Pattern Matching in bash"},{"location":"unix-advanced.html#example-1","text":"1 2 $ ls ???.txt bar.txt foo.txt Since we use three ? , it matches any file name with three characters followed by .txt .","title":"Example 1:"},{"location":"unix-advanced.html#example-2","text":"1 2 $ ls [f-t]*t foo.txt test.txt The expression [f-t]*t matches all file names the start with alphabet f , g , etc, until t , followed by zero or more characters, followed by t .","title":"Example 2:"},{"location":"unix-advanced.html#example-3","text":"1 2 3 4 $ ls *.txt bar.txt foo.txt test.txt $ ls {fo,ba}??txt bar.txt foo.txt The expression {fo,ba}??txt matches any file names the start with either fo or ba , followed by two characters, followed by txt .","title":"Example 3:"},{"location":"unix-advanced.html#leveling-up-your-productivity-with-cli","text":"","title":"Leveling Up Your Productivity with CLI"},{"location":"unix-advanced.html#minimizing-hand-movements","text":"You have seen how you can manage files and navigate around the directory structure, all by interacting with the command-line interface. No windows. No mouse. Just you, the keyboard, and the terminal. You do not even need to use any arrow keys or function keys. Why is this a big deal? Let's look at the image of the keyboard below: We only need to use the keys colored in pink. And since these keys concentrated in a small region on the keyboard, for most of us, we can reach the keys if we just position our hands over the keyboard 1 , we only need move our fingers to type.","title":"Minimizing Hand Movements"},{"location":"unix-advanced.html#minimizing-typing","text":"We can even minimize the movement of our fingers in several ways by typing less. We have seen several ways where we have achieved these: Unix commands are named economically -- they are often only a few characters long. We can use Tab to auto-complete a command or a file name. We can use Ctrl + P or Ctrl + N to repeat a previous commands. There are many more bash shortcuts for productivity, if you are keen, take a look at (this cheat sheet]( https://github.com/fliptheweb/bash-shortcuts-cheat-sheet ). You have also seen that Unix has many small, simple, utilities that we can compose to solve a task. But composing them requires much typing: 1 $ cat ID | sort | uniq | grep CEG | wc -l If we need to run this over and over again or share this command with someone, we can simply put these commands in a file, and then run it by invoking its name. Such a file containing commands for the shell is called a shell script . For example, let's create a file named hello.sh containing the line echo hello! by: 1 2 $ cat > hello.sh echo hello!^D The extension .sh is not necessary but it is just something I use so that I can tell that this file contains a shell script. In the example above, cat will wait for me to enter something on the keyboard. So I entered echo hello! followed by Ctrl + D to indicate the end of the input. Now, to execute this file, we run: 1 2 $ bash hello.sh hello! or 1 2 $ bash < hello.sh hello! Recall that we said Unix shells do not necessarily interact with the users? This is an example. We pass the file hello.sh to a new instance of bash , asking it to interpret the lines inside this file as commands to execute. Remember that we want to minimize typing, so can we run it with less typing? What if we can just pass the filename directly to bash to execute? 1 2 $ ./hello.sh bash: ./hello.sh: Permission denied Here, we specify the relative path of the script hello.sh , including the prefix ./ (for reasons that we will explain later). But we should get an error telling us Permission defined . Recall from the File Permissions section that a file needs to have the executable x permission to be executed. So we need to add this permission for ourselves: 1 2 3 $ chmod u+x hello.sh $ ./hello.sh hello! The recommended placement of hands over the keyboard is so that the thumbs are over the Space bar, the left fingers are over A S D F , and the right fingers are over J K L ; . \u21a9","title":"Minimizing Typing"},{"location":"unix-background.html","text":"Unix CLI: Background This article is a replication of the notes from the Unix@Home Workshop held in August 2020. After reading this article, students should understand the basic terms: CLI, terminal, shell, command prompt appreciate why CLI is more efficient aware of the commonly used terminal control sequences What is Command-Line Interfaces? The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer. Why CLI over GUI? Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks. What is a Terminal? With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence. What is a Shell? The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. Other popular shells are fish and Oh-my-zsh ( zsh ). Command Prompt A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: 1 ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell. Terminal Control Sequence On the old teletype machines, a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal. References The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"Background"},{"location":"unix-background.html#unix-cli-background","text":"This article is a replication of the notes from the Unix@Home Workshop held in August 2020. After reading this article, students should understand the basic terms: CLI, terminal, shell, command prompt appreciate why CLI is more efficient aware of the commonly used terminal control sequences","title":"Unix CLI: Background"},{"location":"unix-background.html#what-is-command-line-interfaces","text":"The command-line interfaces, or just CLI for short, is an important interface that we, as computing professionals, interact with the computer for most of our day-to-day tasks. In contrast to graphical user interfaces where users use a mouse to click/drag on menus and windows to interact with a computer, the command-line interface uses keyboard and text. The users would type a command to instruct the computer to do something, and the computer would respond by displaying the reply to the user. CLI evolves from teletypes machines where users would interact with the computer through a typewriter-like machine (see Figure 2.2. of this article for an example). Users would type a command on the keyboard, and the typewriter would print out, line-by-line, the output on a piece of paper. This is the era before monitors and mice. Again, driven by the constraints and the necessity, CLI interfaces are designed to be simple and economical. The commands are short and fast to type; the responses are succinct. Figure: A teletype device (Model 33 ASR) to interact with a computer.","title":"What is Command-Line Interfaces?"},{"location":"unix-background.html#why-cli-over-gui","text":"Since CLI is designed to be economical, CLI is much more efficient and productive to use, in particular when we are interacting with a remote computer over the network -- sending text back and forth is much more efficient than sending graphical elements over the network. Each character takes up to two bytes, but each pixel alone takes up 3 bytes of data. Another reason why using CLI is faster and more productive is that user can keep their hands on the keyboard at all time and not needing to switch frequently between keyboard and mouse. While research has shown that GUI and mouse are great for casual users, for software developers that need to type on the keyboard most of the time, having to switch between keyboard and mouse is a productivity-killer. Further, CLI commands typically provides a host of options that is accessible directly (including of clicking through preference dialogues) from the command line, making these commands flexible and customizable. Finally, since these commands are just text, we can put together a sequence of commands easily as a script , to automate highly repetitive tasks.","title":"Why CLI over GUI?"},{"location":"unix-background.html#what-is-a-terminal","text":"With the advances in Cathode-ray tube (CRT), the teletype machine is replaced with computer terminals in the late 1970s. Instead of printing the output on paper, the output from CLI is now printed on a monitor supporting 24x80 characters on screen in black and white (or green). Figure: The VT100 Computer Terminal. In modern days, operating systems still use similar underlying functionalities to read in keyboard inputs and print out text to show to the users, but instead of these clunky special purpose devices, the functionality of a terminal is replaced by programs called terminal emulator or virtual terminal . Examples include Terminal and iTerm2 on macOS; Windows Terminal on Microsoft; xterm and konsole on Ubuntu, etc. Many legacy control commands on these teletype machines remain in today's computing environment, such as the terminal control sequence.","title":"What is a Terminal?"},{"location":"unix-background.html#what-is-a-shell","text":"The term CLI refers to a type of user interface. To realize this interface, Unix computing environments rely on another type of program called shell . A shell usually works closely with a terminal to get inputs from the users, interpret the meaning of the inputs, execute the tasks (perhaps through the invocation of other programs), and returned the output back to the user through the terminal. Note that a shell can run on its own without a terminal (it can read input from a file, and write the output to a file, for instance). There are many shells available, each with different bells and whistles to help improve our productivity. The most popular shell that comes as default on many Unix systems is bash , or Bourne Again Shell. This is the shell that we will use in this workshop and as default in the SoC Unix computing environment. Other popular shells are fish and Oh-my-zsh ( zsh ).","title":"What is a Shell?"},{"location":"unix-background.html#command-prompt","text":"A shell has a command prompt . It typically looks something like this, but will be different depending on the default configuration on your machine: 1 ooiwt@pe111:~$ The prompt is where you type in a command for the shell to interpret and execute. In bash , the command prompt can be customized to include information such as the username, hostname, time, current working directory, etc. It is customary to use the $ sign as the final character of the prompt. In our examples, we will just show $ to incidate the command prompt. Depending on the habit, sometimes you are asked to type in a command \"into the terminal\", \"into the shell\", or \"into bash\". They all mean the same thing: type in the command at the command prompt of the shell.","title":"Command Prompt"},{"location":"unix-background.html#terminal-control-sequence","text":"On the old teletype machines, a user can send special commands to the teletype machines to control its operation. Many of these special commands still exists today, and can be triggered by with hitting a combination of Ctrl and another key (i.e., a control sequence). The following lists some of the most useful control sequences to know: Ctrl + D : signal the end of input to a program. This is also used to exit from a shell (by telling the shell that you have no more input to send and you are done with it). Ctrl + Z : suspend the current running program. This pauses the execution of the program (but not terminating it). In the bash shell, the most recently suspended program can resume executing in the background with the command bg or brought back to execution in the foreground again with the command fg . Ctrl + C : terminate the current running program. Ctrl + S : freeze the terminal. This is a legacy control command that pauses the output printing of a teletype machine. You shouldn't need to use this control sequence. Ctrl + Q : resume the terminal. This is a legacy control command that resume the printing of a teletype machine. You shouldn't need to use this control sequence, unless you accidentally hit Ctrl + S Ctrl + Z vs. Ctrl + C A common mistake for new students is to hit Ctrl + Z frequently if something goes wrong with their program -- this behavior leads to large number of suspended programs (which still occupy resources such as memory on the computer). The right sequence to use is Ctrl + C -- which terminates the program (and frees up the resources). Ctrl + S accidents Since Ctrl + S is used as the \"save\" shortcut in non-Unix environment, many students accidentally hit this control sequence, causing their terminal to freeze. Don't panic if this happens. Just hit Ctrl + Q and things will be back to normal.","title":"Terminal Control Sequence"},{"location":"unix-background.html#references","text":"The Art of Unix Usability: Command Line Interfaces , by Eric Steven Raymond","title":"References"},{"location":"unix-essentials.html","text":"Unix CLI: The Essentials This article is adapted from the notes of the Unix@Home Workshop held in August 2020. It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general). After following this article, students should be able to: navigate comfortably in a Unix file system using shell commands cd , pwd , and ls use . , .. , ~ or / to form a relative or absolute path name to a file organize files in a Unix file system using shell commands mkdir , rmdir , mv , rm , and cp view the content of the file using cat , more or less manage the permission of a file using chmod perform standard input/output redirection with < and > Unix Directory Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know. Root Directory The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify. Home Directory Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob . Current Working Directory A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash . Parent Directory The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory Specifying a Path To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path . Absolute path The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~ Relative path The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / . Directory-related Commands Now, let's take a look at some basic commands available in bash that deals with navigation and directories. pwd : Print Current Working directory pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering 1 pwd will give the output 1 /home/o/ooiwt ls : LiSt content of a directory The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. 1 2 3 4 5 6 $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command. cd : Change Directory To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. 1 2 3 4 5 $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in \" Unix CLI: Background \", it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory. rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command 1 $ rmdir workshop will remove the directory that you just created. File Management This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. 1 2 3 $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : 1 wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: 1 2 3 4 5 6 7 8 9 10 --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. 1 2 $ ls test.txt cp : CoPy files Now let's try to copy this file to another name. 1 2 3 $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . 1 2 3 4 $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. 1 $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning. mv : MoVe or rename files Now, let's change directory back to workshop . 1 $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . 1 2 3 4 5 $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. 1 2 3 4 5 $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. You can look up on the Internet on how to make -i the default using alias command in .bashrc . Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: 1 $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 4 5 $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . 1 2 $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively. cat : CATenate file content to screen To quickly take a look at the content of the file, use the cat command. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. 1 $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . File Permission Management File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right. The What of File Permissions Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3. The Who of File Permissions Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read Checking file permission You can view the permission of a file by using the ls -l command ( l for long format): 1 2 $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644. The chmod command You can use chmod command to change the permissions of a file or a directory. For instance, 1 2 3 $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: 1 2 3 $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Common Scenarios for chmod Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x . Standard Input/Output History Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal . Examples using cat and wc Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: 1 $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. 1 2 $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: 1 $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered. Output Redirection By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: 1 2 3 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. 1 2 3 4 5 6 7 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt Input Redirection The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. 1 2 3 4 5 6 7 8 $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator. Other Useful Online Tools explainshell explain each shell command for you Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9 \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"Essentials"},{"location":"unix-essentials.html#unix-cli-the-essentials","text":"This article is adapted from the notes of the Unix@Home Workshop held in August 2020. It contains the essential knowledge that a CS2030S students need to survive using the PE nodes to do the labs (and to use a Unix CLI in general). After following this article, students should be able to: navigate comfortably in a Unix file system using shell commands cd , pwd , and ls use . , .. , ~ or / to form a relative or absolute path name to a file organize files in a Unix file system using shell commands mkdir , rmdir , mv , rm , and cp view the content of the file using cat , more or less manage the permission of a file using chmod perform standard input/output redirection with < and >","title":"Unix CLI: The Essentials"},{"location":"unix-essentials.html#unix-directory","text":"Unix organizes files according to a directory structure. The following shows an example. This structure is also known as a directory tree . There are two important directories that you need to know.","title":"Unix Directory"},{"location":"unix-essentials.html#root-directory","text":"The root directory is the directory at the top of the directory tree 1 . It is simply referred to as / , without any name. Under the root directory are many other systems directory, which a casual user does not normally need to (and have no permission to) modify.","title":"Root Directory"},{"location":"unix-essentials.html#home-directory","text":"Each user has his/her own home directory. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. The home directory is referred to with the symbol ~ in bash . Sometimes we add the username behind ~ to indicate the home directory of the other user. E.g., ~bob means the home directory of a user named bob .","title":"Home Directory"},{"location":"unix-essentials.html#current-working-directory","text":"A user can navigate around the directory tree. The current working directory is the directory that the user is currently in. In contrast to the root and home directory, which are fixed 2 , the current working directory changes as the user moves around. Knowing the current working directory is important since this is the default location in the directory tree a command executes. As such, many systems by default display the current working directory as part of the bash command prompt. The current working directory is referred to with the symbol . in bash .","title":"Current Working Directory"},{"location":"unix-essentials.html#parent-directory","text":"The parent directory is directory one layer up from the current directory. The parent directory is referred to with the symbol .. in bash . To summarize, here are the short form representations: Symbol Meaning / the root directory ~ the home directory . the current working directory .. the parent directory","title":"Parent Directory"},{"location":"unix-essentials.html#specifying-a-path","text":"To specify a directory or a file in the Unix directory tree, we can use either the absolute path or the relative path .","title":"Specifying a Path"},{"location":"unix-essentials.html#absolute-path","text":"The absolute path is constructed as follows, starting from the root of the directory structure, find a path (a sequence of directories) to the location that you want to specify, then concatenate the names of the directories together, separated by the forward-slash / . This is a similar notation used for Web site URLs so you should already be familiar with it. For instance, the path /home/o/ooiwt is the absolute path of the directory named ooiwt in the figure above. An absolute path is independent of the current working directory and always start with / or ~","title":"Absolute path"},{"location":"unix-essentials.html#relative-path","text":"The relative path is dependent on the current working directory. To refer to another location, start from the current directory, and find a path (a sequence of directories) to the location that you refer to. When we go up a tree, we use .. to represent the directory. For example, referring to the figure above, if we are in the directory /home/b , and we wish to refer to /home/o/ooiwt , we can use the relative path ../o/ooiwt . If we wish to refer to /home/b/bob , we can use the relative path bob . A relative path never starts with / .","title":"Relative path"},{"location":"unix-essentials.html#directory-related-commands","text":"Now, let's take a look at some basic commands available in bash that deals with navigation and directories.","title":"Directory-related Commands"},{"location":"unix-essentials.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in. Type pwd into the command prompt, and it will print the absolute path to your current working directory. For instance, Suppose you are in /home/o/ooiwt , entering 1 pwd will give the output 1 /home/o/ooiwt","title":"pwd: Print Current Working directory"},{"location":"unix-essentials.html#ls-list-content-of-a-directory","text":"The ls list the content in the current working directory. Rule of Silence Unix follows the economical rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt content of a directory"},{"location":"unix-essentials.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. In the example below, we assume that we start with an empty directory. 1 2 3 4 5 6 $ ls $ mkdir workshop $ ls workshop $ ls -F workshop/ Here, we create a directory called workshop . Now, when we ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory. A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Up Arrow for Command History bash maintains a history of your previously executed commands, and you may use the Ctrl + P (previous) and Ctrl + N (next) to go through it. Press the Ctrl + P until you find a previously executed command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long bash command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix-essentials.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from one to another, we use the cd command. 1 2 3 4 5 $ pwd /home/o/ooiwt $ cd workshop $ pwd /home/o/ooiwt/workshop Suppose our starting working directory is /home/o/ooiwt , after we cd into workshop , the current working directory becomes /home/o/ooiwt/workshop . Note that cd can take in either an absolute path or a relative path. The example above takes in a relative path as the argument. As mentioned in \" Unix CLI: Background \", it is common to include the current working directory into the shell's prompt. So, you may see your command prompt updated to include the new working directory. Entering cd alone (without argument) brings you back to your home directory.","title":"cd: Change Directory"},{"location":"unix-essentials.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in the current directory -- note that a directory must be empty before it can be removed. The command 1 $ rmdir workshop will remove the directory that you just created.","title":"rmdir: ReMove a subDIRectory"},{"location":"unix-essentials.html#file-management","text":"This note assumes that you are familiar with navigation with the Unix directory structure. We will now learn some commands to help us deal with files. Let's recreate the workshop directory in case you have already deleted it with the rmdir at the end of the last unit. 1 2 3 $ mkdir -p workshop $ cd workshop $ ls All of the above commands should complete successfully and silently . Let's populate the directory with a new file. Cut-and-paste the command below into the command prompt : 1 wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt You should see a file being downloaded and saved with an output similar to below: 1 2 3 4 5 6 7 8 9 10 --2020-07-27 15:26:49-- https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/test.txt Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 151.101.0.133, 151.101.64.133, 151.101.128.133, ... Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.0.133|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 64 [text/plain] Saving to: \u2018test.txt\u2019 test.txt 100%[======================>] 64 --.-KB/s in 0s 2020-07-27 15:26:50 (2.35 MB/s) - \u2018test.txt\u2019 saved [64/64] Now run ls , and you should see that ls returns test.txt as the content of the current working directory. 1 2 $ ls test.txt","title":"File Management"},{"location":"unix-essentials.html#cp-copy-files","text":"Now let's try to copy this file to another name. 1 2 3 $ cp test.txt foo.txt $ ls test.txt foo.txt The command above copies the file test.txt into foo.txt . If you want to copy the whole directory, use -r flag, where r stands for copying recursively. Now let's create another directory called copy . 1 2 3 4 $ cd .. $ mkdir copy $ cd copy $ ls Run pwd to double-check that you are in the directory called copy that is at the same level as workshop . Now, we are going to use cp with the -r flag, to copy recursively the whole of workshop directory over. 1 $ cp -r ../workshop . The command cp takes in two arguments, the first is the source, and the second is the destination. Note that we use . above to indicate that we wish to copy the whole sub-tree of workshop over the current directory. The command should complete without any message. Upon completion, you can run ls to double-check that the workshop directory exists under workshop . !!! Warning: cp Overwrites If there is an existing file with the same name, cp will overwrite the existing file without warning.","title":"cp: CoPy files"},{"location":"unix-essentials.html#mv-move-or-rename-files","text":"Now, let's change directory back to workshop . 1 $ cd ../workshop and use the mv command to rename foo.txt into bar.txt . 1 2 3 4 5 $ ls foo.txt test.txt $ mv foo.txt bar.txt $ ls bar.txt test.txt As you can see above, just like cp , mv takes in two arguments, the first is the source and the second is the destination. If the destination of mv is a directory, however, instead of renaming, the mv commands move the source to the destination directory. 1 2 3 4 5 $ ls bar.txt test.txt $ mv ../copy/workshop/foo.txt . $ ls bar.txt foo.txt test.txt Here, you can see that we have moved foo.txt over to the current directory. !!! Warning: mv Overwrites If there is an existing file with the same name, mv will overwrite the existing file without warning. mv comes with a -i flag that interactively asks you if you are sure if you want to overwrite a file. It is a good idea to always run mv -i . Hit Y to continue overwriting the existing file. You can look up on the Internet on how to make -i the default using alias command in .bashrc . Use Tab for Name Completion If you have a very long file name, you may use the bash auto-completion feature to reduce typing. For instance, you may type: 1 $ mv t and press the Tab key, bash will complete the filename for you if there is only one filename with the prefix \"t\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"unix-essentials.html#rm-remove-files","text":"We can use rm to remove files. Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 4 5 $ ls bar.txt foo.txt test.txt $ rm foo.txt $ ls bar.txt test.txt rm -rf While the Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many lives. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . 1 2 $ rm -i bar.txt rm: remove regular file 'bar.txt'? Type y or n to answer yes or no respectively.","title":"rm: ReMove files"},{"location":"unix-essentials.html#cat-catenate-file-content-to-screen","text":"To quickly take a look at the content of the file, use the cat command. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. less is a variant of cat that includes features to read each page leisurely and is useful for long files. 1 $ less test.txt In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to screen"},{"location":"unix-essentials.html#man-online-manual","text":"An online help facility is available in Unix via the man command ( man stands for MANual). To look for more information about any Unix command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q .","title":"man: Online MANual"},{"location":"unix-essentials.html#file-permission-management","text":"File permissions determine who can do what to a file. Typically, you do not need to fiddle with the file permission, but when you need to, it is usually for an important reason and it is critical to do it right.","title":"File Permission Management"},{"location":"unix-essentials.html#the-what-of-file-permissions","text":"Let's look at what you can do to a file first. Unix file permissions allow control of three actions: r (read), w (write) and x (execute). These permission settings allow the following different actions to be done for regular files and directories. permission effect on file effect on directory r reading the content of a file read the names of the files in the directory w writing into a file create/delete/rename files in the directory x executing a file access contents and meta-info (size, creation time) of files in the directory These three actions can be controlled independently. The permissions on a file can be expressed in two ways: using symbolic notation. For instance, rwx , r-x , -wx , where a - means that the corresponding permission is not given (in the order of r , w , x ). using a numerical notation. This notation uses a digit between 0 and 7, which is computed as a sum of the individual digit representing the permissions: r is represented with 4, w is represented with 2, and x is represented with 1. For instance, r-x has a numerical representation of 5, and -wx has a numerical representation of 3.","title":"The What of File Permissions"},{"location":"unix-essentials.html#the-who-of-file-permissions","text":"Unix divides the users into three classes: u is the u ser who owns the file; g refers to the users in the same g roup as the user; and o are all the o ther users. The permissions can be controlled separately for these classes of users. The permission notation simply concatenates the file permissions of each class of users together, in the order of u , g , and o . For instance, the permission of 644, or rw-r--r-- , on a file means that: the owner can read and write the group users can only read all the other users can only read","title":"The Who of File Permissions"},{"location":"unix-essentials.html#checking-file-permission","text":"You can view the permission of a file by using the ls -l command ( l for long format): 1 2 $ ls -l test.txt -rw-r--r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt Ignoring the first - and the last @ , you can see that the permission of test.txt is 644.","title":"Checking file permission"},{"location":"unix-essentials.html#the-chmod-command","text":"You can use chmod command to change the permissions of a file or a directory. For instance, 1 2 3 $ chmod 666 test.txt $ ls -l test.txt -rw-rw-rw-@ 1 ooiwt staff 64 Jul 28 09:52 test.txt would change add the permission w to both group and other users 1 . An alternative way is to just specify the changes. To remove the write permission from others, you can write: 1 2 3 $ chmod o-w test.txt $ ls -l test.txt -rw-rw-r--@ 1 ooiwt staff 64 Jul 28 09:52 test.txt","title":"The chmod command"},{"location":"unix-essentials.html#common-scenarios-for-chmod","text":"Here are some scenarios where you might need to use the chmod command: If you use the SoC Unix server to do your homework, you should prevent the directory that stores your homework from being accessible by other users. Make sure that your homework directory as the permission of 700 . If you download a file from the Internet and you do not have the permission to read it, you should do a u+r to give yourself the read permission. A program should have execution permission to run. If you have a script or an executable file that you can't run, give yourself the execution permission u+x .","title":"Common Scenarios for chmod"},{"location":"unix-essentials.html#standard-inputoutput","text":"","title":"Standard Input/Output"},{"location":"unix-essentials.html#history","text":"Two of the design decisions of Unix that lead to its simplicity are the decisions to (i) decouple the physical input/output devices from the programs, allowing programs written for Unix to read from abstract input and output devices; and (ii) make all programs read and write from these abstract input and output devices by default. Before Unix, the older operating systems often require programmers to painstakingly set up connections to the teletype machines and other devices for reading inputs and printing outputs. With Unix, programmers can now focus on solving the tasks at hand and let Unix takes care of the input and output. The two abstract devices that Unix provides are called standard input and standard output . By default, the standard input refers to the keyboard and the standard output is the terminal .","title":"History"},{"location":"unix-essentials.html#examples-using-cat-and-wc","text":"Let's look at these concepts closer, by examining some examples. Remember cat ? The cat command takes in a filename and it prints the content of the file to the standard output. 1 2 $ cat test.txt This is a test file for learning Unix file management commands. If no filename is given, cat by default try to read from the standard input. Try running: 1 $ cat You will see that the command is waiting for you to type in something. Type in anything, as soon as you press Enter , cat is going to read in the text from the standard input, as if it is the content of a file, and then prints the content to the standard output. You can keep typing, supplying text to cat , or you can type Ctrl + D to send the end-of-input command to cat . Let's look at another command, wc . wc is a utility that counts the number of lines, words, characters. If we call wc and supply it a file name, it will count the number of lines, words, and characters in that given file. 1 2 $ wc test.txt 1 11 64 test.txt The output means that there is 1 line, 11 words, and 64 characters in the file test.txt . But if you do not pass in any file name, wc is going to read in the text from the standard input, as if it is the content of a file, and prints the three counters to the standard output. Go ahead and try: 1 $ wc You will see that the wc command is waiting for you to type in something. Type in a few sentences, you can hit Enter for a new line. When you are done, type Ctrl + D . wc will count the number of lines, words, and characters for the text that you just entered.","title":"Examples using cat and wc"},{"location":"unix-essentials.html#output-redirection","text":"By defining two abstract input and output devices (or channels), Unix frees the programmers from worrying about where to read the input from and write the output to. Most of the time, we can write the output of the program to the standard output. In instances where we need to write the output to another location, we can just redirect the output. The operators > and >> are used to redirect the standard output to a file. The difference is that > will overwrite the given file, while >> will concatenate into the given file. For example: 1 2 3 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt The first command redirects the output from wc to a file named test.count , so you do not see anything printed to the output anymore. We can check by running cat on the new file test.count -- indeed the original output from wc is now stored in the file test.count . If we repeat the command wc test.txt > test.count again, you can see that the file has been overwritten with the output from wc again. But if we replace > with >> , a new line is concatenated into test.count . So the file now has two lines. 1 2 3 4 5 6 7 $ wc test.txt > test.count $ cat test.count 1 11 64 test.txt $ wc test.txt >> test.count $ cat test.count 1 11 64 test.txt 1 11 64 test.txt","title":"Output Redirection"},{"location":"unix-essentials.html#input-redirection","text":"The operator < is used to redirect a file into the standard input. So, instead of reading from the keyboard, we can now read from a file. Commands such as cat and wc already support from a file directly, so there is no difference in terms of functionality to run the commands by passing in the file name, or by using the < operator. 1 2 3 4 5 6 7 8 $ wc test.txt 1 11 64 test.txt $ wc < test.txt 1 11 64 $ cat test.txt This is a test file for learning Unix file management commands. $ cat < test.txt This is a test file for learning Unix file management commands. Note the slight difference in the output format of the second wc above -- it no longer prints the file name since from wc points of view, it is read from the standard input and not from a file, so it is not aware of the file named test.txt In most CS programming assignments, however, to keep things simple, you will be asked to read from the standard input only, so the < is a great time-saver -- you do not have to repeatedly type in the same input data over and over from the keyboard. You can just save the input data in a file, then redirect it to standard input with the < operator.","title":"Input Redirection"},{"location":"unix-essentials.html#other-useful-online-tools","text":"explainshell explain each shell command for you Giving write permission to other users is a security risk and you should not do this unless you know what you are doing. \u21a9 \u21a9 Not exactly true -- since Unix is designed to be flexible, even the root and the home directory can be changed! But let's not worry about that for now since there is no good reason to do that as a beginner. \u21a9","title":"Other Useful Online Tools"},{"location":"vim.html","text":"CS2030S vim Guide This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the usefulness of learning vim and using it as the main source code editor. appreciate the efficiency and philosophy of using vim . have experience navigating around a text buffer and manipulating text in vim be aware of how to learn more about using vim . To edit our code, we need a proper editor. Remember that ideally we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religious war, but for us in SoC, we use vim . Minimizing Hand Movements vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in convenient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ; , so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively. Multi-modal Editor vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two basic modes: NORMAL mode: where you read, navigate and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. In the NORMAL mode, you can use any of these keys I S A O (with or without Shift ) to switch to INSERT mode. To go back to NORMAL mode, press Esc . The keys I S A O have different meanings, which you will learn later. Note that most of the time you will be in NORMAL mode. So a habitual vim users would insert some text and immediately switch back to normal mode by hitting Esc . Tell vim What You Want To Do; Don't Do It Yourself In NORMAL mode, you can manipulate text in vim by issuing commands to vim . These commands are like a programming language. It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation. Let me give an example here. Suppose you have a sentence: 1 Wherever there is light, there is also a shadow. You want to remove also a from the sentence. What would you do in a typical text editor? You can use move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del . Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after a , and then press Del six times. In addition to being tedious, this is error-prone. You might highlight one additional or one less space, or hit Del one too many times. What we are used to do is to perform the action of deleting the words ourselves. For vim , we do it differently. We need to look for the word also and delete two words. This translate to the command / A L S O Enter D 2 W . / triggers a search. This is an almost universal command -- try / on Facebook (web) or on this page. A L S O Enter tells vim what you want to search. After enter, your cursor should be placed at the beginning of also . D 2 W tell vim to \"delete two words\". Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do. This is powerful since this is how our brain thinks -- \"I need to insert this here, change this word to that, remove two lines, etc\" All these maps into commands in vim . As a result, once you master vim basics, you can type as fast as you think 1 ! A common pattern for vim command consists of three parts: (i) place the cursor; (ii) performance an action; (iii) move to the new placement of the cursor. In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words). Another common command that students used is G G = Shift + G . This command is used to indent the source code in the current file. G G is the command to place the cursor at the top of the file. = is the the action (indent), and Shift + G is the command to place the cursor on the last line of the file. Be A Good Unix Citizen Not only the basic commands vim adhere to the Unix principles of composability, vim plays well with Unix shells, which add additional power to the vim . For instance, if you want to have the standard output from a command paste into the file you are editing, you can run: 1 :r! <command> : triggers the vim command line. R ask vim to read something and paste it into the current cursor location. At this point, you can pass in, for instance, another file name. But here, we enter ! , which tells vim to run a shell. We then pass the command to the shell. Whatever the command writes to the standard output, will be read and inserted into vim . Want to insert today's date? 1 :r! date Want to insert a mini calendar? 1 :r! cal Want to insert the list of all JPG pictures? 1 :r! ls *jpg You can even pass a chunk of text from vim to the standard input of another program, and replace it with what is printed to the standard output by that program. Other Reasons To Learn vim Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use vim : vim is installed by default in almost any Unix environment. Imagine if you get called to a client-side to debug a Linux server and you need to edit something -- you can rest assure that vim is there. vim is the only source code editor you need to learn and master. It works for almost any programming language. If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc. vim is extensible and programmable. It has been around for almost 30 years, and tons of plugins have been written. Whatever feature you need, there is likely a native vim command or a vim plugin for that. The only downside to using vim is that it is terminal-based (some considers it ugly) and the steep learning curve. But, in our experience, students will build up their muscle memory and are comfortable with vim after 2-3 weeks of usage. For CS2030S, there is another practical reason to learn and gain familiarity with vim . The practical exams are conducted in a sandboxed environment, which you can only access through ssh via a terminal. You only have a few choices ( emacs , nano , vim ) and vim is the only reasonable choice. Setting Up Your vim Environment Like many other Unix programs, you can configure your preferences by creating an rc (run commands) file in your home directory. These rc files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard. You can view these rc as a script that will be executed automatically whenever a program starts. For vim , the rc file is called .vimrc . The . in the front of the file name carries a special meaning in Unix. It means that this file is hidden -- you won't see it when you ls . Hiding the run command files prevent your home directory from being cluttered. To tell ls to show the hidden files, use the -a flag 1 $ ls -a We have created a .vimrc file, with CS2030S defaults, for your use. This is the basis which you can built on. To copy this file to your home directory on the PE nodes, 1 $ cp ~cs2030s/.vimrc ~ The default .vimrc expects a backup directory at location ~/.backup . This is where a previous copy of your file will be saved as backup everytime you edit a file. This feature has saved me countless of time. You can create a directory called .backup at your home directory with: 1 $ mkdir ~/.backup Lessons Now, follow through the following to get yourself familiarized with vim Lesson 1: Navigation Now, you can stay in your home directory or go back to your workshop directory. Download the following file for practice using vim in this session. 1 $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/jfk.txt The file named jfk.txt should be downloaded. Now let's start your first vim session. 1 $ vim jfk.txt When you start, you will be in NORMAL mode. For now, just move around the cursor with H J K L . Get comfortable with using the keys. Next, try ++parenthesis-left++ and ++parenthesis-right++ to move forward and backward, sentence-by-sentence. Next, try { and } to move forward and backward, paragraph-by-paragraph. Use 0 to jump to the beginning of the line, and ++dollar++ to jump to the end of the line. Use G + G to jump to the beginning of the file, and Shift + G ( G ) to jump to the last line of the file. Now try / , type in any word (or prefix of a word) and Enter . This should move the cursor to the beginning of the word. You can use N and Shift + N to move to the next match and the previous match. When you are comfortable with moving around, you can Shift + Z + Z to exit. Congratulations, you have just completed your first session in vim ! Lesson 2: Manipulating Text Now, we are going to open up the same file again and try to manipulate the text. We are going to stay in the NORMAL mode still. 1 $ vim jfk.txt Deletion Try 0 D 3 W to move the cursor to the beginning of the line and delete three words. Press U to undo. This is another lifesaver that you should remember. In vim , repeating the same command twice usually means applying it to the whole line. So D D deletes the current line. Try that. Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line. So Shift + D deletes from the current cursor until the end of the line. Copy Pasting Hit P to paste back what you just deleted. Try moving the cursor to somewhere else and paste. To copy (or yank) the current line, hit Y Y . Remember that all these commands can be composed using the movement-action-movement pattern. For instance, Shift + 9 Y Shift + 0 , which corresponds to: move to the beginning of the sentence, yank, and until the end of the sentence, basically copy the current sentence. As you have seen in the D 2 W example, you can preceed an action with a number to repeat an action multiple times. Try Y Y 9 P . You should be able to understand what just happened! Deleting a Character The X command deletes the current character. Try this exercise: At the end of the file jfk.txt , there are some typos: 1 libertyi. liberty. Change libertyi. liberty. to libtery. by positioning the cursor on the second i and delete it. Then use Shift + D to delete the extra liberty. at the end of the sentence. Visual Mode In addition to the INSERT and NORMAL modes, vim has the third mode, the VISUAL mode. You can enter the VISUAL mode by hitting V . Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank). Hitting Shift + V will allow you to select line-by-line. The VISUAL mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command. Go ahead and try to select a paragraph in jfk.txt , and hit : . You will see that 1 :'<,'> appears in the last line of the terminal. At this point, you can type in actions that you want to perform on the selected text. For instance, 1 :'<,'>w john.txt will write it to a file named john.txt . But, let's try the following: 1 :'<,'>!fmt !fmt tells vim to invoke the shell and run fmt . fmt is another simple small Unix utility that takes in a text (from standard input) and spew out formatted text in the standard output. You will see that the width of the text has changed to the default of 65. You can try something that we have seen before. Reselect the text, and hit 1 :'<,'>!wc The selected text will be replaced with the output from wc . The : command You have seen examples of : commands for writing to a file or piping selected text to an external command. The : command also opens up a large number of actions you can do in vim . Here are a few essential yet simple commands. To jump to a line, hit : followed by the line number. To open another file, hit : and then type in e <filename> To find help on a topic, hit : and then type in help <keyword> Other advanced features such as search-and-replace, changing preferences, splitting windows, opening new tabs, are also accessible from the : command. The : command prompt supports Ctrl + P and Ctrl + N for navigating back and forth your command history, just like bash . It also supports Tab for auto-completion. Lesson 3: Insert mode! Finally, we are going to try inserting some text. Remember, to use INSERT mode, we always start with a command I A O or S (may paired with Shift ) followed by the text that you want to insert, followed by Esc . Let's try I (insert). Place your cursor anywhere, hit I , and start typing, when you are done. Hit Esc . You just added some text to the file. Place your cursor anywhere, hit A (append), and start typing, when you are done. Hit Esc . A appends the text to the end of the current line. Hit O (open) and start typing, when you are done. Hit Esc . O opens up a new line for the your text. Hit S (substitute) and start typing, when you are done. Hit Esc . S substitute the current character with your text. Now try it with Shift and see the difference in behavior. Other Useful Commands Auto-Completion You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names. Auto-Indent the Whole File You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file. Splitting vim 's Viewport :sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports Search and Replace 1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement Jump to Foo.java Place your cursor on the class name, e.g., Foo . Then hit G F . Change colors 1 :color <scheme> Example, 1 :color morning To see the list of installed color schemes, type :colorscheme Space Ctrl + D Ruler and Numbers If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number. Learning More To learn more about vim , we suggest that you run vimtutor on the command line and follow through the tutorials. You can always :help <keywords> to search for the built-in help pages within vim . Once you are comfortable, you can soup up your vim with various plugins and learn how to use advanced commands (such as recording macros, folding) that are invaluable for programming. There are also many video tutorials and resources online, in addition to the introduction to vim by Yong Qi that we have shared earlier, some interesting ones are: Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins. The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\". \u21a9","title":"Using Vim"},{"location":"vim.html#cs2030s-vim-guide","text":"This article is adapted from the notes of the Unix@Home Workshop held in August 2020. After reading this article, students should appreciate the usefulness of learning vim and using it as the main source code editor. appreciate the efficiency and philosophy of using vim . have experience navigating around a text buffer and manipulating text in vim be aware of how to learn more about using vim . To edit our code, we need a proper editor. Remember that ideally we want to keep our hands on the keyboard and keep ourselves \"in the zone\" with only the terminal, the keyboard, and ourselves, so we will use a terminal-based editor: no windows, no mouse, no arrow keys, no function keys. There are only two respectable, widely available text editors in Unix -- vim and emacs , which one is better has been an ongoing religious war, but for us in SoC, we use vim .","title":"CS2030S vim Guide"},{"location":"vim.html#minimizing-hand-movements","text":"vim , like the shell, aims to minimize hand movements. Frequently used commands are positioned in convenient places on the keyboard. Let me give you a few examples. To exit vim, type Shift + Z + Z . Notice that this is located at the bottom left corner of your keyboard. For normal typing, your left hand is supposed to be placed over the keys A S D F , so you just need move slightly your left pinky to Shift and left ring finger to Z and hit them. To move the cursor, instead of using the arrow keys, vim uses H to move left, L to move right, J to move down, and K to move up. For normal typing, you right hand is supposed to be placed on J K L ; , so these arrow keys alternatives are located very near to where your right hand should be! I have a few more things to say about using H J K L to replace the arrow keys: It is not uncommon for applications to re-map other keys for movement. Many first-person shooting games uses W A S D for movement, for the same reason as vim -- it is close to the resting position of the left hand on the keyboard. The use of H J K L for movement is more ubiquitous than you think. In the Web-version of Facebook and Reddit, for instance, you can use J and K to move up and down across posts. On this website, you can use H and L to go to the previous page and the next page respectively.","title":"Minimizing Hand Movements"},{"location":"vim.html#multi-modal-editor","text":"vim is a multi-modal editor. While for most other editors makes no distinction between reading and editing, vim makes an explicit distinction between the two. vim has two basic modes: NORMAL mode: where you read, navigate and manipulate the text. INSERT mode: where you insert the text As a programmer, having a different NORMAL modes makes sense since we spend much time reading and navigating around source code. Thus, allowing the editing commands to optimized. In the NORMAL mode, you can use any of these keys I S A O (with or without Shift ) to switch to INSERT mode. To go back to NORMAL mode, press Esc . The keys I S A O have different meanings, which you will learn later. Note that most of the time you will be in NORMAL mode. So a habitual vim users would insert some text and immediately switch back to normal mode by hitting Esc .","title":"Multi-modal Editor"},{"location":"vim.html#tell-vim-what-you-want-to-do-dont-do-it-yourself","text":"In NORMAL mode, you can manipulate text in vim by issuing commands to vim . These commands are like a programming language. It is also not unlike the Unix commands, in that each command does a small thing but can be composed together to perform complex text manipulation. Let me give an example here. Suppose you have a sentence: 1 Wherever there is light, there is also a shadow. You want to remove also a from the sentence. What would you do in a typical text editor? You can use move your hand away from the keyboard, find your mouse, move your mouse cursor to highlight the text, and then hit Del . Or you could move the cursor (by mouse or by repeatedly hitting the keyboard) to place the cursor after a , and then press Del six times. In addition to being tedious, this is error-prone. You might highlight one additional or one less space, or hit Del one too many times. What we are used to do is to perform the action of deleting the words ourselves. For vim , we do it differently. We need to look for the word also and delete two words. This translate to the command / A L S O Enter D 2 W . / triggers a search. This is an almost universal command -- try / on Facebook (web) or on this page. A L S O Enter tells vim what you want to search. After enter, your cursor should be placed at the beginning of also . D 2 W tell vim to \"delete two words\". Instead of worrying about the actual actions to perform the deletion, we issue higher-level commands to describe what we want to do. This is powerful since this is how our brain thinks -- \"I need to insert this here, change this word to that, remove two lines, etc\" All these maps into commands in vim . As a result, once you master vim basics, you can type as fast as you think 1 ! A common pattern for vim command consists of three parts: (i) place the cursor; (ii) performance an action; (iii) move to the new placement of the cursor. In the example above, / A L S O Enter places the cursor, D is the action (delete), and 2 W is the movement (move the cursor forward by two words). Another common command that students used is G G = Shift + G . This command is used to indent the source code in the current file. G G is the command to place the cursor at the top of the file. = is the the action (indent), and Shift + G is the command to place the cursor on the last line of the file.","title":"Tell vim What You Want To Do; Don't Do It Yourself"},{"location":"vim.html#be-a-good-unix-citizen","text":"Not only the basic commands vim adhere to the Unix principles of composability, vim plays well with Unix shells, which add additional power to the vim . For instance, if you want to have the standard output from a command paste into the file you are editing, you can run: 1 :r! <command> : triggers the vim command line. R ask vim to read something and paste it into the current cursor location. At this point, you can pass in, for instance, another file name. But here, we enter ! , which tells vim to run a shell. We then pass the command to the shell. Whatever the command writes to the standard output, will be read and inserted into vim . Want to insert today's date? 1 :r! date Want to insert a mini calendar? 1 :r! cal Want to insert the list of all JPG pictures? 1 :r! ls *jpg You can even pass a chunk of text from vim to the standard input of another program, and replace it with what is printed to the standard output by that program.","title":"Be A Good Unix Citizen"},{"location":"vim.html#other-reasons-to-learn-vim","text":"Besides enabling you to type as fast as you think with as few hand movements as possible, there are other reasons to use vim : vim is installed by default in almost any Unix environment. Imagine if you get called to a client-side to debug a Linux server and you need to edit something -- you can rest assure that vim is there. vim is the only source code editor you need to learn and master. It works for almost any programming language. If you use IDE, you have to learn IntelliJ for Java, IDLE for Python, Visual Studio C++ for C++, etc. vim is extensible and programmable. It has been around for almost 30 years, and tons of plugins have been written. Whatever feature you need, there is likely a native vim command or a vim plugin for that. The only downside to using vim is that it is terminal-based (some considers it ugly) and the steep learning curve. But, in our experience, students will build up their muscle memory and are comfortable with vim after 2-3 weeks of usage. For CS2030S, there is another practical reason to learn and gain familiarity with vim . The practical exams are conducted in a sandboxed environment, which you can only access through ssh via a terminal. You only have a few choices ( emacs , nano , vim ) and vim is the only reasonable choice.","title":"Other Reasons To Learn vim"},{"location":"vim.html#setting-up-your-vim-environment","text":"Like many other Unix programs, you can configure your preferences by creating an rc (run commands) file in your home directory. These rc files will be read by the corresponding programs and executed line-by-line as if the text is entered into the program through a keyboard. You can view these rc as a script that will be executed automatically whenever a program starts. For vim , the rc file is called .vimrc . The . in the front of the file name carries a special meaning in Unix. It means that this file is hidden -- you won't see it when you ls . Hiding the run command files prevent your home directory from being cluttered. To tell ls to show the hidden files, use the -a flag 1 $ ls -a We have created a .vimrc file, with CS2030S defaults, for your use. This is the basis which you can built on. To copy this file to your home directory on the PE nodes, 1 $ cp ~cs2030s/.vimrc ~ The default .vimrc expects a backup directory at location ~/.backup . This is where a previous copy of your file will be saved as backup everytime you edit a file. This feature has saved me countless of time. You can create a directory called .backup at your home directory with: 1 $ mkdir ~/.backup","title":"Setting Up Your vim Environment"},{"location":"vim.html#lessons","text":"Now, follow through the following to get yourself familiarized with vim","title":"Lessons"},{"location":"vim.html#lesson-1-navigation","text":"Now, you can stay in your home directory or go back to your workshop directory. Download the following file for practice using vim in this session. 1 $ wget https://raw.githubusercontent.com/nus-unix-workshop/2021-s1/master/jfk.txt The file named jfk.txt should be downloaded. Now let's start your first vim session. 1 $ vim jfk.txt When you start, you will be in NORMAL mode. For now, just move around the cursor with H J K L . Get comfortable with using the keys. Next, try ++parenthesis-left++ and ++parenthesis-right++ to move forward and backward, sentence-by-sentence. Next, try { and } to move forward and backward, paragraph-by-paragraph. Use 0 to jump to the beginning of the line, and ++dollar++ to jump to the end of the line. Use G + G to jump to the beginning of the file, and Shift + G ( G ) to jump to the last line of the file. Now try / , type in any word (or prefix of a word) and Enter . This should move the cursor to the beginning of the word. You can use N and Shift + N to move to the next match and the previous match. When you are comfortable with moving around, you can Shift + Z + Z to exit. Congratulations, you have just completed your first session in vim !","title":"Lesson 1: Navigation"},{"location":"vim.html#lesson-2-manipulating-text","text":"Now, we are going to open up the same file again and try to manipulate the text. We are going to stay in the NORMAL mode still. 1 $ vim jfk.txt","title":"Lesson 2: Manipulating Text"},{"location":"vim.html#deletion","text":"Try 0 D 3 W to move the cursor to the beginning of the line and delete three words. Press U to undo. This is another lifesaver that you should remember. In vim , repeating the same command twice usually means applying it to the whole line. So D D deletes the current line. Try that. Pairing a command with Shift (or the capital letter version) usually means applying the action until the end of the line. So Shift + D deletes from the current cursor until the end of the line.","title":"Deletion"},{"location":"vim.html#copy-pasting","text":"Hit P to paste back what you just deleted. Try moving the cursor to somewhere else and paste. To copy (or yank) the current line, hit Y Y . Remember that all these commands can be composed using the movement-action-movement pattern. For instance, Shift + 9 Y Shift + 0 , which corresponds to: move to the beginning of the sentence, yank, and until the end of the sentence, basically copy the current sentence. As you have seen in the D 2 W example, you can preceed an action with a number to repeat an action multiple times. Try Y Y 9 P . You should be able to understand what just happened!","title":"Copy Pasting"},{"location":"vim.html#deleting-a-character","text":"The X command deletes the current character. Try this exercise: At the end of the file jfk.txt , there are some typos: 1 libertyi. liberty. Change libertyi. liberty. to libtery. by positioning the cursor on the second i and delete it. Then use Shift + D to delete the extra liberty. at the end of the sentence.","title":"Deleting a Character"},{"location":"vim.html#visual-mode","text":"In addition to the INSERT and NORMAL modes, vim has the third mode, the VISUAL mode. You can enter the VISUAL mode by hitting V . Once in visual mode, you can move your cursor to select the text and perform some actions on it (e.g., D or X to delete, Y to yank). Hitting Shift + V will allow you to select line-by-line. The VISUAL mode allows us to pipe the selected text to another Unix command, and replace it with the result of that command. Go ahead and try to select a paragraph in jfk.txt , and hit : . You will see that 1 :'<,'> appears in the last line of the terminal. At this point, you can type in actions that you want to perform on the selected text. For instance, 1 :'<,'>w john.txt will write it to a file named john.txt . But, let's try the following: 1 :'<,'>!fmt !fmt tells vim to invoke the shell and run fmt . fmt is another simple small Unix utility that takes in a text (from standard input) and spew out formatted text in the standard output. You will see that the width of the text has changed to the default of 65. You can try something that we have seen before. Reselect the text, and hit 1 :'<,'>!wc The selected text will be replaced with the output from wc .","title":"Visual Mode"},{"location":"vim.html#the-command","text":"You have seen examples of : commands for writing to a file or piping selected text to an external command. The : command also opens up a large number of actions you can do in vim . Here are a few essential yet simple commands. To jump to a line, hit : followed by the line number. To open another file, hit : and then type in e <filename> To find help on a topic, hit : and then type in help <keyword> Other advanced features such as search-and-replace, changing preferences, splitting windows, opening new tabs, are also accessible from the : command. The : command prompt supports Ctrl + P and Ctrl + N for navigating back and forth your command history, just like bash . It also supports Tab for auto-completion.","title":"The : command"},{"location":"vim.html#lesson-3-insert-mode","text":"Finally, we are going to try inserting some text. Remember, to use INSERT mode, we always start with a command I A O or S (may paired with Shift ) followed by the text that you want to insert, followed by Esc . Let's try I (insert). Place your cursor anywhere, hit I , and start typing, when you are done. Hit Esc . You just added some text to the file. Place your cursor anywhere, hit A (append), and start typing, when you are done. Hit Esc . A appends the text to the end of the current line. Hit O (open) and start typing, when you are done. Hit Esc . O opens up a new line for the your text. Hit S (substitute) and start typing, when you are done. Hit Esc . S substitute the current character with your text. Now try it with Shift and see the difference in behavior.","title":"Lesson 3: Insert mode!"},{"location":"vim.html#other-useful-commands","text":"","title":"Other Useful Commands"},{"location":"vim.html#auto-completion","text":"You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names.","title":"Auto-Completion"},{"location":"vim.html#auto-indent-the-whole-file","text":"You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file.","title":"Auto-Indent the Whole File"},{"location":"vim.html#splitting-vims-viewport","text":":sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports","title":"Splitting vim's Viewport"},{"location":"vim.html#search-and-replace","text":"1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement","title":"Search and Replace"},{"location":"vim.html#jump-to-foojava","text":"Place your cursor on the class name, e.g., Foo . Then hit G F .","title":"Jump to Foo.java"},{"location":"vim.html#change-colors","text":"1 :color <scheme> Example, 1 :color morning To see the list of installed color schemes, type :colorscheme Space Ctrl + D","title":"Change colors"},{"location":"vim.html#ruler-and-numbers","text":"If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number.","title":"Ruler and Numbers"},{"location":"vim.html#learning-more","text":"To learn more about vim , we suggest that you run vimtutor on the command line and follow through the tutorials. You can always :help <keywords> to search for the built-in help pages within vim . Once you are comfortable, you can soup up your vim with various plugins and learn how to use advanced commands (such as recording macros, folding) that are invaluable for programming. There are also many video tutorials and resources online, in addition to the introduction to vim by Yong Qi that we have shared earlier, some interesting ones are: Vim: Precision Editing at the Speed of Thought : A talk by Drew Neil Vim Adventure : An adventure game for learning vim Vim Casts : Videos and articles for teaching vim Vim Video Tutorials by Derek Wyatt Vim Awesome : Directory of plugins. The book Practical Vim by Drew Neil has the subtitle \"Edit text at the speed of thought\". \u21a9","title":"Learning More"},{"location":"slides/index.html","text":"How to create slides with markdown and remark.js Slides are separated by: 1 --- For title slides or slides with a single statement/keyword, use 1 2 --- class: middle,center For title with bullet points, use 1 2 --- class: middle If the code is too long, try to make the content wider 1 2 --- class: wide If text or code are too tall to fit, wrap them with .small[ and ] 1 2 3 .small[ content here ] For something even smaller, use .smaller[..] or .tiny[..] . To insert image, 1 ![text](image.jpg) with scale 1 ![:scale 50%](image.jpg) For background image (fits the whole slide) Add this just after the class: 1 background-image : url ( image . png )","title":"Index"},{"location":"slides/index.html#how-to-create-slides-with-markdown-and-remarkjs","text":"","title":"How to create slides with markdown and remark.js"},{"location":"slides/index.html#slides-are-separated-by","text":"1 ---","title":"Slides are separated by:"},{"location":"slides/index.html#for-title-slides-or-slides-with-a-single-statementkeyword-use","text":"1 2 --- class: middle,center","title":"For title slides or slides with a single statement/keyword, use"},{"location":"slides/index.html#for-title-with-bullet-points-use","text":"1 2 --- class: middle","title":"For title with bullet points, use"},{"location":"slides/index.html#if-the-code-is-too-long-try-to-make-the-content-wider","text":"1 2 --- class: wide","title":"If the code is too long, try to make the content wider"},{"location":"slides/index.html#if-text-or-code-are-too-tall-to-fit-wrap-them-with-small-and","text":"1 2 3 .small[ content here ]","title":"If text or code are too tall to fit, wrap them with .small[ and ]"},{"location":"slides/index.html#for-something-even-smaller-use-smaller-or-tiny","text":"","title":"For something even smaller, use .smaller[..] or .tiny[..]."},{"location":"slides/index.html#to-insert-image","text":"1 ![text](image.jpg) with scale 1 ![:scale 50%](image.jpg)","title":"To insert image,"},{"location":"slides/index.html#for-background-image-fits-the-whole-slide","text":"Add this just after the class: 1 background-image : url ( image . png )","title":"For background image (fits the whole slide)"}]}